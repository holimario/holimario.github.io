<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DDBM与DBIM</title>
      <link href="/2025/03/31/99a5c2ac.html"/>
      <url>/2025/03/31/99a5c2ac.html</url>
      
        <content type="html"><![CDATA[<p>本文参考《DENOISING DIFFUSION BRIDGE MODELS》与《DIFFUSION BRIDGE IMPLICIT MODELS》。</p><h2 id="DDBM"><a href="#DDBM" class="headerlink" title="DDBM"></a>DDBM</h2><p>DDPM等工作可以实现从噪声空间到数据空间的映射，但是很多情形下我们的输入源头其实是来自数据空间A的数据，希望将其映射到另一个数据空间B，这样的话DDPM的一般需要引入条件来指导从噪声空间到数据空间的映射。DDBM则提出了一种新型的扩散桥模型，可以实现两个数据空间的直接映射，比如将低质量图片映射为高质量图片。</p><p>关于DDBM的理论推导已经完全被《随机微分方程理论》中的内容覆盖掉了，因此不再复述关于Doob’s h transform的内容。</p><h2 id="DBIM"><a href="#DBIM" class="headerlink" title="DBIM"></a>DBIM</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成式模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机微分方程理论</title>
      <link href="/2025/03/30/50e83c1b.html"/>
      <url>/2025/03/30/50e83c1b.html</url>
      
        <content type="html"><![CDATA[<p>在阅读有关扩散模型、扩散桥模型的相关理论论文的时候，深感学习随机微分方程相关理论的重要性，因此参考北大刘勇老师的《应用随机分析》的讲义以及Simo Särkkä与Arno Solin的《Applied Stochastic Differential Equations》【这本书没有介绍一些随机过程中的基础概念，而是直接切入到了SDE，因此很多地方的叙述不太完整，很多等号实际上是均方极限，但是对于快速想要入门的人还是挺有帮助的】撰写此文。</p><p>【待补全：基础概率论公设】</p><p>【待补全：ODE求解】</p><h2 id="维纳过程性质解析"><a href="#维纳过程性质解析" class="headerlink" title="维纳过程性质解析"></a>维纳过程性质解析</h2><p>【待补充】</p><h2 id="It-hat-o-积分与SDE"><a href="#It-hat-o-积分与SDE" class="headerlink" title="It$\hat o$积分与SDE"></a>It$\hat o$积分与SDE</h2><p>对于一个SDE，很多时候我们希望求解其分布特性，但是现实是我们无法直接对SDE进行常规的积分来得到对该分布的估计，这时候就需要It$\hat o$积分了(也被称为伊藤积分)。</p><p>对于如下形式的通用SDE【<strong>其中${\bf w}(t)$为零均值白高斯过程，自相关函数为狄拉克函数，也就是如果只关注某个时刻的方差，那么该方差为无穷，要注意的是其并非维纳过程，这要和此前的博文相区分</strong>】</p><script type="math/tex; mode=display">\frac{d\bf x}{dt}={\bf f}({\bf x},t)+{\bf L}({\bf x},t){\bf w}(t)</script><p>常用的积分手段不可行的一个重要原因就是白噪声的不连续性(而不是其随机性)，即使给定一个确定的白噪声的实现，其不连续性仍然无法处理。下面我们开始积分</p><script type="math/tex; mode=display">{\bf x}(t)-{\bf x}(t_0)=\int_{t_0}^t{\bf f}({\bf x}(t),t)dt+\int_{t_0}^t{\bf L}({\bf x}(t),t){\bf w}(t)dt</script><p>看到等式右侧的第二项，它就是问题的来源，${\bf w}(t)$不是连续的！在黎曼积分中，其应该被定义为</p><script type="math/tex; mode=display">\int_{t_0}^t{\bf L}({\bf x}(t),t){\bf w}(t)dt=\lim_{n\to\infty}\sum_k{\bf L}({\bf x}(t_k^*),t_k^*){\bf w}(t_k^*)(t_{k+1}-t_k)</script><p>其中$t_0&lt;t_1&lt;…&lt;t_n$并且$t_k^*\in[t_k,t_{k+1}]$。假如${\bf w}(t)$是连续的，那么我们就比较容易确定出该黎曼积分的上界和下界，通过证明上界和下界的值相同，这样黎曼积分的值就有意义了，但可惜的是${\bf w}(t)$既不是有界的，也不是随时间连续的。</p><p>或许我们也可以尝试Stieltjes积分(一种比黎曼积分更通用的积分形式)，在该情形下，我们认为${\bf w}(t)dt$是另一个过程${\mathbf\beta}(t)$的增量，那么</p><script type="math/tex; mode=display">\int_{t_0}^t{\bf L}({\bf x}(t),t){\bf w}(t)dt=\int_{t_0}^t{\bf L}({\bf x}(t),t)d\beta(t)</script><p>实际上$\beta(t)\in\mathbb{R}^S$就是(连续随机过程)布朗运动过程，其满足如下性质</p><ol><li>任何增量$\Delta\beta_k=\beta(t_{k+1})-\beta(t_k)$都是零均值高斯分布，且方差矩阵为${\bf Q}(t_{k+1}-t_k)$</li><li>不交叠的两个增量彼此独立</li><li>初值为零</li></ol><p>通过这三个性质，我们可以进一步推导得到</p><ol><li>$\beta(t)$各处不可微分</li><li>白噪声${\bf w}(t)$可以被视为$\frac{d\beta(t)}{dt}$</li></ol><p>但是可以看到Stieltjes积分任然面临类似的积分问题</p><script type="math/tex; mode=display">\int_{t_0}^t{\bf L}({\bf x}(t),t)d\beta=\lim_{n\to\infty}\sum_k{\bf L}({\bf x}(t_k^*),t_k^*)[\beta(t_{k+1})-\beta(t_k)]</script><p>其中$t_0&lt;t_1&lt;…&lt;t_n$并且$t_k^<em>\in[t_k,t_{k+1}]$。该积分要求极限结果与$t_k^</em>$位置选取独立，但是对于存在布朗运动的SDE(${\bf x}(t)$本身的变化不可忽略)，情况并非如此【<strong>此处有待进一步分析</strong>】。</p><p>而It$\hat o$随机积分则比较好地处理了这些问题。其核心的一个观察是，如果我们将$t_k^<em>$确定下来，令$t_k^</em>=t_k$，那么积分形式变为【取不同的边的话，积分结果是不同的】</p><script type="math/tex; mode=display">\int_{t_0}^t{\bf L}({\bf x}(t),t)d\beta=\lim_{n\to\infty}\sum_k{\bf L}({\bf x}(t_k),t_k)[\beta(t_{k+1})-\beta(t_k)]</script><p>这个极限就变为唯一了【<strong>主要还是考虑到$\beta(t)$之间的相关性</strong>】，这样我们就可以求解积分</p><script type="math/tex; mode=display">{\bf x}(t)-{\bf x}(t_0)=\int_{t_0}^t{\bf f}({\bf x}(t),t)dt+\int_{t_0}^t{\bf L}({\bf x}(t),t)d\beta(t)</script><p>也可以写为微分形式</p><script type="math/tex; mode=display">d{\bf x}={\bf f}({\bf x},t)dt+{\bf L}({\bf x},t)d{\bf \beta}(t)</script><blockquote><p> 考虑如下的随机过程积分</p><script type="math/tex; mode=display">\begin{align}\int_0^t\beta(t)d\beta(t)\\=\lim_{n\to\infty}\sum_k\beta(t_k)[\beta(t_{k+1})-\beta(t_k)]\\=\lim_{n\to\infty}\sum_k\left[-\frac{1}{2}(\beta(t_{k+1})-\beta(t_k))^2+\frac{1}{2}(\beta^2(t_{k+1})-\beta^2(t_k))\right]\\=-\frac{1}{2}t+\frac{1}{2}\beta^2(t)\end{align}</script><p>这里用到了<strong>均方极限</strong>【这个概念有待补充】</p><script type="math/tex; mode=display">\mathbb{E}\left(\lim_{n\to\infty}\sum_k((\beta(t_{k+1})-\beta(t_k))^2)-t\right)^2=0</script><p>上述随机过程积分可以写为</p><script type="math/tex; mode=display">d\left[\frac{1}{2}\beta^2(t)\right]=\beta(t)d\beta(t)+\frac{1}{2}dt</script></blockquote><p><strong>伊藤公式</strong>：设${\bf x}(t)$为伊藤过程(<strong>即其SDE中的维纳过程项的伊藤积分存在</strong>)，那么考虑一个关于${\bf x}(t)$的任意标量函数$\phi({\bf x}(t),t)$，$\phi$的伊藤微分，也就是$\phi$的伊藤SDE为</p><script type="math/tex; mode=display">\begin{align}d\phi=\frac{\partial \phi}{\partial t}dt+\sum_i\frac{\partial\phi}{\partial x_i}dx_i+\frac{1}{2}\sum_{i,j}\left(\frac{\partial^2\phi}{\partial x_i\partial x_j}\right)dx_idx_j\\=\frac{\partial\phi}{\partial t}dt+(\nabla\phi)^Td{\bf x}+\frac{1}{2}\trace\{(\nabla\nabla^T\phi)d{\bf x}d{\bf x}^T\}\end{align}</script><p>【在使用时，常用到关系$d\beta dt={\bf 0}$，$dtd\beta={\bf 0}$，$d\beta d\beta^T={\bf Q}dt$】</p><p>通过适当地构造$\phi$，可以将原本的SDE转变为易于求解的形式，从而得到${\bf x}_t$的分布形式。</p><h2 id="Kolmogorov方程"><a href="#Kolmogorov方程" class="headerlink" title="Kolmogorov方程"></a>Kolmogorov方程</h2><h3 id="Kolmogorov向前方程"><a href="#Kolmogorov向前方程" class="headerlink" title="Kolmogorov向前方程"></a>Kolmogorov向前方程</h3><p>也被称为Fokker-Planck方程、Kolmogorov第二方程，可以用于求解前向转移概率密度函数。</p><p>对于一维SDE</p><script type="math/tex; mode=display">d\xi_t=b(t,\xi_t)dt+\sigma(t,\xi_t)dB_t</script><p>那么其正向转移密度函数是如下偏微分方程的基本解</p><script type="math/tex; mode=display">\frac{\partial}{\partial t}p(x(t)|y(s))=\frac{1}{2}\frac{\partial^2}{\partial x^2}(\sigma(t,x(t))^2p(x(t)|y(s)))-\frac{\partial}{\partial x}(b(t,x(t))p(x(t)|y(s)))</script><p>【其中$s&lt;t$】</p><p>Fokker-Planck方程是非条件概率的Kolmogorov向前方程。</p><p>对于多维形式的SDE</p><script type="math/tex; mode=display">d\xi_t={\bf b}(t,\xi_t)dt+{\bf\Sigma}(t,\xi_t)dB_t</script><p>其向前方程为</p><script type="math/tex; mode=display">\frac{\partial p({\bf x}(t)|{\bf y}(s))}{\partial t}=\frac{1}{2}\sum_{i,j=1}^d\frac{\partial^2}{\partial x_i\partial x_j}\left[\sum_{k=1}^d{\bf\Sigma}_{ik}(t,{\bf x}(t)){\bf\Sigma}_{jk}(t,{\bf x}(t))p({\bf x}(t)|{\bf y}(s))\right]-\sum_{i=1}^d\frac{\partial}{\partial x_i}\left[b_i(t,{\bf x}(t))p({\bf x}(t)|{\bf y}(s))\right]</script><p>也可以写为$\nabla$算子表示的形式，更加简洁【DDBM中给出的形式】</p><script type="math/tex; mode=display">\frac{\partial}{\partial t}p({\bf x}_t|{\bf x}_s)=-\nabla_{ {\bf x}_t}\cdot\left[{\bf b}(t,{\bf x}_t)p({\bf x}_t|{\bf x}_s)\right]+\frac{1}{2}\nabla\cdot\left(\nabla\cdot\left[{\bf\Sigma}(t,{\bf x}_t){\bf\Sigma}(t,{\bf x}_t)^Tp({\bf x}_t|{\bf x}_s)\right]\right)</script><h3 id="Kolmogorov向后方程"><a href="#Kolmogorov向后方程" class="headerlink" title="Kolmogorov向后方程"></a>Kolmogorov向后方程</h3><p>也被称为Kolmogorov第一方程，可以用于求解反向转移概率密度函数。</p><p>对于一维SDE</p><script type="math/tex; mode=display">d\xi_t=b(t,\xi_t)dt+\sigma(t,\xi_t)dB_t</script><p>那么其反向转移密度函数是如下偏微分方程的基本解</p><script type="math/tex; mode=display">-\frac{\partial}{\partial t}p(y(s)|x(t))=\frac{1}{2}(\sigma(t,x(t))^2\frac{\partial^2}{\partial x^2}p(y(s)|x(t)))+b(t,x(t))\frac{\partial}{\partial x}p(y(s)|x(t))</script><p>【其中$s&lt;t$】</p><p>对于多维形式的SDE</p><script type="math/tex; mode=display">d\xi_t={\bf b}(t,\xi_t)dt+{\bf\Sigma}(t,\xi_t)dB_t</script><p>其向后方程为</p><script type="math/tex; mode=display">-\frac{\partial p({\bf y}(s)|{\bf x}(t))}{\partial t}=\frac{1}{2}\sum_{i,j=1}^d\sum_{k=1}^d{\bf\Sigma}_{ik}(t,{\bf x}(t)){\bf\Sigma}_{jk}(t,{\bf x}(t))\frac{\partial^2}{\partial x_i\partial x_j}\left[p({\bf y}(s)|{\bf x}(t))\right]+\sum_{i=1}^db_i(t,{\bf x}(t))\frac{\partial}{\partial x_i}\left[p({\bf y}(s)|{\bf x}(t))\right]</script><p>也可以写为$\nabla$算子表示的形式，更加简洁【DDBM中给出的形式】</p><script type="math/tex; mode=display">-\frac{\partial}{\partial t}p({\bf x}_s|{\bf x}_t)={\bf b}(t,{\bf x}_t)\cdot\nabla_{ {\bf x}_t}\left[p({\bf x}_t|{\bf x}_s)\right]+\frac{1}{2}\trace\left[{\bf\Sigma}(t,{\bf x}_t){\bf\Sigma}(t,{\bf x}_t)^T\nabla^2p({\bf x}_t|{\bf x}_s)\right]</script><h2 id="Lamperti-Transform"><a href="#Lamperti-Transform" class="headerlink" title="Lamperti Transform"></a>Lamperti Transform</h2><p>假如给定一个如下形式的SDE</p><script type="math/tex; mode=display">d{\bf x}={\bf f}({\bf x},t)dt+{\bf L}({\bf x},t)d\beta</script><p>可以通过Lamperti Transform，将其变换为如下形式</p><script type="math/tex; mode=display">d{\bf y}={\bf g}({\bf y},t)dt+d\beta</script><p>即将噪声项前与${\bf L}({\bf x},t)$相关的项转移到$dt$微分前，这一操作在进行数值模拟运算的时候很有帮助，因为对于加性的噪声，处理会比较方便。</p><p>首先考虑一个标量形式</p><script type="math/tex; mode=display">dx=f(x,t)dt+L(x,t)d\beta</script><p>那么可以定义如下的变换形式</p><script type="math/tex; mode=display">y=h(x,t)+\int_\xi^t\frac{1}{L(u,t)}du</script><p>其中$\xi$为任意点。那么采用It$\hat o$公式到$h$上，可以得到</p><script type="math/tex; mode=display">\begin{align}dy=\frac{\partial h(x,t)}{\partial t}dt+\left(\frac{1}{L(x,t)}\right)dx+\frac{1}{2}\left(-\frac{\partial L(x,t)/\partial x}{L^2(x,t)}\right)dx^2\\=\left[\frac{\partial }{\partial t}\int_\xi^x\frac{1}{L(u,t)}du\right]dt+\left(\frac{1}{L(x,t)}\right)(f(x,t)dt+L(x,t)d\beta)+\frac{1}{2}\left(-\frac{\partial L(x,t)/\partial x}{L^2(x,t)}\right)L^2(x,t)dt\\=\left(\frac{\partial}{\partial t}\int_\xi^x\frac{1}{L(u,t)}du+\frac{f(x,t)}{L(x,t)}-\frac{1}{2}\frac{\partial L(x,t)}{\partial x}\right)dt+d\beta\end{align}</script><p>假如$x=h^{-1}(y,t)$存在，那么我们就可以构造出</p><script type="math/tex; mode=display">g(y,t)=\left(\frac{\partial}{\partial t}\int_\xi^x\frac{1}{L(u,t)}du+\frac{f(x,t)}{L(x,t)}-\frac{1}{2}\frac{\partial L(x,t)}{\partial x}\right)\Big|_{x=h^{-1}(y,t)}</script><h2 id="Girsanov-Theorem"><a href="#Girsanov-Theorem" class="headerlink" title="Girsanov Theorem"></a>Girsanov Theorem</h2><p>希望将原本的概率分布转变为另一个概率分布，可以通过该定理进行测度变换，使得仅改变SDE中的漂移项系数，而不改变扩散项前的方差系数。【有待进一步补充】</p><h2 id="Doob’s-h-transform"><a href="#Doob’s-h-transform" class="headerlink" title="Doob’s h transform"></a>Doob’s h transform</h2><p>在一个给定的SDE下，我们可以通过It$\hat o$积分或者Kolmogorov方程求解出其对应的随时间变化的密度转移函数。有时候我们希望对已有的一个SDE过程进行修正，使其密度转移函数更加满足我们的期望(比如更加倾向于朝着某个方向移动)，Doob’s h transform就是这样的一个数学工具，使得我们可以按照自己期望的策略对现有的SDE的密度转移函数进行修改，并进而反推出其对应的SDE究竟应该是什么样的。</p><p>定义$p({\bf y},t’|{\bf x},t):=p({\bf y}(t’)|{\bf x}(t))$​为现在SDE的状态转移密度函数。那么我们现在可以定义另一个马尔可夫过程的状态转移密度函数$p^h({\bf y},t’|{\bf x},t):=p^h({\bf y}(t’)|{\bf x}(t))$</p><script type="math/tex; mode=display">p^h({\bf y},t+s|{\bf x},t)=p({\bf y},t+s|{\bf x},t)\frac{h(t+s,{\bf y})}{h(t,{\bf x})}</script><p>其中函数$h(t,{\bf x})$就是我们设定的修正项，使得在$t$时刻处于状态${\bf x}$的随机变量在$t+s$时刻【相较于原本的状态转移密度函数】更倾向于移动向$h(t+s,{\bf y})$大于$h(t,{\bf x})$的状态${\bf y}$。当然，为了保证调整之后的状态转移密度函数仍然是归一化的，$h(t,{\bf x})$需要满足如下的时空正则特性【对于任意$s&gt;0$均成立】</p><script type="math/tex; mode=display">h(t,{\bf x})=\int p({\bf y},t+s|{\bf x},t)h(t+s,{\bf y})d{\bf y}</script><p>$h(t,{\bf x})$满足上述时空正则特性时，可以保证上述等式中$p^h({\bf y},t+s|{\bf x},t)$的积分为$1$。</p><blockquote><p><strong>广义生成器</strong>：对于$\phi({\bf x},t)$，其具有广义生成器【<strong>这里Simo Särkkä的书中的定义貌似是错的，应该将期望改为条件期望</strong>】</p><script type="math/tex; mode=display">\mathcal{A}_t\phi({\bf x},t)=\lim_{s\downarrow 0}\frac{\mathbb{E}[\phi({\bf x}(t+s),t+s)|{\bf x}(t)]-\phi({\bf x}(t),t)}{s}</script><p>【下箭头表示单调递减收敛于】</p><p>特别的，对于如下SDE</p><script type="math/tex; mode=display">d{\bf x}={\bf f}({\bf x},t)dt+{\bf L}({\bf x},t)d\beta</script><p>其广义生成器满足如下形式</p><script type="math/tex; mode=display">\mathcal{A}_t(\cdot)=\frac{\partial(\cdot)}{\partial t}+\sum_i\frac{\partial (\cdot)}{\partial x_i}f_i({\bf x},t)+\frac{1}{2}\sum_{i,j}\left(\frac{\partial^2(\cdot)}{\partial x_i\partial x_j}\right)[{\bf L}({\bf x},t){\bf Q}{\bf L}^T({\bf x},t)]_{ij}</script></blockquote><p>我们可以验证</p><script type="math/tex; mode=display">\begin{align}\mathbb{E}[h(t,{\bf x})]\\=\int p({\bf x},t)\int p({\bf y},t+s|{\bf x},t)h(t+s,{\bf y})d{\bf y}d{\bf x}\\=\int p({\bf y},t+s)h(t+s,{\bf y})d{\bf y}\\=\mathbb{E}[h(t+s,{\bf x})]\end{align}</script><p>证明$h(t,{\bf x})$的期望是不随着时间变化的，进一步，我们还可以证明$h(t,{\bf x})$是鞅【给定过去序列，其未来期望为过去序列的末尾值】【不过这个严格意义上来说，也不是鞅，因为条件不是一个序列】【下面这个证明用到了SDE马尔科夫链性质】</p><script type="math/tex; mode=display">\begin{align}\mathbb{E}[h(t+s,{\bf x}(t+s)|{ {\bf x}(t)}]\\=\int p({\bf x}',t+s|{\bf x},t)\int p({\bf y},t+s'|{\bf x}',t+s)h(t+s',{\bf y})d{\bf y}d{\bf x}'\\=\int p({\bf y},t+s'|{\bf x},t)h(t+s,{\bf y})d{\bf y}\\=h(t,{\bf x})\end{align}</script><p>这也意味着$\mathcal{A}_t h(t,{\bf x})=0$。那么下面我们可以基于生成元的性质来推理出根据$h(t,{\bf x})$修正后的随机过程的SDE形式【<strong>Simo Särkkä的书中的这一部分有一点typo错误</strong>】</p><script type="math/tex; mode=display">\begin{align}\mathcal{A}^h_t\phi({\bf x})\\=\lim_{s\downarrow 0}\frac{\mathbb{E}^h[\phi({\bf x}(t+s))|{\bf x}(t)]-\phi({\bf x}(t))}{s}\\=\lim_{s\downarrow 0}\frac{\mathbb{E}^h[\phi({\bf x}(t+s))h(t+s,{\bf x})|{\bf x}(t)]-\phi({\bf x}(t))h(t,{\bf x})}{sh(t,{\bf x})}\\=\frac{1}{h(t,{\bf x})}\mathcal{A}_t\{h(t,{\bf x})\phi({\bf x})\}\\=\frac{1}{h(t,{\bf x})}\Bigg\{\underbrace{\begin{align}\left[\frac{\partial h(t,{\bf x})}{\partial t}+\sum_i\frac{\partial h(t,{\bf x})}{\partial x_i}f_i({\bf x},t)+\\\frac{1}{2}\sum_{i,j}\left(\frac{\partial^2h(t,{\bf x})}{\partial x_i\partial x_j}\right)[{\bf L}({\bf x},t){\bf Q}{\bf L}^T({\bf x},t)]_{ij}\right]\end{align}}_{\mathcal{A}_th(t,{\bf x})=0}\phi({\bf x})\\+\sum_i h(t,{\bf x})\frac{\partial\phi({\bf x})}{\partial x_i}f_i({\bf x},t)+\frac{1}{2}\sum_{i,j}\Bigg[\frac{\partial h(t,{\bf x})}{\partial x_j}\frac{\partial \phi({\bf x})}{\partial x_i}+\frac{\partial h(t,{\bf x})}{\partial x_i}\frac{\partial\phi({\bf x})}{\partial x_j}\\+h(t,{\bf x})\frac{\partial^2\phi({\bf x})}{\partial x_i\partial x_j}\Bigg][{\bf L}({\bf x},t){\bf Q}{\bf L}^T({\bf x},t)]_{ij}\Bigg\}\\=\frac{1}{h(t,{\bf x})}\Bigg\{\sum_i h(t,{\bf x})\frac{\partial\phi({\bf x})}{\partial x_i}f_i({\bf x},t)+\frac{1}{2}\sum_{i,j}\Bigg[\frac{\partial h(t,{\bf x})}{\partial x_j}\frac{\partial \phi({\bf x})}{\partial x_i}+\frac{\partial h(t,{\bf x})}{\partial x_i}\frac{\partial\phi({\bf x})}{\partial x_j}\\+h(t,{\bf x})\frac{\partial^2\phi({\bf x})}{\partial x_i\partial x_j}\Bigg][{\bf L}({\bf x},t){\bf Q}{\bf L}^T({\bf x},t)]_{ij}\Bigg\}\\=\sum_i\Bigg[f_i({\bf x},t)+\left[{\bf L}({\bf x},t){\bf Q}{\bf L}^T({\bf x},t)\frac{\nabla h(t,{\bf x})}{h(t,{\bf x})}\right]_i\Bigg]\frac{\partial\phi({\bf x})}{\partial x_i}+\frac{1}{2}\sum_{ij}\frac{\partial^2\phi({\bf x})}{\partial x_i\partial x_j}[{\bf L}({\bf x},t){\bf Q}{\bf L}^T({\bf x},t)]_{ij}\end{align}</script><p>对比我们提到出的形式，对照生成元和SDE的对应关系，可以得到新的状态转移函数对应的SDE为</p><script type="math/tex; mode=display">\begin{align}d{\bf x}=\left[{\bf f}({\bf x},t)+{\bf L}({\bf x}){\bf Q}{\bf L}^T({\bf x},t)\frac{\nabla h(t,{\bf x})}{h(t,{\bf x})}\right]dt+{\bf L}d\beta\\=\left[{\bf f}({\bf x},t)+{\bf L}({\bf x}){\bf Q}{\bf L}^T({\bf x},t)\nabla\log h(t,{\bf x})\right]dt+{\bf L}d\beta\end{align}</script><p>在有个这个变换之后，我们实际上可以修改任何形式的扩散模型，使其在特定时刻变为我们想要的定点，比如我们想要调整某个现有扩散过程，使其在$T$时刻到达${\bf x}(T)$，那么调整后的SDE应该为如下所示</p><script type="math/tex; mode=display">d{\bf x}=[{\bf f}({\bf x},t)+{\bf L}({\bf x},t){\bf Q}{\bf L}^T({\bf x},t)\nabla_{ {\bf x}(t)}\log p({\bf x}(T)|{\bf x}(t))]dt+{\bf L}({\bf x},t)d\beta</script><p>证明比较简单，根据贝叶斯法则</p><script type="math/tex; mode=display">\begin{align}p({\bf x}(t+s)|{\bf x}(t),{\bf x}(T))=\frac{p({\bf x}(T)|{\bf x}(t+s),{\bf x}(t))p({\bf x}(t+s)|{\bf x}(t))}{p({\bf x}(T)|{\bf x}(t))}\\=\frac{p({\bf x}(T)|{\bf x}(t+s))p({\bf x}(t+s)|{\bf x}(t))}{p({\bf x}(T)|{\bf x}(t))}\end{align}</script><p>我们希望调整后的状态转移函数$p({\bf x}(t+s)|{\bf x}(t))$的行为近似于$p({\bf x}(t+s)|{\bf x}(t),{\bf x}(T))$的行为，这样的话，我们只需令</p><script type="math/tex; mode=display">h(t,{\bf x})=p({\bf x}(T)|{\bf x}(t))</script><p>这个$h$实际上也是自然满足时空约束的(当然，即使不满足，我们或许也可以设法增加一些修正因子)</p><script type="math/tex; mode=display">p({\bf x}(T)|{\bf x}(t))=\int p({\bf x}(t+s)|{\bf x}(t))p({\bf x}(T)|{\bf x}(t+s))d{\bf x}(t+s)</script><p>对于上述求解得到的SDE，很容易可以求得其反向过程SDE</p><script type="math/tex; mode=display">d{\bf x}=\{ \hat{\bf f}({\bf x},t)-\nabla_{\bf x}\cdot[{\bf L}({\bf x},t){\bf L}({\bf x},t)^T]-{\bf L}({\bf x},t){\bf L}({\bf x},t)^T\nabla_{\bf x}\log \hat q({\bf x},t)\}dt+{\bf L}({\bf x},t)d\bar{\bf w}</script><p>其中</p><script type="math/tex; mode=display">\hat{\bf f}({\bf x},t)={\bf f}({\bf x},t)+{\bf L}({\bf x},t){\bf Q}{\bf L}^T({\bf x},t)\nabla_{ {\bf x}(t)}\log p({\bf x}(T)|{\bf x}(t))</script><p>$\hat q({\bf x},t)$为新的SDE过程的概率分布【其实就等于$p({\bf x}(t)|{\bf x}(T))$】。其对应的反向(ODE其实无所谓正向和反向)ODE为</p><script type="math/tex; mode=display">\begin{align}d{\bf x}=\left\{ \hat{\bf f}({\bf x},t)-\frac{1}{2}\nabla\cdot[{\bf L}({\bf x},t){\bf L}({\bf x},t)^T]-\frac{1}{2}{\bf L}({\bf x},t){\bf L}({\bf x},t)^T\nabla_{\bf x}\log \hat q_t({\bf x})\right\}dt\\=\left\{ {\bf f}({\bf x},t)+{\bf L}({\bf x},t){\bf Q}{\bf L}^T({\bf x},t)\nabla_{ {\bf x}(t)}\log p({\bf x}(T)|{\bf x}(t))-\frac{1}{2}\nabla\cdot[{\bf L}({\bf x},t){\bf L}({\bf x},t)^T]-\frac{1}{2}{\bf L}({\bf x},t){\bf L}({\bf x},t)^T\nabla_{\bf x}\log p({\bf x}(t)|{\bf x}(T))\right\}dt\end{align}</script>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩散桥</title>
      <link href="/2025/03/29/b88744a.html"/>
      <url>/2025/03/29/b88744a.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成式模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性模型</title>
      <link href="/2025/03/29/aad91066.html"/>
      <url>/2025/03/29/aad91066.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Analytic-DPM与DPM-solver</title>
      <link href="/2025/03/20/ba24de2.html"/>
      <url>/2025/03/20/ba24de2.html</url>
      
        <content type="html"><![CDATA[<h2 id="Analytic-DPM"><a href="#Analytic-DPM" class="headerlink" title="Analytic-DPM"></a>Analytic-DPM</h2><p>这篇文章提出，目前诸如DDPM和DDIM等模型在最优化ELBO的过程中，存在一个潜在的优化空间是，在给定的前向扩散过程的超参数下，其一般认为反向扩散过程的方差$\sigma_n^2$就是</p><h2 id="DPM-solver"><a href="#DPM-solver" class="headerlink" title="DPM-solver"></a>DPM-solver</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成式模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩散模型的SDE、ODE视角以及Fokker-Planck方程</title>
      <link href="/2025/03/18/a872bcc1.html"/>
      <url>/2025/03/18/a872bcc1.html</url>
      
        <content type="html"><![CDATA[<p>本文参考《Tutorial on Diffusion Models for Imaging and Vision》【<strong>该文中对DSM的${\bf x}’$替换为${\bf x}$的部分的叙述貌似有点小问题以及最后对fokker-Planck方程的部分的一个例子也有点小问题</strong>】以及《 SCORE-BASED GENERATIVE MODELING THROUGH STOCHASTIC DIFFERENTIAL EQUATIONS》。</p><h2 id="得分匹配模型"><a href="#得分匹配模型" class="headerlink" title="得分匹配模型"></a>得分匹配模型</h2><p>宋飏等人在DDPM发表之前就提出了多轮噪声尺度的得分匹配模型，这一类模型的本质后续被证明和DDPM是在同一体系下的，不过重新梳理其理论推导有助于我们后续从另一个视角理解扩散模型。</p><p>我们已有一些数据$\{ {\bf x}_i\in\mathbb{R}^D\}_{i=1}^N$，数据的分布为$q({\bf x})$，但是现在我们面临的问题不再是拟合这个分布，而是找到这个分布中概率最大的数据点(其实就是学习已有的数据分布，便于生成一些看起来最常见的数据)，那么其实本质上就是找到</p><script type="math/tex; mode=display">\max_{\bf x} q({\bf x})</script><p>直观来看，我们可以通过梯度上升来找到这个数据点$\nabla_{\bf x} q({\bf x})$，但是由于$q({\bf x})$中常常存在归一化系数，对这个系数的拟合会耗费额外的不必要资源(毕竟我们只关心相对的最大值)，因此不妨将最优化问题转变为</p><script type="math/tex; mode=display">\max_{\bf x}\log q({\bf x})</script><p>这样的话，我们再求梯度$\nabla_{\bf x}\log q({\bf x})$，归一化系数就直接被干掉了，这就是$q({\bf x})$的分数【有文献提到，这里的分数实际上和数学意义上常见的分数的定义不同】。那么我们可以用一个网络${\bf s}_\theta:\mathbb{R}^D\to\mathbb{R}^D$来拟合该分数，拟合完成后，就可以使用近似的梯度上升法来找到概率最大的数据点</p><script type="math/tex; mode=display">{\bf x}_{t+1}={\bf x}_t+\tau\nabla_{\bf x}\log q({ {\bf x}_t })</script><p>这时我们可以引入离散朗之万动力学方程</p><script type="math/tex; mode=display">{\bf x}_{t+1}={\bf x}_t+\tau\nabla_{\bf x}\log q({ {\bf x}_t })+\sqrt{2\tau}{\bf z},{\bf z}\sim\mathcal{N}(0,{\bf I})</script><p>可以看到，朗之万动力学方程实际上就是加入了噪声项的梯度上升。但是为什么要引入这样的一个噪声项呢？一个直观理解是，我们实际上不是希望完全求解最开始的优化问题，也就是不是希望单单找到那个最优点，而是希望最终收敛的结果具有一定多样性，建立对高概率区域附近的分布的认知。【但是实际上这个噪声的引入是有严格的数学背景的，这和Fokker-Planck方程有密切的关系，该方程可以给出任何一种随机微分方程在任一时刻的分布$p({\bf x},t)$】</p><p>上面就是得分匹配函数的核心理念【先训练${\bf s}_\theta({\bf x})\approx \nabla_{\bf x}\log q({\bf x})$，再应用离散朗之万动力学方程进行采样】，但是在实际应用上述算法时，存在一个核心问题在于，真值$\nabla_{\bf x}\log q({\bf x})$如何得到？【毕竟我们的目标就是拟合这个玩意，要是我们已经有这个东西的简单计算方式就不需要再拟合这个玩意了(<strong>我们收集到的数据是离散的，而真实的分布空间是连续的</strong>)】</p><p><strong>【明确得分匹配ESM】</strong>该方法认为数据真实分布是多个简单的核分布的叠加【<strong>在真实样本点处放置核函数，使得整个空间变为较为平滑的连续分布空间</strong>】，即</p><script type="math/tex; mode=display">q({\bf x})\approx q_h({\bf x})=\frac{1}{M}\sum_{m=1}^M\frac{1}{h}K(\frac{ {\bf x}-{\bf x}^{(m)} }{h})</script><p>那么拟合目标就变为</p><script type="math/tex; mode=display">\begin{align}J_{ESM}(\theta)\\:=\mathbb{E}_{q({\bf x})}||{\bf s}_\theta({\bf x})-\nabla_{\bf x}\log q({\bf x})||^2\\\approx \mathbb{E}_{q_h({\bf x})}||{\bf s}_\theta({\bf x})-\nabla_{\bf x}\log q_h({\bf x})||^2\\=\int||{\bf s}_\theta({\bf x})-\nabla_{\bf x}\log q_h({\bf x})||^2 q_h({\bf x})d{\bf x}\\\approx\frac{1}{M}\sum_{m=1}^M\int||{\bf s}_\theta({\bf x})-\nabla_{\bf x}\log q_h({\bf x})||^2\frac{1}{h}K\left(\frac{ {\bf x}-{\bf x}^{(m)} }{h}\right)d{\bf x}\end{align}</script><p>由于核函数一般是一些简单的分布形式，这样对其求梯度的过程就比较容易计算出来了【优化目标中的积分实际上是通过蒙特卡洛方法的近似实现的，每次从相应的核函数的定义中随机抽取几个样本，求解损失函数】(容易处理的，tractable)。【此处可以进一步详细介绍】</p><p><strong>【模糊得分匹配ISM】</strong>在该方法中，优化目标为</p><script type="math/tex; mode=display">J_{ISM}(\theta):=\mathbb{E}_{q({\bf x})}\left[\text{Tr}(\nabla_{\bf x}{\bf s}_{\theta}({\bf x}))+\frac{1}{2}||{\bf s}_\theta({\bf x})||^2\right]</script><p>其中$\nabla_{\bf x}{\bf s}_\theta({\bf x})$为${\bf s}_\theta({\bf x})$的雅可比矩阵，而该方法的优化目标是可以被蒙特卡洛方法估计的</p><script type="math/tex; mode=display">J_{ISM}(\theta)\approx \frac{1}{M}\sum_{m=1}^M\sum_i(\partial_i{\bf s}_\theta({\bf x}^{(m)})+\frac{1}{2}|[{\bf s}_\theta({\bf x}^{(m)})]_i|^2)</script><p>其中$\partial_i{\bf s}_\theta({\bf x}^{(m)})=\frac{\partial }{\partial x_i}[{\bf s}_\theta({\bf x})]_i=\frac{\partial^2}{\partial x_i^2}\log p_\theta({\bf x})$，但是如果分数是由深度神经网络拟合得到的，那么迹是比较难以计算的。</p><p><strong>【去噪得分匹配DSM】</strong>这种方法在2011年就被提出了，而在深度学习时代由宋飏等人进一步发扬光大。由于前述的两种方法存在诸多局限，因此该方法被提出，损失函数如下所示</p><script type="math/tex; mode=display">J_{DSM}(\theta):=\mathbb{E}_{q({\bf x},{\bf x}')}\left[\frac{1}{2}||{\bf s}_\theta({\bf x})-\nabla_{\bf x}\log q({\bf x|{\bf x}}')||^2\right]</script><p>通过理论计算，实际上可以验证$J_{DSM}(\theta)=J_{ESM}(\theta)+C$，也就说这样训练出来的最优${\bf s}_\theta({\bf x})$和ESM的拟合目标拟合出来的最优结果是一致的，下面是详细推导：</p><script type="math/tex; mode=display">\begin{align}J_{ESM}(\theta)\\=\mathbb{E}_{q({\bf x})}\left[\frac{1}{2}||{\bf s}_\theta({\bf x})-\nabla_{\bf x}\log q({\bf x})||^2\right]\\=\mathbb{E}_{q({\bf x})}\left[\frac{1}{2}||{\bf s}_\theta({\bf x})||^2-{\bf s}_\theta({\bf x})^T\nabla_{\bf x}\log q({\bf x})+\frac{1}{2}||\nabla_{\bf x}\log q({\bf x})||^2\right]\\=\mathbb{E}_{q({\bf x})}\left[\frac{1}{2}||{\bf s}_\theta({\bf x})||^2-{\bf s}_\theta({\bf x})^T\nabla_{\bf x}\log q({\bf x})\right]+C\\=\mathbb{E}_{q({\bf x})}\left[\frac{1}{2}||{\bf s}_\theta({\bf x})||^2\right]-\int q({\bf x}){\bf s}_\theta({\bf x})^T\nabla_{\bf x}\log q({\bf x})d{\bf x}+C\\=\mathbb{E}_{q({\bf x})}\left[\frac{1}{2}||{\bf s}_\theta({\bf x})||^2\right]-\int {\bf s}_\theta({\bf x})^T\nabla_{\bf x}q({\bf x})d{\bf x}+C\end{align}</script><p>对于第二项，我们可以利用隐变量条件概率积分来替换$q({\bf x})$，即$q({\bf x})=\int q({\bf x}|{\bf x}’)q({\bf x}’)d{\bf x}’$，那么进一步推导得到</p><script type="math/tex; mode=display">\begin{align}\int {\bf s}_\theta({\bf x})^T\nabla_{\bf x}q({\bf x})d{\bf x}\\=\int {\bf s}_\theta({\bf x})^T\nabla_{\bf x}\left(\int q({\bf x}|{\bf x}')q({\bf x}')d{\bf x}'\right)d{\bf x}\\=\int {\bf s}_\theta({\bf x})^T\left(\int \nabla_{\bf x}q({\bf x}|{\bf x}')q({\bf x}')d{\bf x}'\right)d{\bf x}\\=\int {\bf s}_\theta({\bf x})^T\left(\int \nabla_{\bf x}q({\bf x}|{\bf x}')\frac{q({\bf x}|{\bf x}')}{q({\bf x}|{\bf x}')}q({\bf x}')d{\bf x}'\right)d{\bf x}\\=\int {\bf s}_\theta({\bf x})^T\left(\int \nabla_{\bf x}\log q({\bf x}|{\bf x}')q({\bf x}|{\bf x}')q({\bf x}')d{\bf x}'\right)d{\bf x}\\=\int\int {\bf s}_\theta({\bf x})^T\nabla_{\bf x}\log q({\bf x}|{\bf x}')q({\bf x},{\bf x}')d{\bf x}'d{\bf x}\\=\mathbb{E}_{q({\bf x},{\bf x}')}\left[{\bf s}_\theta({\bf x})^T\nabla_{\bf x}\log q({\bf x}|{\bf x}')\right]\end{align}</script><p>将这个结果代入回$J_{ESM}(\theta)$，得到</p><script type="math/tex; mode=display">\begin{align}J_{ESM}(\theta)\\=\mathbb{E}_{q({\bf x})}\left[\frac{1}{2}||{\bf s}_\theta({\bf x})||^2\right]-\mathbb{E}_{q({\bf x},{\bf x}')}\left[{\bf s}_\theta({\bf x})^T\nabla_{\bf x}\log q({\bf x}|{\bf x}')\right]+C\\=\mathbb{E}_{q({\bf x},{\bf x}')}\left[\frac{1}{2}||{\bf s}_\theta({\bf x})||^2\right]-\mathbb{E}_{q({\bf x},{\bf x}')}\left[{\bf s}_\theta({\bf x})^T\nabla_{\bf x}\log q({\bf x}|{\bf x}')\right]+C\\=J_{DSM}(\theta)+C'\end{align}</script><p>其实对比该损失函数和前述的损失函数，不难发现其就是把拟合目标由$\nabla_{\bf x}\log q({\bf x})$变为了$\nabla_{\bf x}\log q({\bf x|{\bf x}}’)$，通过这样的替换，我们实际上就可以将难以计算的拟合目标变得容易求解。比如我们可以令$q({\bf x}|{\bf x}’)=\mathcal{N}({\bf x}|{\bf x}’,\sigma^2)$，即${\bf x}={\bf x}’+\sigma{\bf z}$，那么这样我们就容易求解出</p><script type="math/tex; mode=display">\begin{align}\nabla_{\bf x}\log q({\bf x}|{\bf x}')\\=\nabla_{\bf x}\left\{-\frac{||{\bf x}-{\bf x}'||^2}{2\sigma^2}\right\}\\=-\frac{ {\bf x}-{\bf x}'}{\sigma^2}\\=-\frac{\bf z}{\sigma}\end{align}</script><p><strong>假如我们把${\bf x}’$当作真实的数据空间，那么要拟合的${\bf x}$分布空间实际上就变成了被高斯噪声扰动后的数据空间</strong>，此时我们可以重新写出DSM的拟合目标</p><script type="math/tex; mode=display">J_{DSM}(\theta)=\mathbb{E}_{ {\bf x}\sim q({\bf x}),{\bf z}\sim{\mathcal{N}(0,{\bf I})} }\left[||{\bf s}_\theta({\bf x}+\sigma {\bf z})+\frac{\bf z}{\sigma}||^2\right]</script><p>这一拟合目标是十分直观的，实际上就是学习如何消去这个噪声${\bf z}$，也就是对于每一个输入的带噪样本点${\bf x}’$，要找到其指向最近的真实样本点${\bf x}$的向量，<strong>但是要格外注意的是，只有当$\sigma$趋近于零，我们得到的才是对真实数据空间$q({\bf x})$的拟合，否则实际上得到的是对被高斯噪声扰动后的数据空间的拟合</strong>。</p><p>在实际拟合时，我们是从数据集$\left\{ {\bf x}^{(m)}\right\}_{m=1}^M$出发，完成如下优化问题</p><script type="math/tex; mode=display">\begin{align}\theta^*=\mathop{\arg\min}\limits_{\theta}\mathbb{E}_{ {\bf x}\sim q({\bf x}),{\bf z}\sim{\mathcal{N}(0,{\bf I})} }\left[\left\Vert{\bf s}_\theta({\bf x}+\sigma {\bf z})+\frac{\bf z}{\sigma}\right\Vert^2\right]\\\approx\mathop{\arg\min}\limits_{\theta}\frac{1}{M}\sum_{m=1}^M\frac{1}{2}\left\Vert{\bf s}_\theta({\bf x}^{(m)}+\sigma{\bf z^{(m)} })+\frac{ {\bf z}^{(m)} }{\sigma}\right\Vert^2\end{align}</script><p>如上的训练过程是在一个固定$\sigma$尺度下训练得到分数拟合函数，那么自然会想到将其扩展到多个噪声尺度【即宋飏等人提出的noise conditioned score network (NCSN)】：</p><script type="math/tex; mode=display">J_{NCSN}(\theta)=\frac{1}{L}\sum_{i=1}^L\lambda(\sigma_i)\mathcal{l}(\theta;\sigma_i)</script><p>其中$\mathcal{l}(\theta;\sigma_i)=\mathbb{E}_{ {\bf x}\sim q({\bf x}),{\bf z}\sim{\mathcal{N}(0,{\bf I})} }\left[||{\bf s}_\theta({\bf x}+\sigma_i {\bf z})+\frac{\bf z}{\sigma_i}||^2\right]$，而$\lambda(\sigma)=\sigma^2$【这是经验公式】，且一般$\sigma_i$是随着$i$增大而逐级递减的。在推理时，则采取如下退火重要性采样朗之万方程：</p><script type="math/tex; mode=display">{\bf x}_{t+1}={\bf x}_t+\frac{\alpha_i}{2}{\bf s}_\theta({\bf x}_t,\sigma_i)+\sqrt{\alpha_i}{\bf z}_t,\ \ \ \ \ {\bf z}_t\sim\mathcal{N}(0,{\bf I})</script><p>其中$\alpha_i=\sigma_i^2/\sigma_L^2$。对于每个噪音尺度$\sigma_i$，都会进行$T$次关于$t$的迭代，最终得到的${\bf x}_T$会作为下一次噪声尺度迭代的开始${\bf x}_0$。</p><h3 id="Sliced-Score-Matching-SSM"><a href="#Sliced-Score-Matching-SSM" class="headerlink" title="Sliced Score Matching (SSM)"></a>Sliced Score Matching (SSM)</h3><p>此处是宋飏等人在2019年论文提出的新的得分匹配函数的优化目标，该优化目标<strong>通过将对得分函数的高维空间的完全匹配替换为对随机方向的得分函数投影的匹配，从而避免了计算$\nabla_{\bf x}\log q({\bf x})$的麻烦</strong>，这实际上使得后续为找到非仿射系数的前向SDE的反向SDE成为可能。</p><blockquote><p>我们通常需要知道过渡核 $p_{0t}(x(t) \,|\, x(0))$ 才能有效地拟合得分模型。当漂移项$f(t)$是仿射的时，过渡核始终是<strong>高斯分布</strong>，其均值和方差通常具有<strong>闭式形式</strong>，可以通过标准方法获得。对于更一般的随机微分方程 (SDE)，我们可以通过求解<strong>Kolmogorov 正向方程</strong>来获得$p_{0t}(x(t) \,|\, x(0))$。另外，我们还可以直接对 SDE 进行<strong>模拟采样</strong>，以从$p_{0t}(x(t) \,|\, x(0))$中生成样本，并在模型训练中将方程 (7) 中的<strong>去噪分数匹配</strong>替换为<strong>切片分数匹配</strong> (SSM)。  这种做法能够绕过显式计算$ \nabla_x \log p_{0t}(x(t) \,|\, x(0))$的需求。</p></blockquote><p>这里直接摆上原文的证明(偷懒)，要注意的是<strong>SSM优化目标的成立需要满足下面证明提到的几个假设</strong>(在某些场景下，假设可能是不成立的)【该证明的核心步骤是分部积分】</p><p><img src="/pics/扩散模型的score-based模型视角与fokker-planck方程/屏幕截图 2025-03-27 145736.png" alt=""></p><p><img src="/pics/扩散模型的score-based模型视角与fokker-planck方程/屏幕截图 2025-03-27 145805.png" alt=""></p><h2 id="SDE与ODE视角下的扩散模型"><a href="#SDE与ODE视角下的扩散模型" class="headerlink" title="SDE与ODE视角下的扩散模型"></a>SDE与ODE视角下的扩散模型</h2><p>DDPM与得分匹配模型本质上都是对连续随机微分方程的离散化拟合。因此从连续随机微分方程的视角出发，我们可以更进一步理解扩散模型的分布特性(引入fokker-Planck方程)。</p><p><strong>【常微分方程简单例子】</strong>设有一个离散迭代方程${\bf x}_i=\left(1-\frac{\beta}{2}\right){\bf x}_{i-1}$，那么我们可以将其转化为在时间$[0,1]$内的连续微分方程，只需令${\bf x}(\frac{i}{N})={\bf x}_i$，以及$\beta=\frac{\hat\beta}{N}$【<strong>这个$\beta$的代换是十分重要的，因为假如没有这个代换，我们就无法进行后续取极限的操作</strong>】，那么就可以得到${\bf x}(\frac{i}{N})=\left(1-\frac{\hat\beta}{2N}\right){\bf x}(\frac{i-1}{N})$，不妨令$\Delta t=\frac{1}{N}$，那么就可以得到${\bf x}(t+\Delta t)-{\bf x}(t)=-\frac{\hat\beta}{2}{\bf x}(t)\Delta t$，令分割无限细化，就可以得到$\frac{d{\bf x}(t)}{dt}=-\frac{\hat\beta}{2}{\bf x}(t)$，该微分方程的解为${\bf x}(t)=\exp(-\frac{\hat\beta}{2}t)$，这样我们就得到了对上述离散迭代行为的一个简单认识。【<strong>从离散微分方程到连续微分方程的映射中，很喜欢做的一个处理就是把无限长的序列压缩到单位时间长度中，这样的话单次离散微分方程的计算实际上就是发生在一个极小时间内了，这时再在差分等式右侧凑出来一个$\Delta t$，也就可以顺理成章地转化为微分运算了</strong>】</p><p>简而言之，一阶常微分方程的形式为如下所示：</p><script type="math/tex; mode=display">\frac{d{\bf x}(t)}{dt}={\bf f}(t,{\bf x})</script><p>一般容易计算其解析形式为</p><script type="math/tex; mode=display">{\bf x}(t)={\bf x}_0+\int_0^t{\bf f}(s,{\bf x}(s))ds</script><p>而对于一阶随机微分方程，其形式其实和ODE非常接近，只不过增加了噪声项【<strong>此处表达式的正确性存疑</strong>】</p><script type="math/tex; mode=display">\frac{d{\bf x}(t)}{dt}={\bf f}(t,{\bf x})+{\bf g}(t,{\bf x}){\bf \xi}(t),\ \ \ \ \ \ \ \ {\bf \xi}(t)\sim\mathcal{N}(0,{\bf I})</script><p>常见的形式是包含维纳过程$d{\bf w}$的，$d{\bf w}\sim\mathcal{N}(0,dt{\bf I})$</p><script type="math/tex; mode=display">d{\bf x}={\bf f}(t,{\bf x})dt+{\bf g}(t,{\bf x})d{\bf w}</script><p>我们也可以将其表达为积分形式</p><script type="math/tex; mode=display">{\bf x}(t,\omega)={\bf x}_0+\int_0^t{\bf f}(s,{\bf x}(s,\omega))ds+\int_0^t{\bf g}(s,{\bf x}(s,\omega))d{\bf w}(s,\omega)</script><p>其中$\omega$为${\bf x}$在概率空间中的状态【在该问题中即为随机过程变量${\bf x}$的某种轨迹，整个概率空间由多种多样的轨迹组成】，为了求解得到一个随机过程的一条轨迹就需要先选定一种随机状态$\omega$。</p><p>对于形如如下所示的连续的前向扩散过程(在$t$时刻具有分布$p_t({\bf x})$)</p><script type="math/tex; mode=display">d{\bf x}={\bf f}({\bf x},t)dt+g(t)d{\bf w}</script><p>那么其对应的反向扩散过程为【该部分证明需要参考1982年《Reverse-time diffusion equation models》中的证明】【这个反向扩散方程可以保证反向轨迹在$t$时刻的分布为$q_t({\bf x})$】</p><script type="math/tex; mode=display">d{\bf x}=[{\bf f}({\bf x},t)-g(t)^2\nabla_{\bf x}\log q_t({\bf x})]dt+g(t)d\bar{\bf w}\tag{*}\label{*}</script><p>其中$\bar{\bf w}$为反向扩散过程中的维纳过程(独立于过去的维纳过程，不独立于未来，这一性质是与${\bf w}$相反的)</p><blockquote><p>根据宋飏等人论文的论述(基于1982年反向扩散过程物理学论文)，更一般的扩散形式为【${\bf f}(\cdot,t):\mathbb{R}^d\to\mathbb{R}^d$为向量函数，${\bf G}(\cdot,t):\mathbb{R}^d\to\mathbb{R}^{d\times d}$为矩阵函数，该矩阵函数意味着可以对各个通道施加与状态${\bf x}$相关的且存在一定相关性的噪声，比$g(t)$具有更强的灵活性】</p><script type="math/tex; mode=display">d{\bf x}={\bf f}({\bf x},t)dt+{\bf G}({\bf x},t)d{\bf w}</script><p>相应地，其对应的反向扩散过程为</p><script type="math/tex; mode=display">\begin{align}【d{\bf x}=\{ {\bf f}({\bf x},t)-\frac{1}{q({\bf x},t)}\nabla_{\bf x}\cdot (q({\bf x},t){\bf G}({\bf x},t){\bf G}({\bf x},t)^T)\}dt+{\bf G}({\bf x},t)d\bar{\bf w}】\\d{\bf x}=\{ {\bf f}({\bf x},t)-\nabla_{\bf x}\cdot[{\bf G}({\bf x},t){\bf G}({\bf x},t)^T]-{\bf G}({\bf x},t){\bf G}({\bf x},t)^T\nabla_{\bf x}\log q({\bf x},t)\}dt+{\bf G}({\bf x},t)d\bar{\bf w}\end{align}</script><p>【上下两种表述是一样的】其中$\nabla\cdot F({\bf x}):=[\nabla\cdot {\bf f}^1({\bf x}),…,\nabla\cdot{\bf f}^d({\bf x})]^T$，${\bf F}({\bf x})=[{\bf f}^1({\bf x}),…,{\bf f}^d({\bf x})]^T$。在1982年中的原文其实是表述为</p><script type="math/tex; mode=display">\bar{\bf f}^i({\bf x},t)={\bf f}^i({\bf x},t)-\frac{1}{q({\bf x},t)}\sum_{j,k}\frac{\partial}{\partial x_j}[q({\bf x},t)\cdot g^{jk}({\bf x},t)g^{ik}({\bf x},t)]</script><p>对于离散SDE，那么前向过程写为</p><script type="math/tex; mode=display">{\bf x}_{i+1}={\bf x}_{i}+{\bf f}_i({\bf x}_i)+{\bf G}_i({\bf z}_i)</script><p>其对应的反向ODE过程为</p><script type="math/tex; mode=display">{\bf x}_i={\bf x}_{i+1}-{\bf f}_{i+1}({\bf x}_{i+1})+\frac{1}{2}{\bf G}_{i+1}{\bf G}_{i+1}^T{\bf s}_{\theta}({\bf x}_{i+1},i+1)</script><blockquote><p>对于上述SDE，还有一个很有趣的期望性质，令${\bf M}(t)$为分布均值，${\bf\Sigma}(t)$为分布的方差矩阵，那么其满足如下ODE【参考《Applied Stochastic Differential Equations》 by Simo Särkkä &amp; Arno Solin】：</p><script type="math/tex; mode=display">\frac{d{\bf M} }{dt}=\mathbb{E}[{\bf f}({\bf x},t)]</script><script type="math/tex; mode=display">\frac{d{\bf\Sigma} }{dt}=\mathbb{E}[{\bf f}({\bf x},t)({\bf x}-{\bf M})^T]+\mathbb{E}[({\bf x}-{\bf M}){\bf f}({\bf x},t)^T]+\mathbb{E}[{\bf G}({\bf x},t){\bf Q}{\bf G}({\bf x},t)^T]</script><p>其中$d{\bf w}d{\bf w}^T={\bf Q}dt$。</p><p>据此，宋飏等人给出了DDPM的SDE对应的方差矩阵的演变ODE</p><script type="math/tex; mode=display">\frac{d{\bf \Sigma}_{VP}(t) }{dt}=\beta(t)({\bf I}-{\bf\Sigma}_{VP}(t))</script><p>事实上这个方程很好求解，可以计算得到</p><script type="math/tex; mode=display">{\bf\Sigma}_{VP}(t)={\bf I}+\exp\left(-\int_0^t\beta(s)ds\right)({\bf\Sigma}_{VP}(0)-{\bf I})</script><p>由此可见，DDPM分布随时间演变的方差是有界的(受限于${\bf\Sigma}_{VP}(0)$，因此称为VP)。宋飏等人进一步提出了sub-VP对应的前向SDE</p><script type="math/tex; mode=display">d{\bf x}=-\frac{1}{2}\beta(t){\bf x}dt+\sqrt{\beta(t)\left(1-\exp\left(-2\int_0^t\beta(s)ds\right)\right)}d{\bf w}</script><p>该SDE对应的方差矩阵的演化为</p><script type="math/tex; mode=display">{\bf\Sigma}_{subVP}(t)={\bf I}+\exp\left(-2\int_0^t\beta(s)ds\right){\bf I}+\exp\left(-\int_0^t\beta(s)ds\right)({\bf\Sigma}_{subVP}(0)-2{\bf I})</script><p>其满足的重要性质是${\bf\Sigma}_{subVP}(t) \preceq{\bf\Sigma}_{VP}(t)$。</p><p><img src="/pics/扩散模型的score-based模型视角与fokker-planck方程/屏幕截图 2025-03-28 214545.png" alt=""></p></blockquote><p>此外，有文献显示，上述SDE实际上可以由另外一个ODE来替代</p><script type="math/tex; mode=display">d{\bf x}=\left\{ {\bf f}({\bf x},t)-\frac{1}{2}\nabla\cdot[{\bf G}({\bf x},t){\bf G}({\bf x},t)^T]-\frac{1}{2}{\bf G}({\bf x},t){\bf G}({\bf x},t)^T\nabla_{\bf x}\log q_t({\bf x})\right\}dt</script><p>宋飏等人给出了一个基于fokker-planck方程的简易证明，此处直接粘贴原文证明。【<strong>这部分的证明核心也是函数乘积的求导，其推导的思想就是fokker-planck方程和前向马尔可夫SDE存在对应关系，那么我们可以将fokker-planck方程中与原SDE的$d{\bf w}$前的系数相关的项归并到与${\bf f}({\bf x},t)$相关的项中，从而实现将${\bf G}({\bf x},t)$置零，这样就等价于消去了维纳过程项，原本的SDE就被转化为ODE了</strong>】</p><p><img src="/pics/扩散模型的score-based模型视角与fokker-planck方程/屏幕截图 2025-03-27 201043.png" alt="屏幕截图 2025-03-27 201043"></p><p>将上述ODE重新写为</p><script type="math/tex; mode=display">d{\bf x}=\bar{\bf f}({\bf x},t)dt</script><p>其中$\bar{\bf f}({\bf x},t)$一般为模型拟合得到的，为$\bar{\bf f}_\theta({\bf x},t)$，那么套用Fokker-Planck方程，可以解得如下关系</p><script type="math/tex; mode=display">\log (p_\theta)_0({\bf x}(0))=\log (p_{\theta})_T({\bf x}(T))+\int_0^T\nabla\cdot\bar{\bf f}_\theta({\bf x}(t),t)dt</script><p>通常情况下，计算$\nabla\cdot\bar{\bf f}_\theta({\bf x}(t),t)$耗费比较大，因此宋飏等人提出采用Skilling-Hutchinson估计器</p><script type="math/tex; mode=display">\nabla\cdot\bar{\bf f}_\theta({\bf x}(t),t)=\mathbb{E}_{p({\bf\epsilon})}[\epsilon^T\nabla\bar{\bf f}_\theta({\bf x}(t),t)\epsilon]</script><p>其中，$\nabla\bar{\bf f}_\theta({\bf x}(t),t)$表示$\bar{\bf f}_\theta({\bf x}(t),t)$的Jacobian矩阵，随机变量$\epsilon$满足：$\mathbb{E}_{p(\epsilon)}[\epsilon]=0$且$\text{Cov}_{p(\epsilon)}={\bf I}$，$\epsilon^T\nabla\bar{\bf f}_\theta({\bf x}(t),t)$可以通过<strong>反向模式自动微分</strong>(reverse mode automatic differentiation)高效计算，其计算成本与评估$\bar{\bf f}_\theta({\bf x}(t),t)$相当。</p><p>由此，我们实际上可以通过上述模拟来精确计算拟合出的分布在任意${\bf x}$处的对数值$\log (p_\theta)_0({\bf x})$，由此便容易得到负对数似然。【我们自然希望真实的图片的平均负对数似然尽可能小】</p></blockquote><h4 id="DDPM的随机微分方程"><a href="#DDPM的随机微分方程" class="headerlink" title="DDPM的随机微分方程"></a>DDPM的随机微分方程</h4><p>对于DDPM模型，有如下离散随机微分方程形式</p><script type="math/tex; mode=display">{\bf x}_i=\sqrt{1-\beta_i}{\bf x}_{i-1}+\sqrt{\beta_i}{\bf z}_{i-1},\ \ \ \ \ {\bf z}_{i}\sim\mathcal{N}(0,{\bf I})</script><p>如果我们同样令${\bf x}_i={\bf x}(\frac{i}{N})$【即$t(i)=\frac{i}{N}$】以及$\Delta t=\frac{1}{N}$，$f_1(t(i))=\frac{\sqrt{1-\beta(t+\Delta t)})-1}{\Delta t}=N(\sqrt{1-\beta_{i+1}}-1)$，$f_2(t)=\frac{\beta(t+\Delta t)}{\Delta t}=N\beta_{i+1}$，【<strong>此处凑出来的$f_1(t)$和$f_2(t)$都是为了让$\Delta t$出现在它该出现的地方</strong>】那么有</p><script type="math/tex; mode=display">\begin{align}{\bf x}(t+\Delta t)=\sqrt{1-\beta_i}{\bf x}(t)+\sqrt{\beta_i}{\bf z}(t)\\\Rightarrow {\bf x}(t+\Delta t)-{\bf x}(t)=(\sqrt{1-\beta_i}-1){\bf x}(t)+\sqrt{\beta_i}{\bf z}(t)\\\Rightarrow {\bf x}(t+\Delta t)-{\bf x}(t)=(f_1(t)\Delta t){\bf x}(t)+\sqrt{\beta(t+\Delta t)}\frac{ {\bf w}(t+\Delta t)-{\bf w}(t)}{\sqrt{\Delta t} }\\\Rightarrow d{\bf x}=f_1(t){\bf x}(t)dt+\sqrt{f_2(t)}d{\bf w}\end{align}</script><p>在一些文献中，常常认为$\beta$足够小，那么就有$f_1(t(i))\approx-\frac{1}{2}N\beta_{i+1}$，该形式和$f_2(t(i))$一致，因此不妨直接令$\hat\beta(t(i))=N\beta_{i+1}$，这样就得到了常见的一种随机微分方程形式</p><script type="math/tex; mode=display">d{\bf x}=-\frac{1}{2}\hat\beta(t){\bf x}(t)dt+\sqrt{\hat\beta(t)}d{\bf w}</script><p>当$\Delta t$越接近于零，那么该连续的随机微分方程对离散微分方程的拟合越接近，当二者足够接近时，我们实际上就可以使用拟合SDE的方法来拟合离散随机微分方程的过程。</p><p>实际上，我们也可以反过来，认为DDPM给出的离散随机方程实际上是在离散地近似求解上述连续SDE。</p><p>而对于上述连续前向过程的连续反向过程，参考$(\ref{*})$式子，就应该是如下形式(此处为了书写方便，令$\beta(t):=\hat\beta(t)$)【注意此处的$dt$是反向的，即为负，$\bar{\bf w}$为反向的维纳过程】</p><script type="math/tex; mode=display">d{\bf x}=-\beta(t)\left[\frac{\bf x}{2}+\nabla_{\bf x}\log q_t({\bf x})\right]dt+\sqrt{\beta(t)}d\bar {\bf w}</script><p>下面可以证明，DDPM的离散反向过程本质上就是对该连续反向过程的离散模拟。</p><script type="math/tex; mode=display">\begin{align}{\bf x}(t-\Delta t)-{\bf x}(t)=-\beta(t)\left[\frac{ {\bf x}(t)}{2}+\nabla_{\bf x}\log q_t({\bf x})\right](-\Delta t)+\sqrt{\beta(t)}({\bar{\bf w}(t-\Delta t)}-{\bar{\bf w}(t)})\\\Rightarrow {\bf x}(t-\Delta t)=\left(1+\frac{\beta(t)\Delta t}{2}\right){\bf x}(t)+\beta(t)\nabla_{\bf x}\log q_t({\bf x})\Delta t+\sqrt{\beta(t)}({\bar{\bf w}(t-\Delta t)}-{\bar{\bf w}(t)})\\\Rightarrow {\bf x}_{i-1}=\left(1+\frac{\beta(t)\Delta t}{2}\right){\bf x}_i+\beta(t)\nabla_{\bf x}\log q_t({\bf x})\Delta t+\sqrt{\beta(t)}\sqrt{\Delta t}{\bf z}_i\\\Rightarrow {\bf x}_{i-1}=\left(1+\frac{\beta(\frac{i}{N})\frac{1}{N}}{2}\right){\bf x}_i+\beta\left(\frac{i}{N}\right)\nabla_{\bf x}\log q_t({\bf x})\frac{1}{N}+\sqrt{\frac{\beta\left(\frac{i}{N}\right)}{N}}{\bf z}_i\\\Rightarrow {\bf x}_{i-1}\approx\left(1+\frac{\beta(\frac{i}{N})\frac{1}{N}}{2}\right){\bf x}_i+\beta\left(\frac{i}{N}\right)\nabla_{\bf x}\log q_t({\bf x})\frac{1}{N}+\frac{1}{2}\left(\beta\left(\frac{i}{N}\right)\frac{1}{N}\right)^2\nabla_{\bf x}\log q_t({\bf x})+\sqrt{\frac{\beta(\frac{i}{N})}{N}}{\bf z}_i\\\Rightarrow {\bf x}_{i-1}\approx\left(1+\frac{\beta(\frac{i}{N})\frac{1}{N}}{2}\right)\left({\bf x}_i+\beta\left(\frac{i}{N}\right)\frac{1}{N}\nabla_{\bf x}\log q_t({\bf x})\right)+\sqrt{\frac{\beta(\frac{i}{N})}{N}}{\bf z}_i\\\Rightarrow {\bf x}_{i-1}\approx\left(1+\frac{\hat\beta_i}{2}\right)\left({\bf x}_i+\hat\beta_i\nabla_{\bf x}\log q_t({\bf x})\right)+\sqrt{\hat\beta_i}{\bf z}_i\\\Rightarrow {\bf x}_{i-1}\approx\frac{1}{\sqrt{1-\hat\beta_i}}\left({\bf x}_i+\hat\beta_i\nabla_{\bf x}\log q({\bf x}_i,i)\right)+\sqrt{\hat\beta_i}{\bf z}_i\\\end{align}</script><p>其中做了一次代换$\hat\beta_i=\beta(\frac{i}{N})\frac{1}{N}$【且为了凑出DDPM的离散形式，实际上引入了一个二阶小量】，当$N$非常大的时候，我们可以认为这种离散化方程可以很好地模拟原本的连续随机过程。事实上宋飏等人的论文中给出了另一种可行的离散方程近似形式【该形式是由SDE离散化推导得到的，而不是通过ELBO优化得到的，原本的DDPM的离散方程被称为祖先采样，但是不是所有形式的扩散过程都是可以通过ELBO优化得到祖先采样形式的】</p><script type="math/tex; mode=display">{\bf x}_{i-1}=\left(2-\sqrt{1-\hat\beta_i}\right){\bf x}_i+\hat\beta_i\nabla_{\bf x}\log q({\bf x}_i,i)+\sqrt{\hat\beta_i}{\bf z}_i</script><h3 id="SMLD-得分匹配模型-的随机微分方程"><a href="#SMLD-得分匹配模型-的随机微分方程" class="headerlink" title="SMLD(得分匹配模型)的随机微分方程"></a>SMLD(得分匹配模型)的随机微分方程</h3><p>其前向离散随机微分方程为</p><script type="math/tex; mode=display">{\bf x}_i={\bf x}_{i-1}+\sqrt{\sigma_i^2-\sigma_{i-1}^2}{\bf z}_{i-1}</script><p>可以类似于DDPM的过程将其转化为连续形式</p><script type="math/tex; mode=display">\begin{align}{\bf x}(t+\Delta t)={\bf x}(t)+\sqrt{\sigma^2(t+\Delta t)-\sigma^2(t)}{\bf z}(t)\\\Rightarrow d{\bf x}=\sqrt{\frac{\sigma^2(t+\Delta t)-\sigma^2(t)}{\Delta t}}d{\bf w}\\\Rightarrow d{\bf x}=\sqrt{\frac{d[\sigma^2(t)]}{d t}}d{\bf w}\end{align}</script><p>相应地，容易写出其对应的反向SDE为</p><script type="math/tex; mode=display">d{\bf x}=-\left(\frac{d[\sigma^2(t)]}{dt}\nabla_{\bf x}\log q_t({\bf x})\right)dt+\sqrt{\frac{d[\sigma^2(t)]}{d t}}d\bar{\bf w}</script><p>同样通过离散化，可以得到</p><script type="math/tex; mode=display">{\bf x}_{i-1}={\bf x}_i+(\sigma_i^2-\sigma_{i-1}^2)\nabla_{\bf x}\log q_i({\bf x}_i)+\sqrt{(\sigma_i^2-\sigma_{i-1}^2)}{\bf z}_i</script><h2 id="Predictor-Corrector算法"><a href="#Predictor-Corrector算法" class="headerlink" title="Predictor-Corrector算法"></a>Predictor-Corrector算法</h2><p>此处借鉴了求解ODE常用的数值方法，先进行初步预测，然后对初步预测进行多轮次纠正，使得结果更为准确。</p><p><img src="/pics/扩散模型的score-based模型视角与fokker-planck方程/屏幕截图 2025-03-29 103034.png" alt=""></p><p>文中还给出了实验中采用的Corrector算法，但是效果不佳，这里就不放了。</p><h2 id="条件生成"><a href="#条件生成" class="headerlink" title="条件生成"></a>条件生成</h2><p>此处参考<a href="https://zhuanlan.zhihu.com/p/688843943">网站1</a>。</p><p>如果我们希望进行基于$\nabla_{\bf x}q_t({\bf x}|{\bf y})$的条件生成，那么实际上我们很容易计算得到</p><script type="math/tex; mode=display">\begin{align}\nabla_{\bf x}q_t({\bf x}|{\bf y})\\=\nabla_{\bf x}q_t({\bf y}|{\bf x})+\nabla_{\bf x}q_t({\bf x})-\nabla_{\bf x}q_t({\bf y})\\=\nabla_{\bf x}q_t({\bf y}|{\bf x})+\nabla_{\bf x}q_t({\bf x})\end{align}</script><p>这样的话，我们看起来需要额外训练一个模型来拟合$\nabla_{\bf x}q_t({\bf y}|{\bf x})$，如果在拟合出的$\nabla_{\bf x}(p_\phi)_t({\bf y}|{\bf x})$前加上权重$\gamma$，我们实际上就可以控制遵循条件引导的强弱</p><script type="math/tex; mode=display">\gamma\nabla_{\bf x}(p_\phi)_t({\bf y}|{\bf x})+\nabla_{\bf x}(p_\theta)_t({\bf x})</script><p>如果不希望训练额外的$\nabla_{\bf x}(p_\phi)_t({\bf y}|{\bf x})$，那么实际上可以再把$\nabla_{\bf x}q_t({\bf y}|{\bf x})$变回去，得到</p><script type="math/tex; mode=display">\begin{align}\gamma\nabla_{\bf x}(p_\phi)_t({\bf y}|{\bf x})+\nabla_{\bf x}(p_\theta)_t({\bf x})\\=\gamma\nabla_{\bf x}(p_\theta)_t({\bf x}|{\bf y})+(1-\gamma)\nabla_{\bf x}(p_\theta)_t({\bf x})\end{align}</script><p>这样的话本质上只需要训练$\nabla_{\bf x}(p_\theta)_t({\bf x}|{\bf y})$，这时只需要引入所谓的空条件，那么也就相当于同时训练了$\nabla_{\bf x}(p_\theta)_t({\bf x})$。</p><h2 id="Fokker-Planck方程"><a href="#Fokker-Planck方程" class="headerlink" title="Fokker-Planck方程"></a>Fokker-Planck方程</h2><p>通过将Kramers-Moyal展开截断到2阶，就可以得到fokker-planck方程(或者称为Kolmogorov’s前向方程)，该方程可基于SDE推理出各个时刻的分布情况【关于这部分的更细致内容可以参考《Stochastic Differential Equations》 by Bernt Øksendal】</p><blockquote><p>(此处是1维形式)对于任意的马尔可夫过程$\xi (t)$，其在$t$时刻的分布满足$p(x,t)$【$\xi(t)=x$】，那么该随时间变化的分布必然满足</p><script type="math/tex; mode=display">\frac{\partial }{\partial t}p(x,t)=-\frac{\partial}{\partial x}D^{(1)}(x,t)p(x,t)+\frac{\partial^2}{\partial x^2}D^{(2)}(x,t)p(x,t)</script><p>其中</p><script type="math/tex; mode=display">D^{(m)}(x,t)=\frac{1}{m!}\lim\limits_{\Delta t\to 0}\left[\frac{1}{\Delta t}\mathbb{E}[(\xi(t+\Delta t)-x)^m]\Big|_{\xi(t)=x}\right]</script></blockquote><p>对于一般的像前面提到的那样的随机微分方程(${\bf x}:\mathbb{R}^d$)：</p><script type="math/tex; mode=display">d{\bf x}={\bf f}({\bf x},t)dt+{\bf G}({\bf x},t)d{\bf w}</script><p>则fokker-planck方程形式为</p><script type="math/tex; mode=display">\frac{\partial p({\bf x},t)}{\partial t}=-\sum_{i=1}^d\frac{\partial}{\partial x_i}[f_i({\bf x},t)p({\bf x},t)]+\frac{1}{2}\sum_{i=1}^d\sum_{j=1}^d\frac{\partial^2}{\partial x_i\partial x_j}\left[\sum_{k=1}^dG_{ik}({\bf x},t)G_{jk}({\bf x},t)p({\bf x},t)\right]</script><p>【<strong>此处留待进一步解析</strong>】</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成式模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDPM与DDIM</title>
      <link href="/2025/03/18/1f1ed4e9.html"/>
      <url>/2025/03/18/1f1ed4e9.html</url>
      
        <content type="html"><![CDATA[<p>本文参考<a href="https://zhuanlan.zhihu.com/p/614147698">网站1</a>与<a href="https://spaces.ac.cn/archives/9181">网站2</a>。</p><h2 id="DDPM优化目标梳理"><a href="#DDPM优化目标梳理" class="headerlink" title="DDPM优化目标梳理"></a>DDPM优化目标梳理</h2><p>DDPM本质上是一种自回归的隐变量模型，将对目标分布$q({\bf x}_0)$的拟合转变为对$q({\bf x}_{0:T})$的拟合。</p><p>前向过程被定义为<strong>马尔科夫链</strong>：</p><script type="math/tex; mode=display">q({\bf x}_{1:T}|{\bf x}_0)=\prod_{t=1}^T q({\bf x}_t|{\bf x}_{t-1})\tag{1}\label{1}</script><p>且(或许是为了保证拟合目标是可计算的tractable)单步转移也是高斯的：</p><script type="math/tex; mode=display">q({\bf x}_t|{\bf x}_{t-1})=\mathcal{N}({\bf x}_t;\sqrt{1-\beta_t}{\bf x}_{t-1},\beta_t{\bf I})\tag{2}\label{2}</script><p>其中$\beta_t$为可以人为定义的超参数。结合$(\ref{1})$和$(\ref{2})$，我们可以得到</p><script type="math/tex; mode=display">q({\bf x}_t|{\bf x}_0)=\int_{ {\bf x}_{t+1:T} }\int_{ {\bf x}_{1:t-1} }q({\bf x}_{1:T}|{\bf x}_0)d{\bf x}_{1:t-1}d{\bf x}_{t+1:T}</script><p>当然，最简单的推导方法是将其转化为离散随机微分方程(<strong>计算这类方程的时候要十分注意随机项带来的时间反演失效</strong>)</p><script type="math/tex; mode=display">{\bf x}_t=\sqrt{1-\beta_t}{\bf x}_{t-1}+\sqrt{\beta_t}{\bf \varepsilon}_t</script><p>通过不断迭代，我们可以得到</p><script type="math/tex; mode=display">{\bf x}_t=\sqrt{ {\prod_{k=1}^{t}(1-\beta_k)} }{\bf x}_0+\sqrt{1-\prod_{k=1}^{t}(1-\beta_k)}\hat\varepsilon_t\tag{*}\label{*}</script><p>上面式子中$\hat\varepsilon_t$为所有$\varepsilon_t$的随机效果的等效总和，下面定义$\alpha_t=1-\beta_t$，${\bar \alpha}_t={\prod_{k=1}^{t}\alpha_k}$。(计算方差的时候会用到$\frac{y_n}{y_{n+1}}=\frac{\beta_n(1-\beta_{n+1})}{\beta_{n+1}}$，$y_t=\beta_t$，需要求解$\sum_{n=0}^t y_n$，可以通过引入-1合并同类项来化简)</p><p>我们希望拟合出一个模型$p_\theta({\bf x}_{0:T})$，使得$p_\theta({\bf x}_0)$与$q({\bf x}_0)$尽可能接近，则一般需要最小化KL散度：</p><script type="math/tex; mode=display">D_\text{KL}(q({\bf x}_0)||p_\theta({\bf x}_0))=\mathbb{E}_q\left[\log\frac{q({\bf x}_0)}{p_\theta({\bf x}_0)}\right]\tag{3}</script><p>由于我们只关心与$\theta$有关的项，因此优化目标可以重新写为</p><script type="math/tex; mode=display">\mathbb{E}_q\left[-\log p_\theta({\bf x}_0)\right]\tag{4}</script><p>对这个目标的直接优化并不容易(因为概率空间很大，并且需要始终保证模型输出的概率是归一化的)，但是由于我们引入了一系列隐含变量${\bf x}_{1:T}$，因此可以曲线救国，通过压缩上述优化目标的上界(ELBO)来实现对上述优化目标的优化</p><script type="math/tex; mode=display">\mathbb{E}_{ {\bf x}_0\sim q({\bf x}_0)}\left[-\log p_\theta({\bf x}_0)\right]\le \mathbb{E}_{ {\bf x}_{0:T}\sim q({\bf x}_{0:T})}\left[-\log\frac{p_\theta({\bf x}_{0:T})}{q({\bf x}_{1:T}|{\bf x}_0)}\right]\tag{5}</script><p>为了说明为什么该不等号成立，我们可以从只有一个隐变量(实际上就是把${\bf x}_{1:T}$视为一个整体)的情形出发，考虑${\bf x}_{0:1}$的情况</p><script type="math/tex; mode=display">\begin{align}\mathbb{E}_{ {\bf x}_{0:1}\sim q({\bf x}_{0:1})}\left[-\log\frac{p_\theta({\bf x}_{0:1})}{q({\bf x}_{1}|{\bf x}_0)}\right]\tag{6}\\=\mathbb{E}_{ {\bf x}_{0}\sim q({\bf x}_{0})}\left[-\log p_\theta({\bf x}_{0})\right]+\mathbb{E}_{ {\bf x}_{0:1}\sim q({\bf x}_{0:1})}\left[-\log\frac{p_\theta({\bf x}_{1}|{\bf x}_{0})}{q({\bf x}_{1}|{\bf x}_0)}\right]\tag{7}\label{7}\\=\mathbb{E}_{ {\bf x}_{0}\sim q({\bf x}_{0})}\left[-\log p_\theta({\bf x}_{0})\right]+\mathbb{E}_{ {\bf x}_{0}\sim q({\bf x}_{0})}\left[D_{\text{KL}}(q({\bf x}_{1}|{\bf x}_0))||p_\theta({\bf x}_{1}|{\bf x}_{0}))\right]\tag{8}\label{8}\end{align}</script><p>$(\ref{8})$的第二项是关于$q({\bf x}_1|{\bf x}_0)$与$p_\theta({\bf x}_1|{\bf x}_0)$的KL散度的期望，显然是非负的。从$(\ref{8})$也可以看到得到这个ELBO的过程实际上就是加了一个额外的非负项，这不是多此一举吗？通过下面的推导(参考原文附录中的推导)我们可以看到这样的举措实际上是把原来难以求解的非条件概率变为容易求解(tractable)的条件概率</p><script type="math/tex; mode=display">\begin{align}\mathbb{E}_{ {\bf x}_{0:T}\sim q({\bf x}_{0:T})}\left[-\log\frac{p_\theta({\bf x}_{0:T})}{q({\bf x}_{1:T}|{\bf x}_0)}\right]\tag{9}\label{9}\\=\mathbb{E}_{ {\bf x}_{0:T}\sim q({\bf x}_{0:T})}\left[-\log p_\theta({\bf x}_T)-\sum_{t\ge 1}\log\frac{p_\theta({\bf x}_{t-1}|{\bf x}_t)}{q({\bf x}_t|{\bf x}_{t-1})}\right]\tag{10}\label{10}\\=\mathbb{E}_{ {\bf x}_{0:T}\sim q({\bf x}_{0:T})}\left[-\log p_\theta({\bf x}_T)-\sum_{t>1}\log\frac{p_\theta({\bf x}_{t-1}|{\bf x}_t)}{q({\bf x}_t|{\bf x}_{t-1})}-\log\frac{p_\theta({\bf x}_0|{\bf x}_1)}{q({\bf x}_1|{\bf x}_0)}\right]\tag{11}\label{11}\\=\mathbb{E}_{ {\bf x}_{0:T}\sim q({\bf x}_{0:T})}\left[-\log p_\theta({\bf x}_T)-\sum_{t>1}\log\frac{p_\theta({\bf x}_{t-1}|{\bf x}_t)}{q({\bf x}_{t-1}|{\bf x}_{t},{\bf x}_0)}\cdot\frac{q({\bf x}_{t-1}|{\bf x}_0)}{q({\bf x}_t|{\bf x}_0)}-\log\frac{p_\theta({\bf x}_0|{\bf x}_1)}{q({\bf x}_1|{\bf x}_0)}\right]\tag{12}\label{12}\\=\mathbb{E}_{ {\bf x}_{0:T}\sim q({\bf x}_{0:T})}\left[-\log \frac{p_\theta({\bf x}_T)}{q({\bf x}_T|{\bf x}_0)}-\sum_{t>1}\log\frac{p_\theta({\bf x}_{t-1}|{\bf x}_t)}{q({\bf x}_{t-1}|{\bf x}_{t},{\bf x}_0)}-\log p_\theta({\bf x}_0|{\bf x}_1)\right]\tag{13}\label{13}\\\end{align}</script><p>此处要注意的是$(\ref{9})$到$(\ref{10})$不只用到了前向过程是马尔科夫链的假设【<strong>我们将在DDIM中看到，这一步实际上是不必要的</strong>】，并且用到了模型拟合的反向过程也是马尔科夫链的假设，即</p><script type="math/tex; mode=display">p_\theta({\bf x}_{0:T})=p_\theta({\bf x}_T)\prod_{t=1}^Tp_\theta({\bf x}_{t-1}|{\bf x}_t)\tag{14}</script><p>而$(\ref{11})$到$(\ref{12})$用到了如下关系(用到了前向过程的马尔科夫链假设)</p><script type="math/tex; mode=display">q({\bf x}_t|{\bf x}_{t-1})=q({\bf x}_t|{\bf x}_{t-1},{\bf x}_0)=\frac{q({\bf x}_{t-1}|{\bf x}_t,{\bf x}_0)\cdot q({\bf x}_t|{\bf x}_0)}{q({\bf x}_{t-1}|{\bf x}_0)}\tag{15}</script><p>分析得到的$(\ref{13})$式子，可以看到第1项和第2项实际上是多个KL散度，本质上都是让分子和分母上的分布足够接近，而第3项则可以通过在对数函数中重新引入分母$q({\bf x}_0|{\bf x}_1)$，使得其也变为KL散度的形式(此处本质上是引入了一个常数，所以对优化目标没影响)。</p><p>由于一般取$p_\theta({\bf x}_T)$为固定正态分布，而前向过程的$\beta_t$参数也一般人为确定，因此$(\ref{13})$中第1项就没有可学习的参数了。再考虑第二项，在DDPM中，<strong>其假设反向过程的单次转移也满足高斯分布</strong>(为了保证可计算性tractable)：</p><script type="math/tex; mode=display">p_\theta({\bf x}_{t-1}|{\bf x}_t):=\mathcal{N}({\bf x}_{t-1};{\mathbf \mu}_\theta({\mathbf x}_t,t),{\mathbf \Sigma}_\theta({\bf x}_t, t))\tag{16}</script><p>我们可以通过简单的推导得到：</p><script type="math/tex; mode=display">\begin{align}q({\bf x}_{t-1}|{\bf x}_t,{\bf x}_0)\\=\frac{q({\bf x}_{t}|{\bf x}_{t-1},{\bf x}_0)\cdot q({\bf x}_{t-1}|{\bf x}_0)}{q({\bf x}_t|{\bf x}_0)}\\=\frac{\mathcal{N}({\bf x}_t; \sqrt{1-\beta_t}{\bf x}_{t-1},\beta_t{\bf I})\cdot\mathcal{N}({\bf x}_{t-1};\sqrt{ {\bar\alpha}_{t-1} }{\bf x}_0,(1-{\bar\alpha}_{t-1}){\bf I})}{\mathcal{N}({\bf x}_t;\sqrt{ {\bar\alpha}_{t} }{\bf x}_0,(1-{\bar\alpha}_{t}){\bf I})}\\=\mathcal{N}\left({\bf x}_{t-1};\frac{(1-{\bar\alpha}_{t-1})\sqrt{1-\beta_t}{\bf x}_t+\beta_t\sqrt{ {\bar \alpha}_{t-1} }{\bf x}_0}{1-{\bar\alpha}_t}, \frac{1-{\bar\alpha}_{t-1} }{1-{\bar\alpha}_t}\beta_t{\bf I}\right)\end{align}\tag{17}</script><p>可以看到$q({\bf x}_{t-1}|{\bf x}_t,{\bf x}_0)\sim\mathcal{N}({\bf x}_{t-1};\tilde\mu({\bf x}_t,{\bf x}_0, t),\sigma^2_t{\bf I})$，其中</p><script type="math/tex; mode=display">\sigma^2_t=\frac{1-{\bar\alpha}_{t-1} }{1-{\bar\alpha}_t}\beta_t\tag{18}</script><p>如果认为反向过程单次转移的各个通道是完全独立的，那么就有</p><script type="math/tex; mode=display">p_\theta({\bf x}_{t-1}|{\bf x}_t)=\mathcal{N}({\bf x}_{t-1};{\mathbf \mu}_\theta({\mathbf x}_t,t),{\mathbf \Sigma}_\theta({\bf x}_t, t))=\mathcal{N}({\bf x}_{t-1};{\mathbf \mu}_\theta({\mathbf x}_t,t),\tilde\sigma^2_\theta({\bf x}_t, t))\tag{19}</script><p>为了方便计算，不妨直接令$\tilde\sigma^2_\theta({\bf x}_t, t)=\sigma_t^2$【<strong>此处可以做一些研究工作</strong>】，那么针对第二项的损失函数就可以展开写为闭合形式(closed-form)</p><script type="math/tex; mode=display">\begin{align}\mathcal{L}_{t-1}\\=\mathbb{E}_{ {\bf x}_{0:T}\sim q({\bf x}_{0:T})}\left[\frac{1}{2\sigma_t^2}(({\bf x}_{t-1}-\mu_\theta({\bf x}_{t},t))^2-({\bf x}_{t-1}-\tilde\mu({\bf x}_t,{\bf x}_0,t))^2)\right]\\=\mathbb{E}_{ {\bf x}_{0:T}\sim q({\bf x}_{0:T})}\left[\frac{1}{2\sigma_t^2}({\bf x}_{t-1}-\mu_\theta({\bf x}_{t},t))^2\right]+C\\=\mathbb{E}_{ {\bf x}_{0,(t-1),t}\sim q({\bf x}_{0,(t-1),t})}\left[\frac{1}{2\sigma_t^2}({\bf x}_{t-1}-\mu_\theta({\bf x}_{t},t))^2\right]+C\\=\mathbb{E}_{ {\bf x}_{0,t}\sim q({\bf x}_{0,t})}\left[\frac{1}{2\sigma_t^2}(\mathbb{E}[{\bf x}_{t-1}|{\bf x}_t,{\bf x}_0]-\mu_\theta({\bf x}_{t},t))^2\right]+C'\\=\mathbb{E}_{ {\bf x}_{0,t}\sim q({\bf x}_{0,t})}\left[\frac{1}{2\sigma_t^2}(\tilde\mu({\bf x}_t,{\bf x}_0,t)-\mu_\theta({\bf x}_{t},t))^2\right]+C'\end{align}\tag{20}</script><p>DDPM在这里做的进一步处理是，考虑到${\bf x}_t$是作为输入直接输入$\mu_\theta$的，因此借鉴ResNet的思想，我们希望不再重复预测这一部分内容，所以可以将$\tilde\mu$转变为以${\bf x}_t$为主导的形式(利用$(\ref{*})$)【此处论述有待商榷】</p><script type="math/tex; mode=display">\begin{align}\tilde\mu({\bf x}_t,{\bf x}_0,t)\\=\frac{((1-{\bar\alpha}_{t-1})\sqrt{1-\beta_t}{\bf x}_t+\beta_t\sqrt{ {\bar \alpha}_{t-1} }{\bf x}_0}{1-\bar\alpha_t}\\=\frac{(1-{\bar\alpha}_{t-1})\sqrt{1-\beta_t}{\bf x}_t+\beta_t\sqrt{ {\bar \alpha}_{t-1} }\frac{1}{\sqrt{\bar\alpha_t}}({\bf x}_t-\sqrt{1-{\bar\alpha_t}}\hat\varepsilon_t)}{1-\bar\alpha_t}\\=\frac{\left((1-{\bar\alpha}_{t-1})\sqrt{1-\beta_t}+\beta_t\sqrt{ {\bar \alpha}_{t-1} }\frac{1}{\sqrt{\bar\alpha_t}}\right){\bf x}_t-\beta_t\sqrt{ {\bar \alpha}_{t-1} }\frac{1}{\sqrt{\bar\alpha_t}}\sqrt{1-{\bar\alpha_t}}\hat\varepsilon_t}{1-\bar\alpha_t}\\=A{\bf x}_t-B{\varepsilon}\end{align}\tag{21}</script><p>回到$\mathcal{L}_{t-1}$，继续推导得到【原文期望的底是${\bf x}_0$，本质上是相同的】</p><script type="math/tex; mode=display">\begin{align}\mathcal{L}_{t-1}\\=\mathbb{E}_{ {\bf x}_t\sim q({\bf x}_t),\hat\varepsilon_t\sim\mathcal{N}(0,{\bf I})}\left[\frac{1}{2\sigma_t^2}\left(A{\bf x}_t-B\hat\varepsilon_t-\mu_\theta({\bf x}_{t},t)\right)^2\right]+C'\\=\mathbb{E}_{ {\bf x}_t\sim q({\bf x}_t),{\hat\varepsilon}_t\sim\mathcal{N}(0,{\bf I})}\left[\frac{1}{2\sigma_t^2}\left(A{\bf x}_t-B\hat\varepsilon_t-(A{\bf x}_t-B\varepsilon_\theta({\bf x}_t,t))\right)^2\right]+C'\\=\mathbb{E}_{ {\bf x}_t\sim q({\bf x}_t),{\hat\varepsilon}_t\sim\mathcal{N}(0,{\bf I})}\left[\frac{B^2}{2\sigma_t^2}\left(\hat\varepsilon_t-\varepsilon_\theta({\bf x}_t,t)\right)^2\right]+C''\\=\mathbb{E}_{ {\bf x}_t\sim q({\bf x}_t),{\hat\varepsilon}_t\sim\mathcal{N}(0,{\bf I})}\left[\frac{\beta_t^2}{2\sigma_t^2(1-\bar\alpha_t)\alpha_t}\left(\hat\varepsilon_t-\varepsilon_\theta({\bf x}_t,t)\right)^2\right]+C''\end{align}\tag{22}</script><p>最后，分析优化目标中的第三项，DDPM原文中采取了一种离散化方法来将连续高斯分布$\mathcal{N}({\bf x}_0;\mu_\theta({\bf x}_1,1),\sigma^2{\bf I})$【<strong>此处认为各个通道相互独立</strong>】分配给各个离散单元(在图片中，一般认为为$\{0,1,…,255\}$到$[-1,1]$的线性映射)：</p><script type="math/tex; mode=display">p_\theta({\bf x}_0|{\bf x}_1)=\prod_{i=1}^{D}\int_{\delta_{-}(x_0^i)}^{\delta_+(x_0^i)}{\mathcal{N}(x;\mu_\theta^i({\bf x}_1,1),\sigma_1^2)}dx</script><script type="math/tex; mode=display">\delta_+(x)=\left\{\begin{align}\infty \text{, if }x=1\\x+\frac{1}{255} \text{, if }x<1\end{align}\right.</script><script type="math/tex; mode=display">\delta_-(x)=\left\{\begin{align}-\infty \text{, if }x=-1\\x-\frac{1}{255} \text{, if }x>-1\end{align}\right.</script><p>其中$D$为数据维度，$i$为其中某个指定维度。【<strong>此处留待进一步分析</strong>】</p><h2 id="DDIM优化目标梳理"><a href="#DDIM优化目标梳理" class="headerlink" title="DDIM优化目标梳理"></a>DDIM优化目标梳理</h2><p>DDIM是对DDPM的假设条件的放宽，从而得到了更加广义的结果。</p><p>重新考虑$(\ref{9})$式</p><script type="math/tex; mode=display">\begin{align}\mathbb{E}_{ {\bf x}_{0:T}\sim q({\bf x}_{0:T})}\left[-\log\frac{p_\theta({\bf x}_{0:T})}{q({\bf x}_{1:T}|{\bf x}_0)}\right]\\=\mathbb{E}_{ {\bf x}_{0:T}\sim q({\bf x}_{0:T})}\left[-\log p_\theta({\bf x}_T)-\sum_{t\ge 1}\log\frac{p_\theta({\bf x}_{t-1}|{\bf x}_t)}{q({\bf x}_t|{\bf x}_{t-1},{\bf x}_0)}\right]\\=\mathbb{E}_{ {\bf x}_{0:T}\sim q({\bf x}_{0:T})}\left[-\log p_\theta({\bf x}_T)-\sum_{t>1}\log\frac{p_\theta({\bf x}_{t-1}|{\bf x}_t)}{q({\bf x}_t|{\bf x}_{t-1},{\bf x}_0)}-\log\frac{p_\theta({\bf x}_0|{\bf x}_1)}{q({\bf x}_1|{\bf x}_0)}\right]\\=\mathbb{E}_{ {\bf x}_{0:T}\sim q({\bf x}_{0:T})}\left[-\log p_\theta({\bf x}_T)-\sum_{t>1}\log\frac{p_\theta({\bf x}_{t-1}|{\bf x}_t)}{q({\bf x}_{t-1}|{\bf x}_{t},{\bf x}_0)}\cdot\frac{q({\bf x}_{t-1}|{\bf x}_0)}{q({\bf x}_t|{\bf x}_0)}-\log\frac{p_\theta({\bf x}_0|{\bf x}_1)}{q({\bf x}_1|{\bf x}_0)}\right]\\=\mathbb{E}_{ {\bf x}_{0:T}\sim q({\bf x}_{0:T})}\left[-\log \frac{p_\theta({\bf x}_T)}{q({\bf x}_T|{\bf x}_0)}-\sum_{t>1}\log\frac{p_\theta({\bf x}_{t-1}|{\bf x}_t)}{q({\bf x}_{t-1}|{\bf x}_{t},{\bf x}_0)}-\log p_\theta({\bf x}_0|{\bf x}_1)\right]\end{align}</script><p><strong>实际上在$(\ref{9})$到$(\ref{10})$这里，我们压根不需要用到前向过程的马尔科夫链假设</strong>，也就是说之前DDPM中引入的假设实际上比我们需要的假设要多。</p><p>DDPM构建核心的优化目标的推导思路如下【参考苏神博客】</p><script type="math/tex; mode=display">q({\bf x}_t|{\bf x}_{t-1})\text{,马尔科夫链假设}\stackrel{推导}{\longrightarrow}q({\bf x}_t|{\bf x}_0),q({\bf x}_t|{\bf x}_{t-1},{\bf x}_0)\stackrel{推导}{\longrightarrow}q({\bf x}_{t-1}|{\bf x}_t,{\bf x}_0)\stackrel{近似}{\longrightarrow}p_{\theta}({\bf x}_{t-1}|{\bf x}_t)</script><p>DDIM作者对DDPM的一个观察是其最终得到的第二项的损失函数实际上仅仅与$q({\bf x}_t|{\bf x}_0)$和$q({\bf x}_t|{\bf x}_{t-1},{\bf x}_0)$直接相关，而不是直接依赖于$q({\bf x}_{t}|{\bf x}_{t-1})$和马尔科夫链假设。如果我们将对$q({\bf x}_{t}|{\bf x}_{t-1})$的假设和马尔科夫链假设扔掉，那么实际上就拓宽了解的空间，因为对于形式确定的$q({\bf x}_t|{\bf x}_0)$与$q({\bf x}_t|{\bf x}_{t-1},{\bf x}_0)$，可以反推出$q({\bf x}_t|{\bf x}_{t-1})$形式：</p><script type="math/tex; mode=display">q({\bf x}_t|{\bf x}_{t-1})=\int q({\bf x}_t|{\bf x}_{t-1},{\bf x}_0)q({\bf x}_{t-1}|{\bf x}_0)\frac{q({\bf x}_0)}{q({\bf x}_{t-1})}d{\bf x}_0</script><p>反推出的$q({\bf x}_t|{\bf x}_{t-1})$并不一定是高斯分布，因此相较于DDPM扩展了解的空间，事实上我们可以进一步思考，对于给定的$q({\bf x}_t|{\bf x}_{t-1})$，我们必定可以推导出确定的$q({\bf x}_t|{\bf x}_0)$和$q({\bf x}_t|{\bf x}_{t-1},{\bf x}_0)$，但是给定$q({\bf x}_t|{\bf x}_0)$和$q({\bf x}_t|{\bf x}_{t-1},{\bf x}_0)$，我们却无法(在不给定$q({\bf x}_0)$的时候)反推出确定的$q({\bf x}_t|{\bf x}_{t-1})$，可以说DDPM中的假设实际上隐含了某种对$q({\bf x}_0)$的限制，而DDIM放宽了这种限制【<strong>有待商榷</strong>】。</p><p>不过在假设$q({\bf x}_t|{\bf x}_0)$与$q({\bf x}_t|{\bf x}_{t-1},{\bf x}_0)$的形式的时候，需要额外满足限制</p><script type="math/tex; mode=display">q({\bf x}_t|{\bf x}_0)=\int q({\bf x}_t|{\bf x}_{t-1},{\bf x}_0)q({\bf x}_{t-1}|{\bf x}_0)d{\bf x}_{t-1}\tag{23}\label{23}</script><p>在如上背景下，DDIM作者提出了如下的前向扩散过程的展开形式</p><script type="math/tex; mode=display">q({\bf x}_{0:T}):=q({\bf x}_0)\prod_{t=1}^T q({\bf x}_t|{\bf x}_{t-1},{\bf x}_0)</script><p>此时引入假设1：</p><script type="math/tex; mode=display">q({\bf x}_t|{\bf x}_0)=\mathcal{N}({\bf x}_t;\sqrt{\bar\alpha_t}{\bf x}_0,(1-\bar\alpha_t){\bf I})</script><p>假设2：</p><script type="math/tex; mode=display">q({\bf x}_{t}|{\bf x}_{t-1},{\bf x}_0)=\mathcal{N}({\bf x}_t;\gamma_t{\bf x}_0+\lambda_t{\bf x}_{t-1},\sigma_t^2{\bf I})</script><p>那么上述两个假设需要满足限制$(\ref{23})$，求解该限制</p><script type="math/tex; mode=display">\begin{align}\mathcal{N}({\bf x}_t;\sqrt{\bar\alpha_t}{\bf x}_0,(1-\bar\alpha_t){\bf I})\\=\int\mathcal{N}({\bf x}_t;\gamma_t{\bf x}_0+\lambda_t{\bf x}_{t-1},\sigma_t^2{\bf I})\cdot\mathcal{N}({\bf x}_{t-1};\sqrt{\bar\alpha_t}{\bf x}_0,(1-\bar\alpha_t){\bf I})d{\bf x}_{t-1}\end{align}</script><p>此处用离散随机微分方程比较好计算(<strong>千万注意各个噪声变量之间的独立性</strong>)</p><script type="math/tex; mode=display">\begin{align}{\bf x}_t=\sqrt{\bar\alpha_t}{\bf x}_0+\sqrt{1-\bar\alpha_t}\varepsilon_{t}\\{\bf x}_{t-1}=\sqrt{\bar\alpha_{t-1}}{\bf x}_0+\sqrt{1-\bar\alpha_{t-1}}\varepsilon_{t-1}\\{\bf x}_t=\gamma_t{\bf x}_0+\lambda_t{\bf x}_{t-1}+\sigma_t\hat\varepsilon_t\end{align}</script><p>(对应系数相等)求解得到</p><script type="math/tex; mode=display">\begin{align}\gamma_t=\sqrt{\bar\alpha_t}-\sqrt{\frac{\bar\alpha_{t-1}(1-\bar\alpha_t-\sigma_t^2)}{1-\bar\alpha_{t-1} } }\\\lambda_t=\sqrt{\frac{1-\bar\alpha_t-\sigma_t^2}{1-\bar\alpha_{t-1} } }\end{align}</script><p>进而可以得到(<strong>注意此处不能直接使用前面提到的随机微分方程进行计算，因为存在独立性问题</strong>)</p><script type="math/tex; mode=display">\begin{align}q({\bf x}_{t-1}|{\bf x}_{t},{\bf x}_0)\\=\frac{q({\bf x}_t|{\bf x}_{t-1},{\bf x}_0)q({\bf x}_{t-1}|{\bf x}_0)}{q({\bf x}_{t}|{\bf x}_0)}\\=\frac{\mathcal{N}({\bf x}_t;\gamma_t{\bf x}_0+\lambda_t{\bf x}_{t-1},\sigma_t^2{\bf I})\cdot\mathcal{N}({\bf x}_{t-1};\sqrt{\bar\alpha_{t-1}}{\bf x}_0,(1-\bar\alpha_{t-1}){\bf I})}{\mathcal{N}({\bf x}_t;\sqrt{\bar\alpha_t}{\bf x}_0,(1-\bar\alpha_t){\bf I})}\\=\mathcal{N}\left({\bf x}_{t-1};\frac{\left(\sigma_t^2\sqrt{\bar\alpha_{t-1}}-\gamma_t(1-\bar\alpha_{t-1})\lambda_t\right){\bf x}_0+\lambda_t(1-\bar\alpha_{t-1}){\bf x}_t}{\sigma_t^2+\lambda_t^2(1-\bar\alpha_{t-1})},\frac{\sigma_t^2(1-\bar\alpha_{t-1})}{\sigma_t^2+\lambda_t^2(1-\bar\alpha_{t-1})}{\bf I} \right)\\=\mathcal{N}\left({\bf x}_{t-1};\sqrt{\bar\alpha_{t-1}}{\bf x}_0+\frac{\sqrt{(1-\bar\alpha_{t-1})(1-\bar\alpha_t-\sigma^2_t)}}{1-\bar\alpha_t}({\bf x}_t-\sqrt{\bar\alpha_t}{\bf x}_0),\frac{1-\bar\alpha_{t-1}}{1-\bar\alpha_t}\sigma_t^2{\bf I}\right)\end{align}</script><p>【DDIM原文中的结果实际上是做了代换$\sigma_t^2=\frac{1-\bar\alpha_{t-1}}{1-\bar\alpha_t}\sigma_t^2$】接下来的步骤就和DDPM很相似了(仍然设方差一致，是不需要学习的)：</p><script type="math/tex; mode=display">\begin{align}\tilde\mu({\bf x}_t,{\bf x}_0,t)\\=\sqrt{\bar\alpha_{t-1}}{\bf x}_0+\frac{\sqrt{(1-\bar\alpha_{t-1})(1-\bar\alpha_t-\sigma^2_t)}}{1-\bar\alpha_t}({\bf x}_t-\sqrt{\bar\alpha_t}{\bf x}_0)\\=\sqrt{\bar\alpha_{t-1}}\frac{1}{\sqrt{\bar\alpha_t}}({\bf x}_t-\sqrt{1-\bar\alpha_t}\varepsilon_t)+\sqrt{\frac{(1-\bar\alpha_{t-1})(1-\bar\alpha_t-\sigma^2_t)}{1-\bar\alpha_t}}\varepsilon_t\\=\sqrt{\frac{\bar\alpha_{t-1} }{\bar\alpha_t} } {\bf x}_t+\left(\sqrt{\frac{(1-\bar\alpha_{t-1})(1-\bar\alpha_t-\sigma^2_t)}{1-\bar\alpha_t}}-\sqrt{\frac{\bar\alpha_{t-1}(1-\bar\alpha_t)}{\bar\alpha_t}}\right)\varepsilon_t\\=A{\bf x}_0+B\varepsilon_t\end{align}</script><p>进一步可以推导得到损失函数</p><script type="math/tex; mode=display">\begin{align}\mathcal{L}_{t-1}\\=\mathbb{E}_{ {\bf x}_t\sim q({\bf x}_t),{\varepsilon}_t\sim\mathcal{N}(0,{\bf I})}\left[\frac{(1-\bar\alpha_t)B^2}{2(1-\bar\alpha_{t-1})\sigma_t^2}\left(\varepsilon_t-\varepsilon_\theta({\bf x}_t,t)\right)^2\right]+C''\end{align}</script><p>损失函数前的系数其实不是很重要，可以认为主要是推理时的采样流程发生了变化，尤其是$\sigma_t^2$可以被设置为零，这实际上就实现了初始值到末尾值的一一对应，即为DDIM名字的由来。</p><h2 id="DDIM的加速采样"><a href="#DDIM的加速采样" class="headerlink" title="DDIM的加速采样"></a>DDIM的加速采样</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成式模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化器总结</title>
      <link href="/2025/03/05/31689640.html"/>
      <url>/2025/03/05/31689640.html</url>
      
        <content type="html"><![CDATA[<p>本文参考：<a href="https://juejin.cn/post/7084409806492008456">https://juejin.cn/post/7084409806492008456</a></p><p>设代优化的模型参数为$\theta$，目标函数（损失函数）为$J(\theta)$，学习率为$\eta$，迭代周期为$t$，损失函数$J(\theta)$关于当前参数$\theta$的梯度为$g_t=\nabla_\theta J(\theta)$。</p><h2 id="梯度下降（Gradient-Descent）"><a href="#梯度下降（Gradient-Descent）" class="headerlink" title="梯度下降（Gradient Descent）"></a>梯度下降（Gradient Descent）</h2><p>参数更新方法为：</p><script type="math/tex; mode=display">\theta_{t+1}=\theta_t-\eta\cdot\nabla_\theta J(\theta)=\theta_t-\eta\cdot g_t</script><p>该方法存在如下的一些缺点：</p><ul><li>训练速度慢：在大规模数据集上进行训练时，每输入一个样本都要进行一次参数更新，而每次迭代都要遍历所有的样本。</li><li>容易陷入局部解：如果走到局部的洼地，可能会认为已经达到最低点。</li></ul><h2 id="批量梯度下降（Batch-Gradient-Descent）"><a href="#批量梯度下降（Batch-Gradient-Descent）" class="headerlink" title="批量梯度下降（Batch Gradient Descent）"></a>批量梯度下降（Batch Gradient Descent）</h2><p>不像标准GD那样，对每个样本输入都进行参数更新，而是直接对所有数据的输入进行参数更新（相当于单独计算每个样本的梯度，然后将其求平均）：</p><script type="math/tex; mode=display">\theta_{t+1}=\theta_t-\eta\cdot\frac{1}{n}\cdot\sum_{i=1}^n\nabla_{\theta_t}J_i(\theta_t,x_i,y_i)</script><p>由于每一步迭代都使用了全部的样本，因此每次下降的方向为整体的平均梯度，收敛过程会比较稳定。</p><p>缺点是每次更新会用到所有的样本计算梯度，计算起来很慢。</p><h2 id="随机梯度下降（Stochastic-Gradient-Descent）"><a href="#随机梯度下降（Stochastic-Gradient-Descent）" class="headerlink" title="随机梯度下降（Stochastic Gradient Descent）"></a>随机梯度下降（Stochastic Gradient Descent）</h2><p>每次更新不需要计算整个数据样本集的梯度，而是每次参数更新时仅仅选取一个样本$(x_i,y_i)$计算其梯度，参数更新公式为：</p><script type="math/tex; mode=display">\theta_{t+1}=\theta_t-\alpha\cdot\nabla_\theta J_i(\theta,x_i,y_i)</script><p>SGD由于每次参数更新仅仅需要计算一个样本的梯度，因此训练速度很快，但是由于不是每次都向着整体最优化方向，导致梯度下降波动很大，更容易从一个局部最优跳到另一个局部最优，导致准确度下降。有论文提到，当缓慢降低学习率时，SGD会显示与BGD相同的收敛行为，几乎一定会收敛到局部或全局最小值。</p><p>优点：</p><ul><li>由于每次迭代只使用了一个样本计算梯度，训练速度快，包含一定随机性，但是从期望来看，每次计算的梯度基本是正确的导数的。虽然看起来SGD波动非常大，会走很多弯路，但是对梯度的要求很低（计算梯度快），而且对于引入噪声，大量的理论和实践工作证明，只要噪声不是特别大，SGD都能很好地收敛。</li><li>应用大型数据集时，训练速度很快。比如每次从百万数据样本中，取几百个数据点，算一个SGD梯度，更新一下模型参数。相比于标准梯度下降法的遍历全部样本，每输入一个样本更新一次参数，要快得多。</li></ul><p>缺点：</p><ul><li>更新频繁，带有随机性，会造成损失函数在收敛过程中严重震荡。SGD没能单独克服局部最优解的问题（主要）。</li><li>SGD在随机选择梯度的同时会引入噪声，使得权值更新的方向不一定正确（次要）。</li></ul><h2 id="小批量梯度下降（Mini-batch-Gradient-Descent）"><a href="#小批量梯度下降（Mini-batch-Gradient-Descent）" class="headerlink" title="小批量梯度下降（Mini-batch Gradient Descent）"></a>小批量梯度下降（Mini-batch Gradient Descent）</h2><p>该算法是BGD和SGD的折中，对于一个含有$n$个训练样本的数据集，每次参数更新选择一个大小为$m$的小批量计算其平均梯度，参数更新公式为</p><script type="math/tex; mode=display">\theta_{t+1}=\theta_t-\eta\sum_{i=x}^{i=x+m-1}\nabla_\theta J_i(\theta,x_i,y_i)</script><p>这样既保证了训练的速度，也保证了最后收敛的准确率，目前SGD一般默认为小批量梯度下降。</p><p>优点：</p><ul><li>可以降低参数更新时的方差，收敛更稳定，另一方面可以充分地利用深度学习库中高度优化的矩阵操作来进行更有效的梯度计算。</li></ul><p>缺点：</p><ul><li>Mini-batch gradient descent 不能保证很好的收敛性，learning rate 如果选择的太小，收敛速度会很慢，如果太大，loss function 就会在极小值处不停地震荡甚至偏离（有一种措施是先设定大一点的学习率，当两次迭代之间的变化低于某个阈值后，就减小 learning rate，不过这个阈值的设定需要提前写好，这样的话就不能够适应数据集的特点）。对于非凸函数，还要避免陷于局部极小值处，或者鞍点处，因为鞍点所有维度的梯度都接近于0，SGD 很容易被困在这里（会在鞍点或者局部最小点震荡跳动，因为在此点处，如果是BGD的训练集全集带入，则优化会停止不动，如果是mini-batch或者SGD，每次找到的梯度都是不同的，就会发生震荡，来回跳动）。</li><li>SGD对所有参数更新时应用同样的 learning rate，如果我们的数据是稀疏的，我们更希望对出现频率低的特征进行大一点的更新， 且learning rate会随着更新的次数逐渐变小。</li></ul><h2 id="动量优化法（Momentum）"><a href="#动量优化法（Momentum）" class="headerlink" title="动量优化法（Momentum）"></a>动量优化法（Momentum）</h2><blockquote><p>在梯度下降公式中，存在两个改进点，一是学习率，二是梯度。其分别衍生出自适应（adaptive）学习率方法与动量（momentum）方法</p></blockquote><p>动量优化法引入了动量的概念，假如小球处于坡度上时，其会不断加速滚到坡底，当其反冲上坡时则会不断减速。带有动量的小球不但可以加速梯度下降，还可以借助积累的动量，冲过小坡，避免落入局部最优点。【其实引入动量的话也避免了在病态情形下的剧烈震荡】</p><h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h3><p>梯度下降容易被困在局部最小的沟壑来回震荡，并且收敛速度仍然不够快。动量法可以一定程度上解决该问题。</p><p>momentum的思想：在参数更新时一定程度上保留之前更新的方向，同时又利用当前的批次的方向微调最终的更新方向，即通过积累此前的动量来加速当前的梯度。</p><p>SGD只使用了当步参数的梯度，随机性较大。如果将历次迭代的梯度按比例融合，可能更加稳定、更有利于跳出局部最优。</p><p>设$m_t$为$t$时刻的动量，$\gamma$表示动量因子，通常取值$0.9$或近似值，在SGD的基础上增加动量，则参数更新公式为</p><script type="math/tex; mode=display">\begin{aligned}m_{t+1}=\gamma\cdot m_t+\eta\cdot\nabla_\theta J(\theta)\\\theta_{t+1}=\theta_t-m_{t+1}\end{aligned}</script><p>一阶动量$m_t$为各个时刻梯度方向的指数移动平均值，约等于最近$\frac{1}{(1-\gamma)}$个时刻的梯度向量和的平均值。也就是说，$t$时刻的下降方向，不仅由当前点的梯度方向决定，而且由此前累积的下降方向决定。</p><p>动量因子 γ\gammaγ 的经验值为0.9，这就意味着下降方向主要是此前累积的下降方向，并略微偏向当前时刻的下降方向。在梯度方向改变时，momentum能够降低参数更新速度，从而减少震荡，在梯度方向相同时，momentum可以加速参数更新， 从而加速收敛。</p><p>动量主要解决SGD的两个问题：</p><ul><li>随机梯度的方法（引入的噪声）</li><li>Hessian矩阵病态问题（可以理解为SGD在收敛过程中和正确梯度相比来回摆动比较大的问题）</li></ul><p>优点：</p><ul><li>前后梯度一致的时候能够加速学习；前后梯度不一致的时候能够抑制震荡，越过局部极小值（加速收敛，减小震荡）</li></ul><p>缺点：</p><ul><li>增加了一个超参数</li></ul><h3 id="NAG（Nesterov-accelerated-gradient）"><a href="#NAG（Nesterov-accelerated-gradient）" class="headerlink" title="NAG（Nesterov accelerated gradient）"></a>NAG（Nesterov accelerated gradient）</h3><p>为了增强探索性，进一步引入了 nesterov 动量。momentum保留了上一时刻的梯度 $\nabla_\theta J(\theta)$，对其没有进行任何改变，NAG是momentum的改进版，在梯度更新时做了一个矫正，具体做法是在当前的梯度$\nabla_\theta J(\theta)$上添加上一个时刻的动量$\gamma\cdot m_t$，梯度改变为$\nabla_\theta J(\theta-\gamma\cdot m_t)$</p><script type="math/tex; mode=display">\begin{aligned}m_{t+1}=\gamma\cdot m_t+\eta\cdot\nabla_\theta J(\theta-\gamma\cdot m_t)\\\theta_{t+1}=\theta_t-m_{t+1}\end{aligned}</script><p>加上nesterov项后，梯度在大的跳跃后，进行计算对当前梯度进行校正。momentum首先计算一个梯度，然后在加速更新梯度的方向进行一个大的跳跃，nesterov项首先在之前加速的梯度方向进行一个大的跳跃，计算梯度然后进行校正。</p><p>Nesterov动量梯度的计算在模型参数施加当前速度之后，因此可以理解为往标准动量中添加了一个校正因子。在凸批量梯度的情况下，Nesterov动量将额外误差收敛率从$O(1/k)$(k步后) 改进到$O(1/k^2)$，然而，在随机梯度情况下，Nesterov动量对收敛率的作用却不是很大。</p><h2 id="自适应学习率优化算法"><a href="#自适应学习率优化算法" class="headerlink" title="自适应学习率优化算法"></a>自适应学习率优化算法</h2><blockquote><p>传统优化算法往往将学习率设置为常数，或者根据训练次数调节学习率，然而学习率对模型性能有着显著的影响，因此上述策略有些僵化，最好可以动态地更新学习率。</p></blockquote><p>使用统一的全局学习率的缺点：</p><ul><li>对于某些参数，通过算法已经优化到了极小值附近，但是有的参数仍然有着很大的梯度。</li><li>如果学习率太小，则梯度很大的参数会有一个很慢的收敛速度； 如果学习率太大，则已经优化得差不多的参数可能会出现不稳定的情况。 解决方案：对每个参与训练的参数设置不同的学习率，在整个学习过程中通过一些算法自动适应这些参数的学习率。 如果损失与某一指定参数的偏导的符号相同，那么学习率应该增加； 如果损失与该参数的偏导的符号不同，那么学习率应该减小。</li></ul><h3 id="AdaGrad（Adaptive-Gradient）"><a href="#AdaGrad（Adaptive-Gradient）" class="headerlink" title="AdaGrad（Adaptive Gradient）"></a>AdaGrad（Adaptive Gradient）</h3><p>该方法对学习率进行了约束，对于经常更新的参数，我们已经积累了大量的相关知识，不希望被单个样本影响太大，希望学习速率慢一些；对于偶尔更新的参数，我们了解的信息太少，希望能从每个偶然出现的样本（稀疏特征的样本）身上多学一些，即学习速率大一些。而该方法中开始使用二阶动量，才意味着“自适应学习率”优化算法时代的到来。</p><p>AdaGrad 算法，独立地适应所有模型参数的学习率，缩放每个参数反比于其<strong>所有梯度历史平均值总和的平方根</strong>。</p><ul><li>具有损失函数最大梯度的参数相应地有个快速下降的学习率。</li><li>而具有小梯度的参数在学习率上有相对较小的下降。</li></ul><p>其梯度更新公式为</p><script type="math/tex; mode=display">\theta_{t+1,i}=\theta_{t,i}-\frac{\eta}{\sqrt{G_{t,ii}+\epsilon}}\cdot g_{t,i}</script><p>其中，$g_{t,i}$为$t$时刻$\theta_i$的梯度</p><script type="math/tex; mode=display">g_{t,i}=\nabla_{\theta_t}J(\theta_{t,i})</script><p>如果是普通的SGD，那么每一个时刻的梯度更新公式为</p><script type="math/tex; mode=display">\theta_{t+1,i}=\theta_{t,i}-\eta\cdot g_{t,i}</script><p>不过可以看到AdaGrad的更新公式中，矫正的学习率$\frac{\eta}{\sqrt{G_{t,ii}+\epsilon}}$也随着$t$和$i$而变化，也就是所谓的“自适应”。（小平滑项$\epsilon$是为了防止分母为零）</p><p>上式中的$G_t$为对角矩阵，$(i,i)$元素就是到$t$时刻为止，参数$\theta_i$的累积梯度平方和，也就是“二阶动量”。$\sqrt{G_{t,ii}+\epsilon}$是恒大于0的，而且参数更新越频繁，二阶动量就越大，学习率$\frac{\eta}{\sqrt{G_{t,ii}+\epsilon}}$就越小，所以在稀疏的数据场景下表现比较好。</p><p>优点：</p><ul><li>自适应的学习率，可以减少人工调节</li></ul><p>缺点：</p><ul><li>仍需要手工设置一个全局学习率$\eta$，如果设置过大的话，会使regularizer过于敏感，对梯度的调节太大</li><li>中后期，分母上梯度累加的平方和会越来越大，使得参数更新量趋于0，训练提前结束，无法进一步学习</li></ul><h3 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h3><p>由于AdaGrad调整学习率变化过于激进，我们考虑一个改变二阶动量计算方法的策略：不累积全部历史梯度，而只关注过去一段时间窗口的下降梯度，即RMSprop只累加固定大小的项，并且也不直接存储这些项，仅仅是近似计算对应的平均值（指数移动平均值），这就避免了二阶动量持续累积、导致训练过程提前结束的问题了，参数更新公式如下</p><script type="math/tex; mode=display">\theta_{t+1}=\theta_t-\frac{\eta}{\sqrt{E[g^2]_t+\epsilon}}g_t</script><p>与AdaGrad相比，分母的$G$变成了过去梯度平方的衰减平均值（指数衰减平均值）。其中$E$的计算公式如下，$t$时刻的值依赖于前一时刻的平均和当前的梯度：</p><script type="math/tex; mode=display">E[g^2]_t=\gamma E[g^2]_{t-1}+(1-\gamma)g_t^2</script><p>这个分母相当于梯度的均方根，所以可以用RMS简写为</p><script type="math/tex; mode=display">\theta_{t+1}=\theta_t-\frac{\eta}{RMS[g]_t}g_t</script><p>优点：</p><ul><li>进一步发展了AdaGrad，缓解了学习率过低的问题</li></ul><p>缺点：</p><ul><li>仍然依赖于全局学习率$\eta$</li></ul><h3 id="Adadelta"><a href="#Adadelta" class="headerlink" title="Adadelta"></a>Adadelta</h3><p>可以将RMSprop中的学习率$\eta$换成$RMS[\Delta\theta]$，这样的话，就不需要提前设定学习率了</p><script type="math/tex; mode=display">\theta_{t+1}=\theta_t-\frac{RMS[\Delta\theta]_{t-1}}{RMS[\Delta\theta]_t}g_t</script><p>优点：</p><ul><li>不依赖全局学习率</li><li>训练前中期，加速效果不错，很快</li></ul><p>缺点：</p><ul><li>训练后期，反复在局部最小值附近抖动</li></ul><h3 id="Adam（Adaptive-Moment-Estimation）"><a href="#Adam（Adaptive-Moment-Estimation）" class="headerlink" title="Adam（Adaptive Moment Estimation）"></a>Adam（Adaptive Moment Estimation）</h3><p>Adam 结合了前面方法的一阶动量和二阶动量，相当于 Ada + Momentum，SGD-M和NAG在SGD基础上增加了一阶动量，AdaGrad和AdaDelta在SGD基础上增加了二阶动量。</p><p>Adam 除了像 Adadelta 和 RMSprop 一样存储了过去梯度的平方$v_t$的指数衰减平均值 ，也像 momentum 一样保持了过去梯度$m_t$的指数衰减平均值：</p><script type="math/tex; mode=display">\begin{aligned}m_t=\beta_1 m_{t-1}+(1-\beta_1)g_t\\v_t=\beta_2v_{t-1}+(1-\beta_2)g_t^2\end{aligned}</script><p>如果$m_t$和$v_t$被初始化为 0向量，那么它们就会向0偏置，所以做了<strong>偏差校正</strong> ，通过计算偏差校正后的$m_t$和$v_t$来抵消这些偏差</p><script type="math/tex; mode=display">\begin{aligned}\hat m_t=\frac{m_t}{1-\beta_1^t}\\\hat v_t=\frac{v_t}{1-\beta_2^t}\end{aligned}</script><p>最终的更新公式为</p><script type="math/tex; mode=display">\theta_{t+1}=\theta_t-\frac{\eta}{\sqrt{\hat v_t}+\epsilon}\hat m_t</script><p>优点：</p><ul><li>Adam梯度经过偏置校正后，每一次迭代学习率都有一个固定范围，使得参数比较平稳。</li><li>结合了Adagrad善于处理稀疏梯度和RMSprop善于处理非平稳目标的优点。</li><li>为不同的参数计算不同的自适应学习率。</li><li>也适用于大多非凸优化问题——适用于大数据集和高维空间。</li></ul><p>缺点： </p><ul><li>Adam 使用动量的滑动平均，可能会随着训练数据变化而抖动比较剧烈，在online场景可能波动较大，在广告场景往往效果不如 AdaGrad。</li></ul><h3 id="Nadam"><a href="#Nadam" class="headerlink" title="Nadam"></a>Nadam</h3><p>Adam遗漏了Nesterov项，因此在Adam的基础上，加上Nesterov项就是Nadam了，参数更新公式如下：</p><script type="math/tex; mode=display">\theta_{t+1}=\theta_t-\frac{\eta}{\sqrt{\hat v_t}+\epsilon}(\beta_1\hat m_t+\frac{(1-\beta_1)g_t}{1-\beta_1^t})</script><p>其中</p><script type="math/tex; mode=display">\begin{aligned}m_t=\beta_1m_{t-1}+(1-\beta_1)g_t\\\hat m_t=\frac{m_t}{1-\beta_1^t}\end{aligned}</script><p>Nadam对学习率有更强的约束，同时对梯度的更新也有更直接的影响。一般而言，在使用带动量的RMSprop或Adam的问题上，使用Nadam可以取得更好的结果。</p><h3 id="AdamW"><a href="#AdamW" class="headerlink" title="AdamW"></a>AdamW</h3><p>Adam有很多的优点，但是在很多数据集上的最好效果还是用SGD with Momentum细调出来的。可见Adam的泛化性并不如SGD with Momentum。有论文提出其中一个重要原因就是 <strong>Adam中L2正则化项并不像在SGD中那么有效</strong>。</p><ul><li><p>L2正则和Weight Decay在Adam这种自适应学习率算法中并不等价，只有在标准SGD的情况下，可以将L2正则和Weight Decay看做一样。特别是，当与自适应梯度相结合时，L2正则化导致具有较大历史参数和/或梯度幅度的权重比使用权重衰减时更小。</p></li><li><p>使用Adam优化带L2正则的损失并不有效，如果引入L2正则化项，在计算梯度的时候会加上正则项求梯度的结果。正常的权重衰减是对所有的权重都采用相同的系数进行更新，本身比较大的一些权重对应的梯度也会比较大，惩罚也越大。但由于Adam计算步骤中减去项会有除以梯度平方的累积，使得梯度大的减去项偏小，从而具有大梯度的权重不会像解耦权重衰减那样得到正则化。 这导致自适应梯度算法的L2和解耦权重衰减正则化的不等价。</p></li></ul><p>而在常见的深度学习库中只提供了L2正则，并没有提供权重衰减的实现。这可能就是导致Adam跑出来的很多效果相对SGD with Momentum有偏差的一个原因</p><p>AdamW 使用了严谨的 weight decay（非L2正则），即权重衰减不参与一、二动量计算，只在最后的更新公式中使用。其更新公式如下：</p><script type="math/tex; mode=display">\begin{aligned}m_t=\beta_1\cdot m_{t-1}+(1-\beta_1)\cdot g_t\\v_t=\beta_2\cdot v_{t-1}+(1-\beta_2)\cdot g_t^2\\\hat m_t=m_t/(1-\beta_1^t)\\\hat v_t=v_t/(1-\beta_2^t)\\\theta_t=\theta_{t-1}-\alpha\cdot(\frac{\hat m_t}{\sqrt{\hat v_t}+\epsilon}+\lambda\cdot\theta_{t-1})\end{aligned}</script>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本控制与git(3)</title>
      <link href="/2025/02/25/23a4a0e0.html"/>
      <url>/2025/02/25/23a4a0e0.html</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="https://git-scm.com/book/zh/v2/Git-%e5%88%86%e6%94%af-%e5%88%86%e6%94%af%e7%ae%80%e4%bb%8b。">https://git-scm.com/book/zh/v2/Git-%e5%88%86%e6%94%af-%e5%88%86%e6%94%af%e7%ae%80%e4%bb%8b。</a></p><h2 id="git分支简介"><a href="#git分支简介" class="headerlink" title="git分支简介"></a>git分支简介</h2><p> Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 <strong>快照</strong> 。</p><p>在进行提交操作时，Git 会保存一个提交对象（commit object）。 知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象。</p><p>假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和，然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 <em>blob</em> 对象来保存它们【<code>Blob</code>（Binary Large Object）对象用于表示不可变的、原始数据的类文件对象。它可以存储二进制数据，通常用于处理文件或大块数据。】），最终将校验和加入到暂存区域等待提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> README test.rb LICENSE$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">'The initial commit of my project'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。</p><p>现在，Git 仓库中有五个对象：三个 <em>blob</em> 对象（保存着文件快照）、一个 <strong>树</strong> 对象 （记录着目录结构和 blob 对象索引）以及一个 <strong>提交</strong> 对象（包含着指向前述树对象的指针和所有提交信息）。</p><p><img src="/pics/版本控制与git/commit-and-tree.png" alt=""></p><p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p><p><img src="/pics/版本控制与git/commits-and-parents.png" alt=""></p><p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 <code>master</code> 分支会在每次提交时自动向前移动。（Git 的 <code>master</code> 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 <code>git init</code> 命令默认创建它，并且大多数人都懒得去改动它。）</p><p><img src="/pics/版本控制与git/branch-and-history.png" alt=""></p><h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><p>它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 <code>git branch</code> 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch testing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会在当前所在的提交对象上创建一个指针。</p><p><img src="/pics/版本控制与git/head-to-master.png.png" alt=""></p><p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 <strong>创建</strong> 一个新分支，并不会自动切换到新分支中去。</p><p>你可以简单地使用 <code>git log</code> 命令查看各个分支当前所指的对象。 提供这一功能的参数是 <code>--decorate</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--oneline</span> <span class="token parameter variable">--decorate</span>f30ab <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master, testing<span class="token punctuation">)</span> <span class="token function">add</span> feature <span class="token comment">#32 - ability to add new formats to the central interface</span>34ac2 Fixed bug <span class="token comment">#1328 - stack overflow under certain conditions</span>98ca9 The initial commit of my project<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout testing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。</p><p>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vim</span> test.rb %修改该文件中的内容$ <span class="token function">git</span> commit <span class="token parameter variable">-a</span> <span class="token parameter variable">-m</span> <span class="token string">'made a change'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/pics/版本控制与git/advance-testing.png" alt=""></p><p>如图所示，你的 <code>testing</code> 分支向前移动了，但是 <code>master</code> 分支却没有，它仍然指向运行 <code>git checkout</code> 时所指的对象。 这就有意思了，现在我们切换回 <code>master</code> 分支看看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令做了两件事。 一是使 HEAD 指回 <code>master</code> 分支，二是将工作目录恢复成 <code>master</code> 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。本质上来讲，这就是忽略 <code>testing</code> 分支所做的修改，以便于向另一个方向进行开发。</p><p><strong>分支切换会改变你工作目录中的文件。</strong>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p><p>不妨再稍微做些修改并提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vim</span> test.rb$ <span class="token function">git</span> commit <span class="token parameter variable">-a</span> <span class="token parameter variable">-m</span> <span class="token string">'made other changes'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，这个项目的提交历史已经产生了分叉。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，<strong>并在时机成熟时将它们合并起来</strong>。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p><p><img src="/pics/版本控制与git/advance-master.png" alt=""></p><p>你可以简单地使用 <code>git log</code> 命令查看分叉历史。 运行 <code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--oneline</span> <span class="token parameter variable">--decorate</span> <span class="token parameter variable">--graph</span> <span class="token parameter variable">--all</span>* c2b9e <span class="token punctuation">(</span>HEAD, master<span class="token punctuation">)</span> made other changes<span class="token operator">|</span> * 87ab2 <span class="token punctuation">(</span>testing<span class="token punctuation">)</span> made a change<span class="token operator">|</span>/* f30ab <span class="token function">add</span> feature <span class="token comment">#32 - ability to add new formats to the</span>* 34ac2 fixed bug <span class="token comment">#1328 - stack overflow under certain conditions</span>* 98ca9 initial commit of my project<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？</p><p>这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。</p><p>创建新分支的同时切换过去：通常我们会在创建一个新分支后立即切换过去，这可以用 <code>git checkout -b &lt;newbranchname&gt;</code> 一条命令搞定。</p><h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p><ol><li>开发某个网站。</li><li>为实现某个新的用户需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p><ol><li>切换到你的线上分支（production branch）。</li><li>为这个紧急任务新建一个分支，并在其中修复它。</li><li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li><li>切换回你最初工作的分支上，继续工作。</li></ol><h3 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h3><p>假设你正在你的项目上工作，并且在 <code>master</code> 分支上已经有了一些提交。</p><p><img src="/pics/版本控制与git/basic-branching-1.png" alt=""></p><p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> iss53Switched to a new branch <span class="token string">"iss53"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>它是下面两条命令的简写：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch iss53$ <span class="token function">git</span> checkout iss53<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/pics/版本控制与git/basic-branching-2.png" alt=""></p><p>你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经检出到该分支 （也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p><p><img src="/pics/版本控制与git/basic-branching-3.png" alt=""></p><p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 <code>iss53</code> 的修改混在一起， 你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 <code>master</code> 分支。</p><p>但是，<strong>在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改， 它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。</strong> 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，贮藏（stashing） 和 修补提交（commit amending））。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 <code>master</code> 分支了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout masterSwitched to branch <span class="token string">'master'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：<strong>当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。</strong> Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p><p>接下来，你要修复这个紧急问题。 我们来建立一个 <code>hotfix</code> 分支，在该分支上工作直到问题解决：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> hotfixSwitched to a new branch <span class="token string">'hotfix'</span>$ <span class="token function">vim</span> index.html$ <span class="token function">git</span> commit <span class="token parameter variable">-a</span> <span class="token parameter variable">-m</span> <span class="token string">'fixed the broken email address'</span><span class="token punctuation">[</span>hotfix 1fb7853<span class="token punctuation">]</span> fixed the broken email address <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">2</span> insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/pics/版本控制与git/basic-branching-4.png" alt=""></p><p>你可以运行你的测试，确保你的修改是正确的，然后将 <code>hotfix</code> 分支合并回你的 <code>master</code> 分支来部署到线上。 你可以使用 <code>git merge</code> 命令来达到上述目的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout master$ <span class="token function">git</span> merge hotfixUpdating f42c576<span class="token punctuation">..</span>3a0874cFast-forward index.html <span class="token operator">|</span> <span class="token number">2</span> ++ <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">2</span> insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在合并的时候，你应该注意到了“快进（fast-forward）”这个词。 由于你想要合并的分支 <code>hotfix</code> 所指向的提交 <code>C4</code> 是你所在的提交 <code>C2</code> 的直接后继， 因此 Git 会直接将指针向前移动。换句话说，当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><p>现在，最新的修改已经在 <code>master</code> 分支所指向的提交快照中，你可以着手发布该修复了。</p><p><img src="/pics/版本控制与git/basic-branching-5.png" alt=""></p><p>关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 <code>hotfix</code> 分支，因为你已经不再需要它了 —— <code>master</code> 分支已经指向了同一个位置。 你可以使用带 <code>-d</code> 选项的 <code>git branch</code> 命令来删除分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-d</span> hotfixDeleted branch hotfix <span class="token punctuation">(</span>3a0874c<span class="token punctuation">)</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout iss53Switched to branch <span class="token string">"iss53"</span>$ <span class="token function">vim</span> index.html$ <span class="token function">git</span> commit <span class="token parameter variable">-a</span> <span class="token parameter variable">-m</span> <span class="token string">'finished the new footer [issue 53]'</span><span class="token punctuation">[</span>iss53 ad82d7a<span class="token punctuation">]</span> finished the new footer <span class="token punctuation">[</span>issue <span class="token number">53</span><span class="token punctuation">]</span><span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你在 <code>hotfix</code> 分支上所做的工作并没有包含到 <code>iss53</code> 分支中。 如果你需要拉取 <code>hotfix</code> 所做的修改，你可以使用 <code>git merge master</code> 命令将 <code>master</code> 分支合并入 <code>iss53</code> 分支，或者你也可以等到 <code>iss53</code> 分支完成其使命，再将其合并回 <code>master</code> 分支。</p><h3 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h3><p>假设你已经修正了 #53 问题，并且打算将你的工作合并入 <code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到 <code>master</code> 分支，这和之前你合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout masterSwitched to branch <span class="token string">'master'</span>$ <span class="token function">git</span> merge iss53Merge made by the <span class="token string">'recursive'</span> strategy.index.html <span class="token operator">|</span>    <span class="token number">1</span> +<span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这和你之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，<code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的公共祖先（<code>C2</code>），做一个简单的三方合并。</p><p><img src="/pics/版本控制与git/basic-merging-1.png" alt=""></p><p>和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p><p><img src="/pics/版本控制与git/basic-merging-2.png" alt=""></p><p>既然你的修改已经合并进来了，就不再需要 <code>iss53</code> 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-d</span> iss53<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 <code>hotfix</code> 分支的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> merge iss53Auto-merging index.htmlCONFLICT <span class="token punctuation">(</span>content<span class="token punctuation">)</span>: Merge conflict <span class="token keyword">in</span> index.htmlAutomatic merge failed<span class="token punctuation">;</span> fix conflicts and <span class="token keyword">then</span> commit the result.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。</strong> 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYou have unmerged paths.  <span class="token punctuation">(</span>fix conflicts and run <span class="token string">"git commit"</span><span class="token punctuation">)</span>Unmerged paths:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to mark resolution<span class="token punctuation">)</span>    both modified:      index.htmlno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>contact : email.support@github.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>=======<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> please contact us at support@github.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code> 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>iss53</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>please contact us at email.support@github.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述的冲突解决方案仅保留了其中一个分支的修改，并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p><p>如果你想使用图形化工具来解决冲突，你可以运行 <code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> mergetoolThis message is displayed because <span class="token string">'merge.tool'</span> is not configured.See <span class="token string">'git mergetool --tool-help'</span> or <span class="token string">'git help config'</span> <span class="token keyword">for</span> <span class="token function">more</span> details.<span class="token string">'git mergetool'</span> will now attempt to use one of the following tools:opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emergeMerging:index.htmlNormal merge conflict <span class="token keyword">for</span> <span class="token string">'index.html'</span><span class="token builtin class-name">:</span>  <span class="token punctuation">{</span>local<span class="token punctuation">}</span>: modified <span class="token function">file</span>  <span class="token punctuation">{</span>remote<span class="token punctuation">}</span>: modified <span class="token function">file</span>Hit <span class="token builtin class-name">return</span> to start merge resolution tool <span class="token punctuation">(</span>opendiff<span class="token punctuation">)</span>:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你想使用除默认工具外的其他合并工具，你可以在 “下列工具中（one of the following tools）” 这句后面看到所有支持的合并工具。 然后输入你喜欢的工具名字就可以了。</p><p>等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterAll conflicts fixed but you are still merging.  <span class="token punctuation">(</span>use <span class="token string">"git commit"</span> to conclude merge<span class="token punctuation">)</span>Changes to be committed:    modified:   index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你对结果感到满意，并且确定之前有冲突的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Merge branch <span class="token string">'iss53'</span>Conflicts:    index.html<span class="token comment">#</span><span class="token comment"># It looks like you may be committing a merge.</span><span class="token comment"># If this is not correct, please remove the file</span><span class="token comment">#.git/MERGE_HEAD</span><span class="token comment"># and try again.</span><span class="token comment"># Please enter the commit message for your changes. Lines starting</span><span class="token comment"># with '#' will be ignored, and an empty message aborts the commit.</span><span class="token comment"># On branch master</span><span class="token comment"># All conflicts fixed but you are still merging.</span><span class="token comment">#</span><span class="token comment"># Changes to be committed:</span><span class="token comment">#modified:   index.html</span><span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息， 添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p><p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch  iss53* master  testing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意 <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）。 这意味着如果在这时候提交，<code>master</code> 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-v</span>  iss53   93b412c fix javascript issue* master  7a98805 Merge branch <span class="token string">'iss53'</span>  testing 782fd34 <span class="token function">add</span> scott to the author list <span class="token keyword">in</span> the readmes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>--merged</code> 与 <code>--no-merged</code> 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">--merged</span>  iss53* master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>因为之前已经合并了 <code>iss53</code> 分支，所以现在看到它在列表中。 <strong>在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</strong></p><p>查看所有包含未合并工作的分支，可以运行 <code>git branch --no-merged</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch --no-merged  testing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 <code>git branch -d</code> 命令删除它时会失败：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-d</span> testingerror: The branch <span class="token string">'testing'</span> is not fully merged.If you are sure you want to delete it, run <span class="token string">'git branch -D testing'</span><span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 <code>-D</code> 选项强制删除它。</p><p>上面描述的选项 <code>--merged</code> 和 <code>--no-merged</code> 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到 <strong>当前</strong> 分支的分支。</p><p>你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。 例如，尚未合并到 <code>master</code> 分支的有哪些？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout testing$ <span class="token function">git</span> branch --no-merged master  topicA  featureB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h2><p>本节会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷， 才衍生出这些典型的工作模式，你可以根据项目实际情况选择一种用用看。</p><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。</p><p>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 <code>master</code> 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 <code>develop</code> 或者 <code>next</code> 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 <code>master</code> 分支了。 这样，在确保这些已完成的主题分支（短期分支，比如之前的 <code>iss53</code> 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。</p><p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p><p><img src="/pics/版本控制与git/lr-branches-1.png" alt=""></p><p>通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p><p><img src="/pics/版本控制与git/lr-branches-2.png" alt=""></p><p>你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 <code>proposed</code>（建议） 或 <code>pu: proposed updates</code>（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 <code>next</code> 或者 <code>master</code> 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</p><h3 id="主题分支"><a href="#主题分支" class="headerlink" title="主题分支"></a>主题分支</h3><p>主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。 也许你从来没有在其他的版本控制系统（<code>VCS</code>）上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。 然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见。</p><p>你已经在上一节中你创建的 <code>iss53</code> 和 <code>hotfix</code> 主题分支中看到过这种用法。 你在上一节用到的主题分支（<code>iss53</code> 和 <code>hotfix</code> 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p><p>考虑这样一个例子，你在 <code>master</code> 分支上工作到 <code>C1</code>，这时为了解决一个问题而新建 <code>iss91</code> 分支，在 <code>iss91</code> 分支上工作到 <code>C4</code>，然而对于那个问题你又有了新的想法，于是你再新建一个 <code>iss91v2</code> 分支试图用另一种方法解决那个问题，接着你回到 <code>master</code> 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 <code>C10</code> 的时候新建一个 <code>dumbidea</code> 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：</p><p><img src="/pics/版本控制与git/topic-branches-1.png" alt=""></p><p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 <code>iss91v2</code> 分支中方案。 另外，你将 <code>dumbidea</code> 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 <code>iss91</code> 分支（即丢弃 <code>C5</code> 和 <code>C6</code> 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：</p><p><img src="/pics/版本控制与git/topic-branches-2.png" alt=""></p><p>请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。</p><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 <code>git ls-remote &lt;remote&gt;</code> 来显式地获得远程引用的完整列表， 或者通过 <code>git remote show &lt;remote&gt;</code> 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。</p><p>远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。</p><p>它们以 <code>&lt;remote&gt;/&lt;branch&gt;</code> 的形式命名。 例如，如果你想要看你最后一次与远程仓库 <code>origin</code> 通信时 <code>master</code> 分支的状态，你可以查看 <code>origin/master</code> 分支。 你与同事合作解决一个问题并且他们推送了一个 <code>iss53</code> 分支，你可能有自己的本地 <code>iss53</code> 分支， 然而在服务器上的分支会以 <code>origin/iss53</code> 来表示。</p><p>这可能有一点儿难以理解，来看一个例子。 假设你的网络里有一个在 <code>git.ourcompany.com</code> 的 Git 服务器。 如果你从这里克隆，Git 的 <code>clone</code> 命令会为你自动将其命名为 <code>origin</code>，拉取它的所有数据， 创建一个指向它的 <code>master</code> 分支的指针，并且在本地将其命名为 <code>origin/master</code>。 Git 也会给你一个与 origin 的 <code>master</code> 分支在指向同一个地方的本地 <code>master</code> 分支，这样你就有工作的基础。</p><p>（远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 <code>git init</code> 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 <code>git clone</code> 时默认的远程仓库名字。 如果你运行 <code>git clone -o booyah</code>，那么你默认的远程分支名字将会是 <code>booyah/master</code>。）</p><p><img src="/pics/版本控制与git/remote-branches-1.png" alt=""></p><p>如果你在本地的 <code>master</code> 分支做了一些工作，在同一段时间内有其他人推送提交到 <code>git.ourcompany.com</code> 并且更新了它的 <code>master</code> 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 <code>origin</code> 服务器连接（并拉取数据），你的 <code>origin/master</code> 指针就不会移动。</p><p><img src="/pics/版本控制与git/remote-branches-2.png" alt=""></p><p>如果要与给定的远程仓库同步数据，运行 <code>git fetch &lt;remote&gt;</code> 命令（在本例中为 <code>git fetch origin</code>）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>）， 从中抓取本地没有的数据，并且更新本地数据库，移动 <code>origin/master</code> 指针到更新之后的位置。</p><p>如果要与给定的远程仓库同步数据，运行 <code>git fetch &lt;remote&gt;</code> 命令（在本例中为 <code>git fetch origin</code>）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>）， 从中抓取本地没有的数据，并且更新本地数据库，移动 <code>origin/master</code> 指针到更新之后的位置。</p><p><img src="/pics/版本控制与git/remote-branches-3.png" alt=""></p><p>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 <code>git.team1.ourcompany.com</code>。 你可以运行 <code>git remote add</code> 命令添加一个新的远程仓库引用到当前的项目。 将这个远程仓库命名为 <code>teamone</code>，将其作为完整 URL 的缩写。</p><p><img src="/pics/版本控制与git/remote-branches-4.png" alt=""></p><p>现在，可以运行 <code>git fetch teamone</code> 来抓取远程仓库 <code>teamone</code> 有而本地没有的数据。 因为那台服务器上现有的数据是 <code>origin</code> 服务器上的一个子集， 所以 Git 并不会抓取数据而是会设置远程跟踪分支 <code>teamone/master</code> 指向 <code>teamone</code> 的 <code>master</code> 分支。</p><p><img src="/pics/版本控制与git/remote-branches-5.png" alt=""></p><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p><p>如果希望和别人一起在名为 <code>serverfix</code> 的分支上工作，你可以像推送第一个分支那样推送它。 运行 <code>git push &lt;remote&gt; &lt;branch&gt;</code>:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin serverfixCounting objects: <span class="token number">24</span>, done.Delta compression using up to <span class="token number">8</span> threads.Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">15</span>/15<span class="token punctuation">)</span>, done.Writing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">24</span>/24<span class="token punctuation">)</span>, <span class="token number">1.91</span> KiB <span class="token operator">|</span> <span class="token number">0</span> bytes/s, done.Total <span class="token number">24</span> <span class="token punctuation">(</span>delta <span class="token number">2</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>To https://github.com/schacon/simplegit * <span class="token punctuation">[</span>new branch<span class="token punctuation">]</span>      serverfix -<span class="token operator">&gt;</span> serverfix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有些工作被简化了。 Git 自动将 <code>serverfix</code> 分支名字展开为 <code>refs/heads/serverfix:refs/heads/serverfix</code>， 那意味着，“推送本地的 <code>serverfix</code> 分支来更新远程仓库上的 <code>serverfix</code> 分支。” 你也可以运行 <code>git push origin serverfix:serverfix</code>， 它会做同样的事——也就是说“推送本地的 <code>serverfix</code> 分支，将其作为远程仓库的 <code>serverfix</code> 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 <code>serverfix</code>，可以运行 <code>git push origin serverfix:awesomebranch</code> 来将本地的 <code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code> 分支。</p><p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 <code>origin/serverfix</code>，指向服务器的 <code>serverfix</code> 分支的引用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch originremote: Counting objects: <span class="token number">7</span>, done.remote: Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">2</span>/2<span class="token punctuation">)</span>, done.remote: Total <span class="token number">3</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, reused <span class="token number">3</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>Unpacking objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">3</span>/3<span class="token punctuation">)</span>, done.From https://github.com/schacon/simplegit * <span class="token punctuation">[</span>new branch<span class="token punctuation">]</span>      serverfix    -<span class="token operator">&gt;</span> origin/serverfix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 <code>serverfix</code> 分支——只有一个不可以修改的 <code>origin/serverfix</code> 指针。</p><p>可以运行 <code>git merge origin/serverfix</code> 将这些工作合并到当前所在的分支。 如果想要在自己的 <code>serverfix</code> 分支上工作，可以将其建立在远程跟踪分支之上：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> serverfix origin/serverfixBranch serverfix <span class="token builtin class-name">set</span> up to track remote branch serverfix from origin.Switched to a new branch <span class="token string">'serverfix'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这会给你一个用于工作的本地分支，并且起点位于 <code>origin/serverfix</code>。</p><h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><p>当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 <code>master</code> 分支。 最简单的实例就是像之前看到的那样，运行 <code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>。 这是一个十分常用的操作所以 Git 提供了 <code>--track</code> 快捷方式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout <span class="token parameter variable">--track</span> origin/serverfixBranch serverfix <span class="token builtin class-name">set</span> up to track remote branch serverfix from origin.Switched to a new branch <span class="token string">'serverfix'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout serverfixBranch serverfix <span class="token builtin class-name">set</span> up to track remote branch serverfix from origin.Switched to a new branch <span class="token string">'serverfix'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> sf origin/serverfixBranch sf <span class="token builtin class-name">set</span> up to track remote branch serverfix from origin.Switched to a new branch <span class="token string">'sf'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在，本地分支 <code>sf</code> 会自动从 <code>origin/serverfix</code> 拉取。</p><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-u</span> origin/serverfixBranch serverfix <span class="token builtin class-name">set</span> up to track remote branch serverfix from origin.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当设置好跟踪分支后，可以通过简写 <code>@{upstream}</code> 或 <code>@{u}</code> 来引用它的上游分支。 所以在 <code>master</code> 分支时并且它正在跟踪 <code>origin/master</code> 时，如果愿意的话可以使用 <code>git merge @{u}</code> 来取代 <code>git merge origin/master</code>。</p><p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-vv</span>  iss53     7e424c3 <span class="token punctuation">[</span>origin/iss53: ahead <span class="token number">2</span><span class="token punctuation">]</span> forgot the brackets  master    1ae2a45 <span class="token punctuation">[</span>origin/master<span class="token punctuation">]</span> deploying index fix* serverfix f8674d9 <span class="token punctuation">[</span>teamone/server-fix-good: ahead <span class="token number">3</span>, behind <span class="token number">1</span><span class="token punctuation">]</span> this should <span class="token keyword">do</span> it  testing   5ea463a trying something new<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以看到 <code>iss53</code> 分支正在跟踪 <code>origin/iss53</code> 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 <code>master</code> 分支正在跟踪 <code>origin/master</code> 分支并且是最新的。 接下来可以看到 <code>serverfix</code> 分支正在跟踪 <code>teamone</code> 服务器上的 <code>server-fix-good</code> 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 <code>testing</code> 分支并没有跟踪任何远程分支。</p><p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch --all<span class="token punctuation">;</span> <span class="token function">git</span> branch <span class="token parameter variable">-vv</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 <code>git pull</code> 在大多数情况下它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 <code>clone</code> 或 <code>checkout</code> 命令为你创建的，<code>git pull</code> 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。</p><p>由于 <code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用 <code>fetch</code> 与 <code>merge</code> 命令会更好一些。</p><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 <code>master</code> 分支（或任何其他稳定代码分支）。 可以运行带有 <code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。 如果想要从服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin <span class="token parameter variable">--delete</span> serverfixTo https://github.com/schacon/simplegit - <span class="token punctuation">[</span>deleted<span class="token punctuation">]</span>         serverfix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p><h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p><h3 id="变基的基本操作"><a href="#变基的基本操作" class="headerlink" title="变基的基本操作"></a>变基的基本操作</h3><p>对于如下的例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p><p><img src="/pics/版本控制与git/basic-rebase-1.png" alt=""></p><p>之前介绍过，整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的最新快照（<code>C3</code> 和 <code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p><p><img src="/pics/版本控制与git/basic-rebase-2.png" alt=""></p><p>其实，还有一种方法：你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上应用一次。 在 Git 中，这种操作就叫做 <strong>变基（rebase）</strong>。 你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p><p>在这个例子中，你可以检出 <code>experiment</code> 分支，然后将它变基到 <code>master</code> 分支上：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout experiment$ <span class="token function">git</span> rebase masterFirst, rewinding <span class="token function">head</span> to replay your work on <span class="token function">top</span> of it<span class="token punctuation">..</span>.Applying: added staged <span class="token builtin class-name">command</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>） 的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）</p><p><img src="/pics/版本控制与git/basic-rebase-3.png" alt=""></p><p>现在回到 <code>master</code> 分支，进行一次快进合并。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout master$ <span class="token function">git</span> merge experiment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/pics/版本控制与git/basic-rebase-4.png" alt=""></p><p>此时，<code>C4'</code> 指向的快照就前图中 <code>C5</code> 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p><p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p><p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p><h3 id="更有趣的变基例子"><a href="#更有趣的变基例子" class="headerlink" title="更有趣的变基例子"></a>更有趣的变基例子</h3><p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。  你创建了一个主题分支 <code>server</code>，为服务端添加了一些功能，提交了 <code>C3</code> 和 <code>C4</code>。 然后从 <code>C3</code> 上创建了主题分支 <code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和 <code>C9</code>。 最后，你回到 <code>server</code> 分支，又提交了 <code>C10</code>。</p><p><img src="/pics/版本控制与git/interesting-rebase-1.png" alt=""></p><p>假设你希望将 <code>client</code> 中的修改合并到主分支并发布，但暂时并不想合并 <code>server</code> 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 <code>git rebase</code> 命令的 <code>--onto</code> 选项， 选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重放：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> rebase <span class="token parameter variable">--onto</span> master server client<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上命令的意思是：“取出 <code>client</code> 分支，找出它从 <code>server</code> 分支分歧之后的补丁， 然后把这些补丁在 <code>master</code> 分支上重放一遍，让 <code>client</code> 看起来像直接基于 <code>master</code> 修改一样”。这理解起来有一点复杂，不过效果非常酷。</p><p><img src="/pics/版本控制与git/interesting-rebase-2.png" alt=""></p><p>现在可以快进合并 <code>master</code> 分支了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout master$ <span class="token function">git</span> merge client<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/pics/版本控制与git/interesting-rebase-3.png" alt=""></p><p>接下来你决定将 <code>server</code> 分支中的修改也整合进来。 使用 <code>git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</code> 命令可以直接将主题分支 （即本例中的 <code>server</code>）变基到目标分支（即 <code>master</code>）上。 这样做能省去你先切换到 <code>server</code> 分支，再对其执行变基命令的多个步骤。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> rebase master server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图所示，<code>server</code> 中的代码被“续”到了 <code>master</code> 后面。</p><p><img src="/pics/版本控制与git/interesting-rebase-4.png" alt=""></p><p>然后就可以快进合并主分支 <code>master</code> 了：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git checkout master$ git merge server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>至此，<code>client</code> 和 <code>server</code> 分支中的修改都已经整合到主分支里了， 你可以删除这两个分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-d</span> client$ <span class="token function">git</span> branch <span class="token parameter variable">-d</span> server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最终提交历史会变成下图的样子：</p><p><img src="/pics/版本控制与git/interesting-rebase-5.png" alt=""></p><h3 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h3><p>奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p><p><strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</strong></p><p>如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p><p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p><p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：</p><p><img src="/pics/版本控制与git/perils-of-rebasing-1.png" alt=""></p><p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p><p><img src="/pics/版本控制与git/perils-of-rebasing-2.png" alt=""></p><p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用 <code>git push --force</code> 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。</p><p><img src="/pics/版本控制与git/perils-of-rebasing-3.png" alt=""></p><p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code> 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p><p><img src="/pics/版本控制与git/perils-of-rebasing-4.png" alt=""></p><p>此时如果你执行 <code>git log</code> 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 <code>C4</code> 和 <code>C6</code>，因为之前就是他把这两个提交通过变基丢弃的。</p><h3 id="用变基解决变基"><a href="#用变基解决变基" class="headerlink" title="用变基解决变基"></a>用变基解决变基</h3><p>如果你 <strong>真的</strong> 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p><p>实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。</p><p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p><p>举个例子，如果遇到前面提到的“有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交”那种情境，如果我们不是执行合并，而是执行 <code>git rebase teamone/master</code>, Git 将会：</p><ul><li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li><li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li><li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</li><li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li></ul><p>从而我们将得到与“你将相同的内容又合并了一次，生成了一个新的提交”中不同的结果，如下图所示。</p><p><img src="/pics/版本控制与git/perils-of-rebasing-5.png" alt=""></p><p>要想上述方案有效，还需要对方在变基时确保 <code>C4'</code> 和 <code>C4</code> 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 <code>C4</code> 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p><p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code> 命令而不是直接 <code>git pull</code>。 又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p><p>如果你习惯使用 <code>git pull</code> ，同时又希望默认使用选项 <code>--rebase</code>，你可以执行这条语句 <code>git config --global pull.rebase true</code> 来更改 <code>pull.rebase</code> 的默认配置。</p><p>如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。</p><p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 <code>git pull --rebase</code> 命令，这样尽管不能避免伤痛，但能有所缓解。</p><h3 id="变基与合并"><a href="#变基与合并" class="headerlink" title="变基与合并"></a>变基与合并</h3><p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p><p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 <em>谎言</em> 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p><p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的事</strong>。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 <code>rebase</code> 及 <code>filter-branch</code> 等工具来编写故事，怎么方便后来的读者就怎么写。</p><p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p><p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本控制与git(2)</title>
      <link href="/2025/02/23/3abf91a1.html"/>
      <url>/2025/02/23/3abf91a1.html</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="https://git-scm.com/book/zh/v2/Git-%e5%9f%ba%e7%a1%80-%e8%8e%b7%e5%8f%96-Git-%e4%bb%93%e5%ba%93。">https://git-scm.com/book/zh/v2/Git-%e5%9f%ba%e7%a1%80-%e8%8e%b7%e5%8f%96-Git-%e4%bb%93%e5%ba%93。</a></p><h2 id="获取git仓库"><a href="#获取git仓库" class="headerlink" title="获取git仓库"></a>获取git仓库</h2><p>有两种获取 Git 项目仓库的方式：</p><ol><li>将尚未进行版本控制的本地目录转换为 Git 仓库；</li><li>从其它服务器 <strong>克隆</strong> 一个已存在的 Git 仓库。</li></ol><h3 id="在已存在目录中初始化仓库"><a href="#在已存在目录中初始化仓库" class="headerlink" title="在已存在目录中初始化仓库"></a>在已存在目录中初始化仓库</h3><p>进入希望转化为git仓库的工作目录，执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。但是这只是一个简单的初始化，项目中的文件还没有被跟踪。</p><p>如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 <code>git add</code> 命令来指定所需的文件来进行追踪，然后执行 <code>git commit</code> ：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> *.c %将所有的扩展名为.c的文件添加到暂存区$ <span class="token function">git</span> <span class="token function">add</span> LICENSE $ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">'initial project version'</span> %进行第一次文件提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="克隆现有仓库"><a href="#克隆现有仓库" class="headerlink" title="克隆现有仓库"></a>克隆现有仓库</h3><p>如果希望参与到某一个开源项目中去，一般就需要获得已经存在的git仓库的拷贝，这时就要用到 <code>git clone</code> 命令。</p><p>Git克隆的是该Git仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。当你执行 <code>git clone</code> 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库。</p><p>克隆仓库的命令是 <code>git clone &lt;url&gt;</code>，比如</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/holimario/holimario.github.io.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就会创建一个和该git仓库相同名称的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹， 从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。</p><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/holimario/holimario.github.io.git mydir<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Git 支持多种数据传输协议。 上面的例子使用的是 <code>https://</code> 协议，不过你也可以使用 <code>git://</code> 协议或者使用 SSH 传输协议，比如 <code>user@server:path/to/repo.git</code> 。</p><h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>现在我们的机器上有了一个 <strong>真实项目</strong> 的 Git 仓库，并从这个仓库中检出了所有文件的 <strong>工作副本</strong>。 通常，你会对这些文件做些修改，每当完成了一个阶段的目标，想要将记录下它时，就将它提交到仓库。</p><p>工作目录下的文件都只有两个状态：<strong>已跟踪</strong>或<strong>未跟踪</strong>。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。</p><p>工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。</p><p><img src="/pics/版本控制与git/lifecycle.png" alt=""></p><h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>可以用 <code>git status</code> 命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>nothing to commit, working directory clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这说明你现在的工作目录很干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。</p><p>现在，让我们在项目下创建一个新的 <code>README</code> 文件。 如果之前并不存在这个文件，使用 <code>git status</code> 命令，你将看到一个新的未跟踪文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">'My Project'</span> <span class="token operator">&gt;</span> README$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Untracked files:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to include <span class="token keyword">in</span> what will be committed<span class="token punctuation">)</span>    READMEnothing added to commit but untracked files present <span class="token punctuation">(</span>use <span class="token string">"git add"</span> to track<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。</p><h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>使用命令 <code>git add</code> 开始跟踪一个文件。 所以，要跟踪 <code>README</code> 文件，运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> README<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时再运行 <code>git status</code> 命令，会看到 <code>README</code> 文件已被跟踪，并处于暂存状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git restore --staged &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    new file:   README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要在 <code>Changes to be committed</code> 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件在你运行 <code>git add</code> 时的版本将被留存在后续的历史记录中。<code>git add</code> 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p><h3 id="暂存已修改的文件"><a href="#暂存已修改的文件" class="headerlink" title="暂存已修改的文件"></a>暂存已修改的文件</h3><p> 如果你修改了一个名为 <code>CONTRIBUTING.md</code> 的已被跟踪的文件，然后运行 <code>git status</code> 命令，会看到下面内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    new file:   READMEChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件 <code>CONTRIBUTING.md</code> 出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行 <code>git add</code> 将“CONTRIBUTING.md”放到暂存区，然后再看看 <code>git status</code> 的输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> CONTRIBUTING.md$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    new file:   README    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 <code>CONTRIBUTING.md</code> 里再加条注释。 重新编辑存盘后，准备好提交。 不过且慢，再运行 <code>git status</code> 看看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vim</span> CONTRIBUTING.md$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    new file:   README    modified:   CONTRIBUTING.mdChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时<code>CONTRIBUTING.md</code> 文件同时出现在暂存区和非暂存区。实际上 Git 只不过暂存了你运行 <code>git add</code> 命令时的版本。 如果你现在提交，<code>CONTRIBUTING.md</code> 的版本是你最后一次运行 <code>git add</code> 命令时的那个版本，而不是你运行 <code>git commit</code> 时，在工作目录中的当前版本。所以，运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行 <code>git add</code> 把最新版本重新暂存起来：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> CONTRIBUTING.md$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    new file:   README    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种格式更为紧凑的输出。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> status <span class="token parameter variable">-s</span> M READMEMM RakefileA  lib/git.rbM  lib/simplegit.rb?? LICENSE.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示： <code>README</code> 文件在工作区已修改但尚未暂存，而 <code>lib/simplegit.rb</code> 文件已修改且已暂存。 <code>Rakefile</code> 文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件的模式。 来看一个实际的 <code>.gitignore</code> 例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> .gitignore*.<span class="token punctuation">[</span>oa<span class="token punctuation">]</span>*~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件。</p><p>文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反。</li></ul><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号（<code>**</code>）表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> 、 <code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p><p>如下是一个<code>.gitignore</code> 文件的例子：</p><pre class="line-numbers language-none"><code class="language-none"># 忽略所有的 .a 文件*.a# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件!lib.a# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO/TODO# 忽略任何目录下名为 build 的文件夹build/# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件doc/**/*.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>GitHub 有一个十分详细的针对数十种项目及语言的 <code>.gitignore</code> 文件列表：<a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 。</p><p>在最简单的情况下，一个仓库可能只根目录下有一个 <code>.gitignore</code> 文件，它递归地应用到整个仓库中。 然而，子目录下也可以有额外的 <code>.gitignore</code> 文件。子目录中的 <code>.gitignore</code> 文件中的规则只作用于它所在的目录中。</p><h3 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h3><p>想知道具体修改了什么地方，可以用 <code>git diff</code> 命令。通常可能会用它来回答这两个问题：当前做的哪些更新尚未暂存？ 有哪些更新已暂存并准备好下次提交？虽然 <code>git status</code> 已经通过在相应栏下列出文件名的方式回答了这个问题，但 <code>git diff</code> 能通过文件补丁的格式更加具体地显示哪些行发生了改变。</p><p>假如再次修改 README 文件后暂存，然后编辑 <code>CONTRIBUTING.md</code> 文件后先不暂存， 运行 <code>status</code> 命令将会看到：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    modified:   READMEChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">diff</span><span class="token function">diff</span> <span class="token parameter variable">--git</span> a/CONTRIBUTING.md b/CONTRIBUTING.mdindex 8ebb991<span class="token punctuation">..</span>643e24f <span class="token number">100644</span>--- a/CONTRIBUTING.md+++ b/CONTRIBUTING.md@@ -65,7 +65,8 @@ branch directly, things can get messy. Please include a <span class="token function">nice</span> description of your changes when you submit your PR<span class="token punctuation">;</span> <span class="token keyword">if</span> we have to <span class="token builtin class-name">read</span> the whole <span class="token function">diff</span> to figure out why you<span class="token string">'re contributing in the first place, you'</span>re <span class="token function">less</span> likely to get feedback and have your change<span class="token parameter variable">-merged</span> in.+merged in. Also, <span class="token function">split</span> your changes into comprehensive chunks <span class="token keyword">if</span> your patch is+longer than a dozen lines. If you are starting to work on a particular area, feel <span class="token function">free</span> to submit a PR that highlights your work <span class="token keyword">in</span> progress <span class="token punctuation">(</span>and note <span class="token keyword">in</span> the PR title that it's<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。</p><p>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --staged</code> （或者<code>git diff --cached</code>）命令。 这条命令将比对已暂存文件与最后一次提交的文件差异：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> <span class="token parameter variable">--staged</span><span class="token function">diff</span> <span class="token parameter variable">--git</span> a/README b/READMEnew <span class="token function">file</span> mode <span class="token number">100644</span>index 0000000<span class="token punctuation">..</span>03902a1--- /dev/null+++ b/README@@ -0,0 +1 @@+My Project<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，<code>git diff</code> 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 <code>git diff</code> 后却什么也没有，就是这个原因。</p><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>现在的暂存区已经准备就绪，可以提交了。此时需要确认是否还存在某些已修改或者已经新建的文件还没有进行<code>git add</code>，否则提交的时候不会记录这些尚未暂存的变化。 这些已修改但未暂存的文件只会保留在本地磁盘。 所以，每次准备提交前，先用 <code>git status</code> 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样会启动你选择的文本编辑器来输入提交说明。（启动的编辑器是通过 Shell 的环境变量 <code>EDITOR</code> 指定的）</p><p>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Please enter the commit message for your changes. Lines starting</span><span class="token comment"># with '#' will be ignored, and an empty message aborts the commit.</span><span class="token comment"># On branch master</span><span class="token comment"># Your branch is up-to-date with 'origin/master'.</span><span class="token comment">#</span><span class="token comment"># Changes to be committed:</span><span class="token comment">#new file:   README</span><span class="token comment">#modified:   CONTRIBUTING.md</span><span class="token comment">#</span>~~~<span class="token string">".git/COMMIT_EDITMSG"</span> 9L, 283C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一个空行，供你输入提交说明。退出编辑器时，Git 会丢弃注释行，用你输入的提交说明生成一次提交。</p><p>另外，你也可以在 <code>commit</code> 命令后添加 <code>-m</code> 选项，将提交信息与命令放在同一行，如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"Story 182: Fix benchmarks for speed"</span><span class="token punctuation">[</span>master 463dc4f<span class="token punctuation">]</span> Story <span class="token number">182</span>: Fix benchmarks <span class="token keyword">for</span> speed <span class="token number">2</span> files changed, <span class="token number">2</span> insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode <span class="token number">100644</span> README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，完成一次提交之后，输出信息告诉你是哪个分支提交的，本次提交的完整SHA-1校验和，以及本次提交中多少文件被修改，多少行添加和删改。</p><h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><p>暂存区可以比较精细地准备提交细节，但是有时会略显繁琐，因此git提供了一个可以跳过使用暂存区域的方式，只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，<strong>Git 就会自动把所有已经跟踪过的文件暂存起来一并提交</strong>，从而跳过 <code>git add</code> 步骤。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   CONTRIBUTING.mdno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span>$ <span class="token function">git</span> commit <span class="token parameter variable">-a</span> <span class="token parameter variable">-m</span> <span class="token string">'added new benchmarks'</span><span class="token punctuation">[</span>master 83e38c7<span class="token punctuation">]</span> added new benchmarks <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">5</span> insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">0</span> deletions<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <code>-a</code> 选项使本次提交包含了所有修改过的文件。 这很方便，但是要小心，有时这个选项会将不需要的文件添加到提交中。</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是 <em>未暂存清单</em>）看到：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> PROJECTS.md$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add/rm &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>        deleted:    PROJECTS.mdno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再运行 <code>git rm</code> 记录此次移除文件的操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> PROJECTS.md<span class="token function">rm</span> <span class="token string">'PROJECTS.md'</span>$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    deleted:    PROJECTS.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下一次提交时，该文件就不再纳入版本管理了。 如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删尚未添加到快照的数据，这样的数据不能被 Git 恢复。</p><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> <span class="token parameter variable">--cached</span> README<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。比如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> log/<span class="token punctuation">\</span>*.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code> 的所有文件。 类似的比如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> <span class="token punctuation">\</span>*~<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令会删除所有名字以 <code>~</code> 结尾的文件。</p><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。但是Git仍然可以推知发生了什么。</p><p> 要在 Git 中对文件改名，可以这么做：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">mv</span> file_from file_to<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">mv</span> README.md README$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    renamed:    README.md -<span class="token operator">&gt;</span> README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mv</span> README.md README<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。</p><p>当你在此项目中运行 <code>git log</code> 命令时，可以看到下面的输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> logcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Mon Mar <span class="token number">17</span> <span class="token number">21</span>:52:11 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    changed the version numbercommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Sat Mar <span class="token number">15</span> <span class="token number">16</span>:40:33 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    removed unnecessary <span class="token builtin class-name">test</span>commit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Sat Mar <span class="token number">15</span> <span class="token number">10</span>:31:28 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    first commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不传入任何参数的默认情况下，<code>git log</code> 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><p><code>git log</code> 有许多选项可以帮助你搜寻你所要找的提交。</p><p>其中一个比较有用的选项是 <code>-p</code> 或 <code>--patch</code> ，它会显示每次提交所引入的差异（按 <strong>补丁</strong> 的格式输出）。 你也可以限制显示的日志条目数量，例如使用 <code>-2</code> 选项来只显示最近的两次提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">-p</span> <span class="token parameter variable">-2</span>commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Mon Mar <span class="token number">17</span> <span class="token number">21</span>:52:11 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    changed the version number<span class="token function">diff</span> <span class="token parameter variable">--git</span> a/Rakefile b/Rakefileindex a874b73<span class="token punctuation">..</span>8f94139 <span class="token number">100644</span>--- a/Rakefile+++ b/Rakefile@@ -5,7 +5,7 @@ require <span class="token string">'rake/gempackagetask'</span> spec <span class="token operator">=</span> Gem::Specification.new <span class="token keyword">do</span> <span class="token operator">|</span>s<span class="token operator">|</span>     s.platform  <span class="token operator">=</span>   Gem::Platform::RUBY     s.name      <span class="token operator">=</span>   <span class="token string">"simplegit"</span>-    s.version   <span class="token operator">=</span>   <span class="token string">"0.1.0"</span>+    s.version   <span class="token operator">=</span>   <span class="token string">"0.1.1"</span>     s.author    <span class="token operator">=</span>   <span class="token string">"Scott Chacon"</span>     s.email     <span class="token operator">=</span>   <span class="token string">"schacon@gee-mail.com"</span>     s.summary   <span class="token operator">=</span>   <span class="token string">"A simple gem for using Git in Ruby code."</span>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Sat Mar <span class="token number">15</span> <span class="token number">16</span>:40:33 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    removed unnecessary <span class="token builtin class-name">test</span><span class="token function">diff</span> <span class="token parameter variable">--git</span> a/lib/simplegit.rb b/lib/simplegit.rbindex a0a60ae<span class="token punctuation">..</span>47c6340 <span class="token number">100644</span>--- a/lib/simplegit.rb+++ b/lib/simplegit.rb@@ -18,8 +18,3 @@ class SimpleGit     end end-<span class="token parameter variable">-if</span> <span class="token variable">$0</span> <span class="token operator">==</span> __FILE__-  <span class="token function">git</span> <span class="token operator">=</span> SimpleGit.new-  puts git.show<span class="token parameter variable">-end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该选项除了显示基本信息之外，还附带了每次提交的变化。 当进行代码审查，或者快速浏览某个搭档的提交所带来的变化的时候，这个参数就非常有用了。 你也可以为 <code>git log</code> 附带一系列的总结性选项。 比如你想看到每次提交的简略统计信息，可以使用 <code>--stat</code> 选项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--stat</span>commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Mon Mar <span class="token number">17</span> <span class="token number">21</span>:52:11 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    changed the version number Rakefile <span class="token operator">|</span> <span class="token number">2</span> +- <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Sat Mar <span class="token number">15</span> <span class="token number">16</span>:40:33 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    removed unnecessary <span class="token builtin class-name">test</span> lib/simplegit.rb <span class="token operator">|</span> <span class="token number">5</span> ----- <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">5</span> deletions<span class="token punctuation">(</span>-<span class="token punctuation">)</span>commit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Sat Mar <span class="token number">15</span> <span class="token number">10</span>:31:28 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    first commit README           <span class="token operator">|</span>  <span class="token number">6</span> ++++++ Rakefile         <span class="token operator">|</span> <span class="token number">23</span> +++++++++++++++++++++++ lib/simplegit.rb <span class="token operator">|</span> <span class="token number">25</span> +++++++++++++++++++++++++ <span class="token number">3</span> files changed, <span class="token number">54</span> insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>--stat</code> 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p><p>另一个非常有用的选项是 <code>--pretty</code>。 这个选项可以使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 <code>oneline</code> 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 选项，它们展示信息的格式基本一致，但是详尽程度不一：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>onelineca82a6dff817ec66f44342007202690a93763949 changed the version number085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary <span class="token builtin class-name">test</span>a11bef06a3f659402fe7563abf99ad00de2209e6 first commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最有意思的是 <code>format</code> ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>format:<span class="token string">"%h - %an, %ar : %s"</span>ca82a6d - Scott Chacon, <span class="token number">6</span> years ago <span class="token builtin class-name">:</span> changed the version number085bb3b - Scott Chacon, <span class="token number">6</span> years ago <span class="token builtin class-name">:</span> removed unnecessary <span class="token builtin class-name">test</span>a11bef0 - Scott Chacon, <span class="token number">6</span> years ago <span class="token builtin class-name">:</span> first commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><em>作者</em> 和 <em>提交者</em> 之间的差别：作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。</p><p>类似 <code>--since</code> 和 <code>--until</code> 这种按照时间作限制的选项很有用。 例如，下面的命令会列出最近两周的所有提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--since</span><span class="token operator">=</span><span class="token number">2</span>.weeks<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令可用的格式十分丰富——可以是类似 <code>"2008-01-15"</code> 的具体的某一天，也可以是类似 <code>"2 years 1 day 3 minutes ago"</code> 的相对日期。用 <code>--author</code> 选项显示指定作者的提交，用 <code>--grep</code> 选项搜索提交说明中的关键字。可以指定多个 <code>--author</code> 和 <code>--grep</code> 搜索条件，这样会只输出匹配 <strong>任意</strong> <code>--author</code> 模式和 <strong>任意</strong> <code>--grep</code> 模式的提交。然而，如果你添加了 <code>--all-match</code> 选项， 则只会输出匹配 <strong>所有</strong> <code>--grep</code> 模式的提交。</p><p>另一个非常有用的过滤器是 <code>-S</code>（俗称“pickaxe”选项，取“用鹤嘴锄在土里捡石头”之意）， 它接受一个字符串参数，并且只会显示那些添加或删除了该字符串的提交。 假设你想找出添加或删除了对某一个特定函数的引用的提交，可以调用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">-S</span> function_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后一个很实用的 <code>git log</code> 选项是路径（path）， 如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。 因为是放在最后位置上的选项，所以用两个短划线（—）隔开之前的选项和后面限定的路径名。</p><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p><strong>有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</strong></p><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令来重新提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">--amend</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。</p><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">'initial commit'</span>$ <span class="token function">git</span> <span class="token function">add</span> forgotten_file$ <span class="token function">git</span> commit <span class="token parameter variable">--amend</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p><p>当你在修补最后的提交时，与其说是修复旧提交，倒不如说是完全用一个 <strong>新的提交</strong> 替换旧的提交， 理解这一点非常重要。从效果上来说，就像是旧有的提交从未存在过一样，它并不会出现在仓库的历史中。修补提交最明显的价值是可以稍微改进你最后的提交。</p><h3 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h3><p>你已经修改了两个文件并且想要将它们作为两次独立的修改提交， 但是却意外地输入 <code>git add *</code> 暂存了它们两个。如何只取消暂存两个中的一个呢？可以使用 <code>git reset HEAD &lt;file&gt;…</code> 来取消暂存。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> reset HEAD CONTRIBUTING.mdUnstaged changes after reset:MCONTRIBUTING.md$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    renamed:    README.md -<span class="token operator">&gt;</span> READMEChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>CONTRIBUTING.md</code> 文件已经是修改未暂存的状态了。<code>git reset</code> 确实是个<strong>危险的命令</strong>，如果加上了 <code>--hard</code> 选项则更是如此。 <strong>然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。</strong></p><h3 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h3><p>如果你并不想保留对 <code>CONTRIBUTING.md</code> 文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？使用<code>git checkout -- CONTRIBUTING.md</code>命令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout -- CONTRIBUTING.md$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    renamed:    README.md -<span class="token operator">&gt;</span> README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到那些修改已经被撤消了。</p><p>务必记得 <code>git checkout — &lt;file&gt;</code> 是一个<strong>危险的命令</strong>。 <strong>你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。</strong> 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</p><p>如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，通过分支保存进度通常是更好的做法。</p><p>在 Git 中任何 <strong>已提交</strong> 的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 <code>--amend</code> 选项覆盖的提交也可以恢复。 然而，<strong>任何你未提交的东西丢失后很可能再也找不到了。</strong></p><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。（你完全可以在一个“远程”仓库上工作，而实际上它在你本地的主机上。 词语“远程”未必表示仓库在网络或互联网上的其它位置，而只是表示它在别处。 在这样的远程仓库上工作，仍然需要和其它远程仓库上一样的标准推送、拉取和抓取操作。）</p><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/schacon/ticgitCloning into <span class="token string">'ticgit'</span><span class="token punctuation">..</span>.remote: Reusing existing pack: <span class="token number">1857</span>, done.remote: Total <span class="token number">1857</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>Receiving objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">1857</span>/1857<span class="token punctuation">)</span>, <span class="token number">374.35</span> KiB <span class="token operator">|</span> <span class="token number">268.00</span> KiB/s, done.Resolving deltas: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">772</span>/772<span class="token punctuation">)</span>, done.Checking connectivity<span class="token punctuation">..</span>. done.$ <span class="token builtin class-name">cd</span> ticgit$ <span class="token function">git</span> remoteorigin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote <span class="token parameter variable">-v</span>originhttps://github.com/schacon/ticgit <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>originhttps://github.com/schacon/ticgit <span class="token punctuation">(</span>push<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> grit$ <span class="token function">git</span> remote <span class="token parameter variable">-v</span>bakkdoor  https://github.com/bakkdoor/grit <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>bakkdoor  https://github.com/bakkdoor/grit <span class="token punctuation">(</span>push<span class="token punctuation">)</span>cho45     https://github.com/cho45/grit <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>cho45     https://github.com/cho45/grit <span class="token punctuation">(</span>push<span class="token punctuation">)</span>defunkt   https://github.com/defunkt/grit <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>defunkt   https://github.com/defunkt/grit <span class="token punctuation">(</span>push<span class="token punctuation">)</span>koke      git://github.com/koke/grit.git <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>koke      git://github.com/koke/grit.git <span class="token punctuation">(</span>push<span class="token punctuation">)</span>origin    git@github.com:mojombo/grit.git <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>origin    git@github.com:mojombo/grit.git <span class="token punctuation">(</span>push<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这表示我们能非常方便地拉取其它用户的贡献。我们还可以拥有向他们推送的权限。</p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>之前已经提到并展示了 <code>git clone</code> 命令是如何自行添加远程仓库的，这里将告诉你如何自己来添加它。 运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remoteorigin$ <span class="token function">git</span> remote <span class="token function">add</span> pb https://github.com/paulboone/ticgit$ <span class="token function">git</span> remote <span class="token parameter variable">-v</span>originhttps://github.com/schacon/ticgit <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>originhttps://github.com/schacon/ticgit <span class="token punctuation">(</span>push<span class="token punctuation">)</span>pbhttps://github.com/paulboone/ticgit <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>pbhttps://github.com/paulboone/ticgit <span class="token punctuation">(</span>push<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch pbremote: Counting objects: <span class="token number">43</span>, done.remote: Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">36</span>/36<span class="token punctuation">)</span>, done.remote: Total <span class="token number">43</span> <span class="token punctuation">(</span>delta <span class="token number">10</span><span class="token punctuation">)</span>, reused <span class="token number">31</span> <span class="token punctuation">(</span>delta <span class="token number">5</span><span class="token punctuation">)</span>Unpacking objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">43</span>/43<span class="token punctuation">)</span>, done.From https://github.com/paulboone/ticgit * <span class="token punctuation">[</span>new branch<span class="token punctuation">]</span>      master     -<span class="token operator">&gt;</span> pb/master * <span class="token punctuation">[</span>new branch<span class="token punctuation">]</span>      ticgit     -<span class="token operator">&gt;</span> pb/ticgit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到——你可以将它合并到自己的某个分支中， 或者如果你想要查看它的话，可以检出一个指向该点的本地分支。</p><h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><p>从远程仓库中获得数据，可以执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch <span class="token operator">&lt;</span>remote<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</strong></p><p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。<code>git fetch</code> 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p><p>如果你的当前分支设置了跟踪远程分支， 那么可以用 <code>git pull</code> 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，<code>git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 <code>master</code> 分支（或其它名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p><h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push &lt;remote&gt; &lt;branch&gt;</code>。 当你想要将 <code>master</code> 分支推送到 <code>origin</code> 服务器时（<strong>再次说明，克隆时通常会自动帮你设置好那两个名字</strong>）， 那么运行这个命令就可以将你所做的备份到服务器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 <strong>当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。</strong></p><h3 id="查看某个远程仓库"><a href="#查看某个远程仓库" class="headerlink" title="查看某个远程仓库"></a>查看某个远程仓库</h3><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show &lt;remote&gt;</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 <code>origin</code>，会得到像下面类似的信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote show origin* remote origin  Fetch URL: https://github.com/schacon/ticgit  Push  URL: https://github.com/schacon/ticgit  HEAD branch: master  Remote branches:    master                               tracked    dev-branch                           tracked  Local branch configured <span class="token keyword">for</span> <span class="token string">'git pull'</span><span class="token builtin class-name">:</span>    master merges with remote master  Local ref configured <span class="token keyword">for</span> <span class="token string">'git push'</span><span class="token builtin class-name">:</span>    master pushes to master <span class="token punctuation">(</span>up to <span class="token function">date</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 <code>master</code> 分支，并且如果运行 <code>git pull</code>， 就会抓取所有的远程引用，然后将远程 <code>master</code> 分支合并到本地 <code>master</code> 分支。 它也会列出拉取到的所有远程引用。</p><p>如果你是 Git 的重度使用者，那么还可以通过 <code>git remote show</code> 看到更多的信息。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote show origin* remote origin  URL: https://github.com/my-org/complex-project  Fetch URL: https://github.com/my-org/complex-project  Push  URL: https://github.com/my-org/complex-project  HEAD branch: master  Remote branches:    master                           tracked    dev-branch                       tracked    markdown-strip                   tracked    issue-43                         new <span class="token punctuation">(</span>next fetch will store <span class="token keyword">in</span> remotes/origin<span class="token punctuation">)</span>    issue-45                         new <span class="token punctuation">(</span>next fetch will store <span class="token keyword">in</span> remotes/origin<span class="token punctuation">)</span>    refs/remotes/origin/issue-11     stale <span class="token punctuation">(</span>use <span class="token string">'git remote prune'</span> to remove<span class="token punctuation">)</span>  Local branches configured <span class="token keyword">for</span> <span class="token string">'git pull'</span><span class="token builtin class-name">:</span>    dev-branch merges with remote dev-branch    master     merges with remote master  Local refs configured <span class="token keyword">for</span> <span class="token string">'git push'</span><span class="token builtin class-name">:</span>    dev-branch                     pushes to dev-branch                     <span class="token punctuation">(</span>up to <span class="token function">date</span><span class="token punctuation">)</span>    markdown-strip                 pushes to markdown-strip                 <span class="token punctuation">(</span>up to <span class="token function">date</span><span class="token punctuation">)</span>    master                         pushes to master                         <span class="token punctuation">(</span>up to <span class="token function">date</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个命令列出了当你在特定的分支上执行 <code>git push</code> 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了， 还有当你执行 <code>git pull</code> 时哪些本地分支可以与它跟踪的远程分支自动合并。</p><h3 id="远程仓库的重命名与移除"><a href="#远程仓库的重命名与移除" class="headerlink" title="远程仓库的重命名与移除"></a>远程仓库的重命名与移除</h3><p>你可以运行 <code>git remote rename</code> 来修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote <span class="token function">rename</span> pb paul$ <span class="token function">git</span> remoteoriginpaul<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p><p>如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了， 又或者某一个贡献者不再贡献了——可以使用 <code>git remote remove</code> 或 <code>git remote rm</code> ：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote remove paul$ <span class="token function">git</span> remoteorigin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>像其他版本控制系统（VCS）一样，Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ <code>v1.0</code> 、 <code>v2.0</code> 等等）。 如何列出已有的标签、如何创建和删除新的标签、以及不同类型的标签分别是什么。</p><h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><p>在 Git 中列出已有的标签非常简单，只需要输入 <code>git tag</code> （可带上可选的 <code>-l</code> 选项 <code>--list</code>）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tagv1.0v2.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你也可以按照特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag <span class="token parameter variable">-l</span> <span class="token string">"v1.8.5*"</span>v1.8.5v1.8.5-rc0v1.8.5-rc1v1.8.5-rc2v1.8.5-rc3v1.8.5.1v1.8.5.2v1.8.5.3v1.8.5.4v1.8.5.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>按照通配符列出标签需要</strong> <code>-l</code> <strong>或</strong> <code>--list</code> <strong>选项</strong>。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。</p><p>轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。</p><p>而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。</p><h3 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h3><p>在 Git 中创建附注标签十分简单。 最简单的方式是当你在运行 <code>tag</code> 命令时指定 <code>-a</code> 选项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag <span class="token parameter variable">-a</span> v1.4 <span class="token parameter variable">-m</span> <span class="token string">"my version 1.4"</span>$ <span class="token function">git</span> tagv0.1v1.3v1.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>-m</code> 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。</p><p>通过使用 <code>git show</code> 命令可以看到标签信息和与之对应的提交信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> show v1.4tag v1.4Tagger: Ben Straub <span class="token operator">&lt;</span>ben@straub.cc<span class="token operator">&gt;</span>Date:   Sat May <span class="token number">3</span> <span class="token number">20</span>:19:12 <span class="token number">2014</span> <span class="token parameter variable">-0700</span>my version <span class="token number">1.4</span>commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Mon Mar <span class="token number">17</span> <span class="token number">21</span>:52:11 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    changed the version number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p><h3 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h3><p>另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或 <code>-m</code> 选项，只需要提供标签名字：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag v1.4-lw$ <span class="token function">git</span> tagv0.1v1.3v1.4v1.4-lwv1.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时，如果在标签上运行 <code>git show</code>，你不会看到额外的标签信息。 命令只会显示出提交信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> show v1.4-lwcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Mon Mar <span class="token number">17</span> <span class="token number">21</span>:52:11 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    changed the version number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h3><p>你也可以对过去的提交打标签。 假设提交历史是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch <span class="token string">'experiment'</span>a6b4c97498bd301d84096da251c98a07c7723e65 beginning <span class="token function">write</span> support0d52aaab4479697da7686c15f77a3d64d9165190 one <span class="token function">more</span> thing6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch <span class="token string">'experiment'</span>0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit <span class="token keyword">function</span>4682c3261057305bdd616e23b64b0857d832627b added a todo <span class="token function">file</span>166ae0c4d3f420721acbb115cc33848dfcc2121a started <span class="token function">write</span> support9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag <span class="token parameter variable">-a</span> v1.2 9fceb02<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到你已经在那次提交上打上标签了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tagv0.1v1.2v1.3v1.4v1.4-lwv1.5$ <span class="token function">git</span> show v1.2tag v1.2Tagger: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Mon Feb <span class="token number">9</span> <span class="token number">15</span>:32:16 <span class="token number">2009</span> <span class="token parameter variable">-0800</span>version <span class="token number">1.2</span>commit 9fceb02d0ae598e95dc970b74767f19372d61af8Author: Magnus Chacon <span class="token operator">&lt;</span>mchacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Sun Apr <span class="token number">27</span> <span class="token number">20</span>:43:35 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    updated rakefile<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h3><p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 <code>git push origin &lt;tagname&gt;</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin v1.5Counting objects: <span class="token number">14</span>, done.Delta compression using up to <span class="token number">8</span> threads.Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">12</span>/12<span class="token punctuation">)</span>, done.Writing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">14</span>/14<span class="token punctuation">)</span>, <span class="token number">2.05</span> KiB <span class="token operator">|</span> <span class="token number">0</span> bytes/s, done.Total <span class="token number">14</span> <span class="token punctuation">(</span>delta <span class="token number">3</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>To git@github.com:schacon/simplegit.git * <span class="token punctuation">[</span>new tag<span class="token punctuation">]</span>         v1.5 -<span class="token operator">&gt;</span> v1.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的 <code>git push</code> 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin <span class="token parameter variable">--tags</span>Counting objects: <span class="token number">1</span>, done.Writing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">1</span>/1<span class="token punctuation">)</span>, <span class="token number">160</span> bytes <span class="token operator">|</span> <span class="token number">0</span> bytes/s, done.Total <span class="token number">1</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>To git@github.com:schacon/simplegit.git * <span class="token punctuation">[</span>new tag<span class="token punctuation">]</span>         v1.4 -<span class="token operator">&gt;</span> v1.4 * <span class="token punctuation">[</span>new tag<span class="token punctuation">]</span>         v1.4-lw -<span class="token operator">&gt;</span> v1.4-lw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p><p>使用 <code>git push &lt;remote&gt; --tags</code> 推送标签并不会区分轻量标签和附注标签， 没有简单的选项能够让你只选择推送一种标签。</p><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p>要删除掉你本地仓库上的标签，可以使用命令 <code>git tag -d &lt;tagname&gt;</code>。 例如，可以使用以下命令删除一个轻量标签：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag <span class="token parameter variable">-d</span> v1.4-lwDeleted tag <span class="token string">'v1.4-lw'</span> <span class="token punctuation">(</span>was e7d5add<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 <code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code> 来更新你的远程仓库：</p><p>第一种变体是 <code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code> ：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin :refs/tags/v1.4-lwTo /git@github.com:schacon/simplegit.git - <span class="token punctuation">[</span>deleted<span class="token punctuation">]</span>         v1.4-lw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。</p><p>第二种更直观的删除远程标签的方式是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin <span class="token parameter variable">--delete</span> <span class="token operator">&lt;</span>tagname<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p>如果你想查看某个标签所指向的文件版本，可以使用 <code>git checkout</code> 命令， 虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout <span class="token number">2.0</span>.0Note: checking out <span class="token string">'2.0.0'</span><span class="token builtin class-name">.</span>You are <span class="token keyword">in</span> <span class="token string">'detached HEAD'</span> state. You can <span class="token function">look</span> around, <span class="token function">make</span> experimentalchanges and commit them, and you can discard any commits you <span class="token function">make</span> <span class="token keyword">in</span> thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you may<span class="token keyword">do</span> so <span class="token punctuation">(</span>now or later<span class="token punctuation">)</span> by using <span class="token parameter variable">-b</span> with the checkout <span class="token builtin class-name">command</span> again. Example:  <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> <span class="token operator">&lt;</span>new-branch<span class="token operator">&gt;</span>HEAD is now at 99ada87<span class="token punctuation">..</span>. Merge pull request <span class="token comment">#89 from schacon/appendix-final</span>$ <span class="token function">git</span> checkout <span class="token number">2.0</span>-beta-0.1Previous HEAD position was 99ada87<span class="token punctuation">..</span>. Merge pull request <span class="token comment">#89 from schacon/appendix-final</span>HEAD is now at df3f601<span class="token punctuation">..</span>. <span class="token function">add</span> atlas.json and cover image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> version2 v2.0.0Switched to a new branch <span class="token string">'version2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果在这之后又进行了一次提交，<code>version2</code> 分支就会因为这个改动向前移动， 此时它就会和 <code>v2.0.0</code> 标签稍微有些不同，这时就要当心了。</p><h3 id="git别名"><a href="#git别名" class="headerlink" title="git别名"></a>git别名</h3><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 <code>git config</code> 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.co checkout$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.br branch$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.ci commit$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.st status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这意味着，当要输入 <code>git commit</code> 时，只需要输入 <code>git ci</code>。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。</p><p>在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.unstage <span class="token string">'reset HEAD --'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会使下面的两个命令等价：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> unstage fileA$ <span class="token function">git</span> reset HEAD -- fileA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样看起来更清楚一些。 通常也会添加一个 <code>last</code> 命令，像这样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.last <span class="token string">'log -1 HEAD'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，可以轻松地看到最后一次提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> lastcommit 66938dae3329c7aebe598c2246a8e6af90d04646Author: Josh Goebel <span class="token operator">&lt;</span>dreamer3@example.com<span class="token operator">&gt;</span>Date:   Tue Aug <span class="token number">26</span> <span class="token number">19</span>:48:51 <span class="token number">2008</span> +0800    <span class="token builtin class-name">test</span> <span class="token keyword">for</span> current <span class="token function">head</span>    Signed-off-by: Scott Chacon <span class="token operator">&lt;</span>schacon@example.com<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 <code>!</code> 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 <code>git visual</code> 定义为 <code>gitk</code> 的别名：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.visual <span class="token string">'!gitk'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本控制与git(1)</title>
      <link href="/2025/02/23/1192c262.html"/>
      <url>/2025/02/23/1192c262.html</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="https://git-scm.com/book/zh/v2/%e8%b5%b7%e6%ad%a5-%e5%85%b3%e4%ba%8e%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6。">https://git-scm.com/book/zh/v2/%e8%b5%b7%e6%ad%a5-%e5%85%b3%e4%ba%8e%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6。</a></p><h2 id="版本控制（VCS，version-control-system）"><a href="#版本控制（VCS，version-control-system）" class="headerlink" title="版本控制（VCS，version control system）"></a>版本控制（VCS，version control system）</h2><h3 id="本地版本控制"><a href="#本地版本控制" class="headerlink" title="本地版本控制"></a>本地版本控制</h3><p>比较流行的一种是RCS，在硬盘上保存补丁集，通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p><h3 id="集中化版本控制系统"><a href="#集中化版本控制系统" class="headerlink" title="集中化版本控制系统"></a>集中化版本控制系统</h3><p>集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。这已经成为了版本控制的标准做法。</p><p>每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>但是缺点在于，如果中央服务器出现损坏或者宕机，那么所有使用者在这段时间都无法工作甚至使其此前的所有版本记录。</p><h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>分布式版本控制系统（Distributed Version Control System，简称 DVCS）为了解决集中化版本的缺陷而诞生。在这种系统中客户端不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录，这样任何一处服务器发生故障，其他客户端都可以进行版本回溯。</p><p>许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。</p><h2 id="git的核心理念"><a href="#git的核心理念" class="headerlink" title="git的核心理念"></a>git的核心理念</h2><h3 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h3><p>其它大部分系统以文件变更列表的形式存储信息，也就是存储不同版本之间的差异。</p><p><img src="/pics/版本控制与git/deltas.png" alt=""></p><p>git将数据看作是对小型文件系统的一系列快照。在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>，git本身更像是一个小型的文件系统。</p><p><img src="/pics/版本控制与git/snapshots.png" alt=""></p><h3 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h3><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。</p><p>如果你想查看当前版本与一个月前的版本之间引入的修改， Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p><p>这意味着在离线情况下也可以进行编辑和提交操作，而等到有网络之后再进行上传。</p><h3 id="git保证完整性"><a href="#git保证完整性" class="headerlink" title="git保证完整性"></a>git保证完整性</h3><p>Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p><p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：</p><pre class="line-numbers language-none"><code class="language-none">24b9da6552252987aa493b52f8696cd6d3b00373<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p><h3 id="git一般只添加数据"><a href="#git一般只添加数据" class="headerlink" title="git一般只添加数据"></a>git一般只添加数据</h3><p>你执行的 Git 操作，几乎只往 Git 数据库中 <strong>添加</strong> 数据。 你很难使用 Git 从数据库中删除数据，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作。未提交更新时有可能丢失或弄乱修改的内容。但是一旦你提交快照到 Git 中， 就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p><h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><p>Git 有三种状态，你的文件可能处于其中之一： <strong>已提交（committed）</strong>、<strong>已修改（modified）</strong> 和 <strong>已暂存（staged）</strong>。</p><ul><li>已修改表示修改了文件，但还没保存到数据库中。</li><li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li><li>已提交表示数据已经安全地保存在本地数据库中。</li></ul><p><img src="/pics/版本控制与git/areas.png" alt=""></p><p>工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p>暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。</p><p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。</p><p>基本的 Git 工作流程如下：</p><ol><li>在工作区中修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li></ol><h2 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h2><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p><ol><li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 <code>git config</code> 时带上 <code>--system</code> 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 你可以传递 <code>--global</code> 选项让 Git 读写此文件，这会对你系统上 <strong>所有</strong> 的仓库生效。</li><li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（即 <code>.git/config</code>）：针对该仓库。 你可以传递 <code>--local</code> 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）</li></ol><p>每一个级别会覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p><p>若你使用 Git 时需要获取帮助，有三种等价的方法可以找到 Git 命令的综合手册（manpage）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token builtin class-name">help</span> <span class="token operator">&lt;</span>verb<span class="token operator">&gt;</span>$ <span class="token function">git</span> <span class="token operator">&lt;</span>verb<span class="token operator">&gt;</span> <span class="token parameter variable">--help</span>$ <span class="token function">man</span> git-<span class="token operator">&lt;</span>verb<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此外，如果你不需要全面的手册，只需要可用选项的快速参考，那么可以用 <code>-h</code> 选项获得更简明的 “help” 输出。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习入门知识</title>
      <link href="/2025/02/14/89184582.html"/>
      <url>/2025/02/14/89184582.html</url>
      
        <content type="html"><![CDATA[<p>本文参考<a href="https://mofanpy.com/tutorials/machine-learning/reinforcement-learning/">莫烦python-强化学习</a>。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一种对强化学习的直观理解就是通过不断地尝试，从实践中学习，最终找到某种规律，得到一个训练后的agent。从实践中学习需要一个老师，这个老师会根据agent的行为进行打分，agent的训练过程实际上就是记住了各种行为对应的打分。</p><p>监督学习中使用的数据是同时包含数据和正确标签的，而强化学习可以认为老师给行为打的分数就是某种标签。</p><h2 id="强化学习分类"><a href="#强化学习分类" class="headerlink" title="强化学习分类"></a>强化学习分类</h2><h3 id="model-free和model-based"><a href="#model-free和model-based" class="headerlink" title="model-free和model-based"></a>model-free和model-based</h3><p>在model-free的方法中，都是直接从环境中得到反馈然后学习，比如Q Learning，Sarsa，Policy Gradients。而model-based则增加了一个程序，为真实世界增加了建模模型来进行模拟，这种方法可以模拟一些真实场景中不存在的情况，并且这种训练出来的RL模型具有一定想象力，可以预判接下来要发生的所有情况来进行行为选择。</p><h3 id="基于概率和基于价值"><a href="#基于概率和基于价值" class="headerlink" title="基于概率和基于价值"></a>基于概率和基于价值</h3><p>基于概率的模型可以通过感官分析下一步要采取的各种动作的概率，然后根据概率采取行动，比如Policy Gradients。而基于价值的模型则是会直接选择价值最高的动作，比如Q Learning，Sarsa。还有一种结合二者的方法，叫做Actor-Critic，actor 会基于概率做出动作, 而 critic 会对做出的动作给出动作的价值, 这样就在原有的 policy gradients 上加速了学习过程。</p><h3 id="回合更新和单步更新"><a href="#回合更新和单步更新" class="headerlink" title="回合更新和单步更新"></a>回合更新和单步更新</h3><p><img src="/pics/强化学习/RLmtd3.png" alt=""></p><p>回合更新是在游戏结束后再总结这一回合中所有转折点，进行行为准则更新。而单步更新则是在游戏进行中每一步都在更新，不需要等到游戏结束。</p><p>Monte-carlo learning 和基础版的 policy gradients 等 都是回合更新制, Q learning, Sarsa，升级版的 policy gradients 等都是单步更新制。因为单步更新更有效率，所以现在大多方法都是基于单步更新。比如有的强化学习问题并不属于回合问题。</p><h3 id="在线学习和离线学习"><a href="#在线学习和离线学习" class="headerlink" title="在线学习和离线学习"></a>在线学习和离线学习</h3><p>在线学习就是指必须本人在场，边玩边学。离线学习则是可以选择自己玩，也可以选择看着别人玩，通过别人玩的记录来学习自己的行为准则。</p><p>最典型的在线学习就是 Sarsa 了，还有一种优化 Sarsa 的算法，叫做 Sarsa lambda，最典型的离线学习就是 Q learning，后来人也根据离线学习的属性，开发了更强大的算法，比如让计算机学会玩电动的 Deep-Q-Network。</p><h2 id="几种算法简介"><a href="#几种算法简介" class="headerlink" title="几种算法简介"></a>几种算法简介</h2><h3 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q-Learning"></a>Q-Learning</h3><p>$s$为状态，$a$为行动，$Q(s,a)$为状态$s$下选择行动$a$的收益，$R$为处于某个状态下的收益。在某一个当前状态$s_t$下，单次执行可以套用如下公式：</p><ul><li>选择收益$Q(s_t,a_t)$最高的行动$a_t$，这样行动后的下一步状态是$s_{t+1}$</li><li>更新收益$Q^{new}(s_t,a_t)\leftarrow(1-\alpha)Q(s_t,a_t)+\alpha(R_{t+1}+\gamma\max_a Q(s_{t+1},a))$</li></ul><p>要注意的是Q Learning说到并不一定做到，所以也被叫做off-policy，离线学习。</p><h3 id="Sarsa"><a href="#Sarsa" class="headerlink" title="Sarsa"></a>Sarsa</h3><p><img src="/pics/强化学习/s4.png" alt=""></p><p>Sarsa和Q Learning的主要步骤很像，但是有一个核心的步骤是不同的，那就是它说到做到，在更新Q值的过程中并不一定会选择最大Q对应的步行动$a$作为更新，而是采用某种与Q相关的策略。</p><p>Q Learning的机器人永远会选择最近的一条通向成功的路，即使可能很危险，而Sarsa则比较保守，希望能够离危险远一些，拿到宝箱是次要的。</p><p>【Epsilon greedy 是用在决策上的一种策略，比如 epsilon = 0.9 时，就说明有90% 的情况我会按照 Q 表的最优值选择行为，10% 的时间使用随机选行为】</p><h4 id="Sarsa-lambda"><a href="#Sarsa-lambda" class="headerlink" title="Sarsa(lambda)"></a>Sarsa(lambda)</h4><p><img src="/pics/强化学习/3-3-1.png" alt=""></p><p>Sarsa是一种单步更新方法，这可以被成为Sarsa(0)，因为它在走完当前这一步之后直接更新行为准则，而假如走完这步再走一步再更新，那么就可以称为Sarsa(1)。以此类推，这就是Sarsa(lambda)。</p><p>“虽然我们每一步都在更新，但是在没有获取宝藏的时候，我们现在站着的这一步也没有得到任何更新，也就是直到获取宝藏时，我们才为获取到宝藏的上一步更新为：这一步很好，和获取宝藏是有关联的，而之前为了获取宝藏所走的所有步都被认为和获取宝藏没关系。回合更新虽然我要等到这回合结束，才开始对本回合所经历的所有步都添加更新，但是这所有的步都是和宝藏有关系的，都是为了得到宝藏需要学习的步，所以每一个脚印在下回合被选则的几率又高了一些。在这种角度来看，回合更新似乎会有效率一些。”</p><p>”其实 lambda 就是一个衰变值，他可以让你知道离奖励越远的步可能并不是让你最快拿到奖励的步，所以我们想象我们站在宝藏的位置，回头看看我们走过的寻宝之路，离宝藏越近的脚印越看得清，远处的脚印太渺小，我们都很难看清，那我们就索性记下离宝藏越近的脚印越重要，越需要被好好的更新。和之前我们提到过的 奖励衰减值 gamma 一样，lambda 是脚步衰减值，都是一个在 0 和 1 之间的数。“</p><h3 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h3><p>对于某些问题，是难以建立一个包含所有状态和行动的Q值表的，因为状态过于多了，比如围棋，因此不妨直接使用神经网络来拟合这个Q值表，其可以接受状态和行动并输出对应的Q值。</p><h3 id="Policy-Gradient"><a href="#Policy-Gradient" class="headerlink" title="Policy Gradient"></a>Policy Gradient</h3><h3 id="Actor-Critic"><a href="#Actor-Critic" class="headerlink" title="Actor Critic"></a>Actor Critic</h3>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parallel Computing (2)</title>
      <link href="/2025/02/12/81b3bf3b.html"/>
      <url>/2025/02/12/81b3bf3b.html</url>
      
        <content type="html"><![CDATA[<h2 id="对多级缓存的认识"><a href="#对多级缓存的认识" class="headerlink" title="对多级缓存的认识"></a>对多级缓存的认识</h2><p>多种miss：</p><ul><li>cold miss</li><li>conflict miss</li><li>capacity miss</li></ul><p><img src="/pics/parallel-compute2/slide_018.jpg" alt="slide_018"></p><h2 id="多种并行思路"><a href="#多种并行思路" class="headerlink" title="多种并行思路"></a>多种并行思路</h2><p>在本次课程中，除开上一次课程介绍的超标量（指令级别并行），又介绍了多种并行处理器思路来提升吞吐量（throughput），考虑到</p><ul><li>并行执行</li><li>访问存储器的延迟（latency）</li></ul><h3 id="超标量（super-scalar）"><a href="#超标量（super-scalar）" class="headerlink" title="超标量（super scalar）"></a>超标量（super scalar）</h3><p>对于同一个程序，可以同时抓取预先编译好的多个可并行指令进行执行。</p><p><img src="/pics/parallel-compute2/slide_024.jpg" alt="slide_024"></p><p>程序中的并行是由硬件自动发现的。</p><h3 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h3><p>在还没出现多核处理器的时候，人们设计CPU往往致力于增加更多的模块来让单条指令执行地更快。</p><p><img src="/pics/parallel-compute2/slide_025.jpg" alt="slide_025"></p><p>但是通过删去这些额外的模块，实际上可以实现多个核的处理器（单核的性能比原来要差）。</p><p><img src="/pics/parallel-compute2/slide_027.jpg" alt="slide_027"></p><p>这样通过在程序中定义多个线程，就可以比较充分地利用两个核的性能。程序示意图如下所示：</p><p><img src="/pics/parallel-compute2/slide_029.jpg" alt="slide_029"></p><p><img src="/pics/parallel-compute2/slide_030.jpg" alt="slide_030"></p><p>现代多核处理器的例子：</p><p><img src="/pics/parallel-compute2/slide_033.jpg" alt="slide_033"></p><p><img src="/pics/parallel-compute2/slide_034.jpg" alt="slide_034"></p><h3 id="单指令多数据流（SIMD）"><a href="#单指令多数据流（SIMD）" class="headerlink" title="单指令多数据流（SIMD）"></a>单指令多数据流（SIMD）</h3><p>single instruction, multiple data。</p><p>通过引入更多的ALU（计算单元），使得可以在同一时间对多个数据进行相同的运算操作。</p><p><img src="/pics/parallel-compute2/slide_037.jpg" alt="slide_037"></p><p>如上架构可以执行如下的数据并行程序：</p><p><img src="/pics/parallel-compute2/slide_039.jpg" alt="slide_039"></p><p><img src="/pics/parallel-compute2/slide_030.jpg" alt="slide_030"></p><p>【注意上述第二个程序既可以被多核处理器处理也可以被SIMD处理】向量化是由编译器实现（explicit）或者在runtime时由硬件实现（implicit）。</p><h4 id="一些行话"><a href="#一些行话" class="headerlink" title="一些行话"></a>一些行话</h4><ul><li>指令流一致性、相干性（coherence）<ul><li>相同指令可以同时作用于多个数据</li><li>一致执行对于SIMD来说是必要的</li><li>一致执行对于多核并行并不是必要的</li></ul></li><li>差异执行（divergent）<ul><li>指令流缺乏一致性</li></ul></li></ul><p><img src="/pics/parallel-compute2/slide_049.jpg" alt="slide_049"></p><p><img src="/pics/parallel-compute2/slide_050.jpg" alt="slide_050"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="/pics/parallel-compute2/slide_053.jpg" alt="slide_053"></p><p><img src="/pics/parallel-compute2/slide_054.jpg" alt="slide_054"></p><h2 id="访问存储的加速"><a href="#访问存储的加速" class="headerlink" title="访问存储的加速"></a>访问存储的加速</h2><p><img src="/pics/parallel-compute2/slide_057.jpg" alt="slide_057"></p><h3 id="数据预加载"><a href="#数据预加载" class="headerlink" title="数据预加载"></a>数据预加载</h3><p>目前有一些现代CPU架构，其可以在使用到数据前自动地进行分析，并提前加载数据，从而减少stall，但是错误估计实际上会降低性能。</p><h3 id="多线程减少stall"><a href="#多线程减少stall" class="headerlink" title="多线程减少stall"></a>多线程减少stall</h3><p>在同一个核上interleave（交织）多个线程来提升利用率。</p><p><img src="/pics/parallel-compute2/slide_066.jpg" alt="slide_066"></p><p>执行单个线程的时间实际上可能仍然很长，但是多个线程总体执行时间相较于串行执行变少了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并行计算 </tag>
            
            <tag> CS149 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parallel Computing (1)</title>
      <link href="/2025/02/12/aa9eecf8.html"/>
      <url>/2025/02/12/aa9eecf8.html</url>
      
        <content type="html"><![CDATA[<h2 id="课程核心主题"><a href="#课程核心主题" class="headerlink" title="课程核心主题"></a>课程核心主题</h2><p>【课程前置：计算机组成相关课程】</p><h3 id="设计并编写真的能够加速的并行程序"><a href="#设计并编写真的能够加速的并行程序" class="headerlink" title="设计并编写真的能够加速的并行程序"></a>设计并编写真的能够加速的并行程序</h3><p><strong>并行思维</strong>：</p><ol><li>将工作分解为多个块，使得这些块可以安全地并行执行</li><li>将每块工作分配给处理器</li><li>适当地规划不同处理器之间的交流和同步问题，保证这些问题不会限制加速比</li></ol><p><strong>对上述并行思维各项任务的抽象（架构）</strong>：使用现有并行编程语言进行编程</p><h3 id="并行计算机硬件的实现：并行计算机如何工作"><a href="#并行计算机硬件的实现：并行计算机如何工作" class="headerlink" title="并行计算机硬件的实现：并行计算机如何工作"></a>并行计算机硬件的实现：并行计算机如何工作</h3><p><strong>可以高效实现程序抽象的架构</strong>：</p><ul><li>实现的性能特征</li><li>设计的trade-off：性能，便利，能耗</li></ul><p><strong>为什么需要了解硬件</strong>：</p><ul><li>计算机的设计架构对于程序编写十分重要</li><li>效率和性能十分重要</li></ul><h3 id="关注效率"><a href="#关注效率" class="headerlink" title="关注效率"></a>关注效率</h3><p><strong>快速并不意味着高效率！</strong></p><p>使用一个具有10个处理器的计算机，但是仅仅实现了2倍的加速比，这显然是不行的。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>电脑程序是一系列需要执行的指令。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>指令是处理器需要处理的操作。执行指令实际上修改了电脑的状态，所谓状态就是指存储在电脑中的数据，这些数据处于寄存器或者存储器中。</p><h3 id="指令级别并行"><a href="#指令级别并行" class="headerlink" title="指令级别并行"></a>指令级别并行</h3><p><strong>instruction level parallelism</strong>（ILP）：构建</p><h3 id="寄存器-缓存-存储器多级结构"><a href="#寄存器-缓存-存储器多级结构" class="headerlink" title="寄存器-缓存-存储器多级结构"></a>寄存器-缓存-存储器多级结构</h3>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并行计算 </tag>
            
            <tag> CS149 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能计算系统第1章-概述</title>
      <link href="/2025/02/11/4cc7c60c.html"/>
      <url>/2025/02/11/4cc7c60c.html</url>
      
        <content type="html"><![CDATA[<h2 id="三个流派"><a href="#三个流派" class="headerlink" title="三个流派"></a>三个流派</h2><ul><li>行为主义：基于控制论，构建感知-动作型控制系统，类似于小脑（强化学习）</li><li>符号主义：基于符号逻辑的方法，用逻辑表示知识和求解方法</li><li>连接主义：基于大脑中神经元细胞连接的计算模型，用人工神经网络来拟合智能行为</li></ul><p>tips：通过核心例子或观点将文章内容在introduction中串联起来，保证审稿人在前期就可以很快理解文章内容。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missing-semester(3)-vim</title>
      <link href="/2025/02/09/86d7b9fc.html"/>
      <url>/2025/02/09/86d7b9fc.html</url>
      
        <content type="html"><![CDATA[<p>本文参考<a href="https://imageslr.com/2021/vim.html">💻【Linux】Vim 入门笔记</a>，仅供自己查阅使用</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>vim编辑器是一种多模态编辑器，其允许用户切换不同的模式来进行不同的编辑任务：</p><ul><li>normal：最初始的模式，主要用于查询和移动</li><li>insert：<code>i</code></li><li>replace：<code>r</code></li><li>visual：<code>v</code></li><li>visual line：<code>shift-v</code></li><li>visual block：<code>ctrl-v</code></li><li>command line：<code>:</code></li></ul><h3 id="buffer-window-tab"><a href="#buffer-window-tab" class="headerlink" title="buffer, window, tab"></a>buffer, window, tab</h3><p>每一个buffer对应一个文件，一个window可以显示一个buffer（多个window可以对应同一个buffer），每一个tab可以打开多个window。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p><code>:</code>后输入命令</p><h3 id="退出vim"><a href="#退出vim" class="headerlink" title="退出vim"></a>退出vim</h3><ul><li><code>:q</code>或<code>:quit</code>：退出当前tab中所在window，直到最后一个window则退出tab</li><li><code>:q!</code>：退出并丢弃已有操作</li><li><code>:wq</code>：保存更改（write）并退出（quit）</li><li><code>ZZ</code>：等价于<code>:wq</code></li></ul><h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><ul><li><code>:w</code>：保存更改</li><li><code>:w &lt;filename&gt;</code>：将当前内容保存到新的文件中</li></ul><h3 id="M-基本移动"><a href="#M-基本移动" class="headerlink" title="[M]基本移动"></a>[M]基本移动</h3><p>使用<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>而不是左下右上的方向键</p><h3 id="M-前进到第一行或最后一行"><a href="#M-前进到第一行或最后一行" class="headerlink" title="[M]前进到第一行或最后一行"></a>[M]前进到第一行或最后一行</h3><ul><li><code>gg</code>：前往第一行</li><li><code>1G</code>：同<code>gg</code></li><li><code>G</code>：前往最后一行</li></ul><h3 id="M-前往第n行"><a href="#M-前往第n行" class="headerlink" title="[M]前往第n行"></a>[M]前往第n行</h3><ul><li><code>nG</code>：前往第n行，可以在标准模式下使用<code>set number</code>来显示行号</li><li><code>:n</code>：同样前往第n行</li></ul><h3 id="M-向右移动一个单词"><a href="#M-向右移动一个单词" class="headerlink" title="[M]向右移动一个单词"></a>[M]向右移动一个单词</h3><ul><li><code>w</code>：向右移动一个单词，光标处于首字符</li><li><code>e</code>：向右移动一个单词，光标落在当前单词的最后一个字符</li></ul><p>注意此处<strong>单词</strong>的定义是<strong>连续的「数字+字母+下划线」</strong>，或者<strong>连续的「特殊字符」</strong>。<code>hello, world!!!</code> 里包含 <code>hello</code>、<code>,</code>、<code>world</code> 和 <code>!!!</code> 四个单词。</p><ul><li><code>W</code>：向右移动一个<strong>连续的「非空字符」</strong>，光标处于首字符</li><li><code>E</code>：向右移动一个<strong>连续的「非空字符」</strong>，光标落在当前单词的最后一个字符</li></ul><h3 id="M-向左移动一个单词"><a href="#M-向左移动一个单词" class="headerlink" title="[M]向左移动一个单词"></a>[M]向左移动一个单词</h3><ul><li><code>b</code>：向左移动到前一个单词的首字符</li><li><code>ge</code>：向左移动到前一个单词的末尾</li><li><code>B</code>：向左移动一个<strong>连续的「非空字符」</strong></li><li><code>gE</code>：向左移动一个<strong>连续的「非空字符」</strong>，到末尾</li></ul><h3 id="M-前往当前行的开头和末尾字符"><a href="#M-前往当前行的开头和末尾字符" class="headerlink" title="[M]前往当前行的开头和末尾字符"></a>[M]前往当前行的开头和末尾字符</h3><ul><li><code>0</code>：前往开头</li><li><code>$</code>：前往末尾</li><li><code>_</code>：前往第一个非空字符（编写python等缩进代码时很有用）</li><li><code>^</code>：与<code>_</code>等价</li></ul><h3 id="E-删除字符"><a href="#E-删除字符" class="headerlink" title="[E]删除字符"></a>[E]删除字符</h3><ul><li><code>x</code>：删除当前字符</li><li><code>X</code>：删除前一个字符</li></ul><h3 id="E-删除单词"><a href="#E-删除单词" class="headerlink" title="[E]删除单词"></a>[E]删除单词</h3><ul><li><code>dw</code>：删除单词</li><li><code>dW</code>：删除下一个空格前的单词</li></ul><h3 id="E-删除当前行"><a href="#E-删除当前行" class="headerlink" title="[E]删除当前行"></a>[E]删除当前行</h3><ul><li><code>dd</code></li></ul><h3 id="E-在当前位置插入"><a href="#E-在当前位置插入" class="headerlink" title="[E]在当前位置插入"></a>[E]在当前位置插入</h3><ul><li><code>i</code>：在当前位置前面插入（insert）</li><li><code>a</code>：在当前位置后面插入（append）</li></ul><h3 id="E-在当前行开头或末尾插入"><a href="#E-在当前行开头或末尾插入" class="headerlink" title="[E]在当前行开头或末尾插入"></a>[E]在当前行开头或末尾插入</h3><ul><li><code>I</code>：在当前行开头插入</li><li><code>A</code>：在当前行末尾插入</li></ul><h3 id="E-在当前行上或下插入新的行"><a href="#E-在当前行上或下插入新的行" class="headerlink" title="[E]在当前行上或下插入新的行"></a>[E]在当前行上或下插入新的行</h3><ul><li><code>o</code>：在上面插入新的行</li><li><code>O</code>：在下面插入新的行</li></ul><h3 id="E-改变大小写"><a href="#E-改变大小写" class="headerlink" title="[E]改变大小写"></a>[E]改变大小写</h3><ul><li><code>~</code>：将光标下的字母改变大小写</li><li><code>gu&lt;motion&gt;</code>：指定范围的字母变成小写，比如 <code>guw</code> 是后一个单词全变成小写，<code>guj</code> 是当前整行改成小写</li><li><code>gU&lt;motion&gt;</code>：指定范围的字母变成大写</li><li><code>guu</code>：将当前行的字母改成小写</li><li><code>gUU</code>：将当前行的字母改成大写</li><li><code>guiw</code>：将光标所在的单词改成小写</li></ul><h3 id="F-移动到写一个指定字符"><a href="#F-移动到写一个指定字符" class="headerlink" title="[F]移动到写一个指定字符"></a>[F]移动到写一个指定字符</h3><ul><li><code>f&lt;target&gt;</code>：移动到下一个<code>&lt;target&gt;</code>出现的位置，比如<code>ft</code>就是移动到下一个<code>t</code>出现的位置</li><li><code>F&lt;target&gt;</code>：移动到前一个<code>&lt;target&gt;</code>出现的位置</li><li><code>t&lt;target&gt;</code>：类似于<code>f</code>，但是会移动到下一个指定字符之前</li><li><code>T&lt;target&gt;</code>：类似于<code>F</code>，但是会移动到前一个指定字符之后</li></ul><h3 id="E-撤销或重做"><a href="#E-撤销或重做" class="headerlink" title="[E]撤销或重做"></a>[E]撤销或重做</h3><ul><li><code>u</code>：撤销（undo）</li><li><code>&lt;ctrl&gt;+r</code>：重做（redo）</li></ul><h2 id="一些模式"><a href="#一些模式" class="headerlink" title="一些模式"></a>一些模式</h2><h3 id="重复n次操作"><a href="#重复n次操作" class="headerlink" title="重复n次操作"></a>重复n次操作</h3><p><code>n&lt;action&gt;</code>，重复n次<code>&lt;action&gt;</code>操作</p><h3 id="操作任意范围"><a href="#操作任意范围" class="headerlink" title="操作任意范围"></a>操作任意范围</h3><p><code>&lt;verb&gt;&lt;motion&gt;</code>，任意的操作<code>&lt;verb&gt;</code>都可以和范围<code>&lt;motion&gt;</code>拼接，使得指定一个范围进行操作。<code>w</code> 是跳到下一个单词的开头，那么 <code>dw</code> 就是删除到下一个单词的开头。</p><p>大部分命令都支持 <code>&lt;verb&gt;&lt;n&gt;&lt;motion&gt;</code> 和 <code>&lt;n&gt;&lt;verb&gt;&lt;motion&gt;</code> 两种模式，比如 <code>d2w</code> 和 <code>2dw</code> 都是删除后两个单词。</p><h3 id="命令大小写"><a href="#命令大小写" class="headerlink" title="命令大小写"></a>命令大小写</h3><p>不同的方向：</p><ul><li><code>x</code> 向右、<code>X</code> 向左</li><li><code>p</code> 向下、<code>P</code> 向上</li><li><code>o</code> 向下、<code>O</code> 向上</li><li><code>f</code> 向右、<code>F</code> 向左</li></ul><p>更严格的条件：</p><ul><li><code>w</code> 将特殊字符作为独立单词，<code>W</code> 只将空格作为单词分隔符</li><li><code>e</code> / <code>E</code>、<code>b</code> / <code>B</code> 同理</li></ul><p>更大的范围：</p><ul><li><code>a</code> 在当前位置后面插入、<code>A</code> 在当前行末尾插入</li><li><code>i</code> 在当前位置前插入、<code>I</code> 在当前行开始插入</li><li><code>d</code> 删除一个范围、<code>D</code> 删除到行末尾</li><li><code>c</code> 删除一个范围、<code>C</code> 删除到行末尾，并进入编辑模式</li><li><code>s</code> 删除当前字符，并进入编辑模式；<code>S</code> 删除当前整行，并进入编辑模式</li></ul><p>连续操作：</p><ul><li><code>r</code> 替换一个字符、<code>R</code> 连续替换多个字符直到按下 <code>&lt;Esc&gt;</code></li></ul><h3 id="两个字母重复"><a href="#两个字母重复" class="headerlink" title="两个字母重复"></a>两个字母重复</h3><p>两个 verb 字母重复，表示对当前整行操作：</p><ul><li><code>dd</code>：删除整行</li><li><code>cc</code>：删除整行，并进入编辑模式</li><li><code>yy</code>：复制整行</li><li><code>guu</code>：当前整行变成小写</li><li><code>gUU</code>：当前整行变成大写</li></ul><h3 id="重复上次操作"><a href="#重复上次操作" class="headerlink" title="重复上次操作"></a>重复上次操作</h3><ul><li><code>.</code>：重复上次的编辑操作</li><li><code>,</code>或<code>;</code>：重复当前行内的上一次 / 下一次 <code>f</code> 查找</li><li><code>n</code>或<code>N</code>：按 <code>/bar&lt;Enter&gt;</code> 搜索 <code>bar</code> 字符串后，按 <code>n</code> 可以查找下一个，按 <code>N</code> 查找上一个</li></ul><h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><h3 id="E-替换一个字符"><a href="#E-替换一个字符" class="headerlink" title="[E]替换一个字符"></a>[E]替换一个字符</h3><p><code>r</code>：再按下任意键，替换（replace）当前字符，等同于 <code>x</code> + <code>i</code>。</p><h3 id="E-替换连续多个字符"><a href="#E-替换连续多个字符" class="headerlink" title="[E]替换连续多个字符"></a>[E]替换连续多个字符</h3><p><code>R</code>：替换连续的多个字符，按下 <code>&lt;Esc&gt;</code> 可以退出替换模式。</p><h3 id="E-更改一个范围的内容"><a href="#E-更改一个范围的内容" class="headerlink" title="[E]更改一个范围的内容"></a>[E]更改一个范围的内容</h3><p><code>c</code>相当于将删除和进入编辑模式合二为一（change）。</p><ul><li><code>cw</code>：更改下一个单词，等同于<code>dw</code>+<code>i</code></li></ul><h3 id="E-删除当前字符并进入编辑模式"><a href="#E-删除当前字符并进入编辑模式" class="headerlink" title="[E]删除当前字符并进入编辑模式"></a>[E]删除当前字符并进入编辑模式</h3><p><code>s</code>等价于<code>x</code>+<code>i</code>。</p><h3 id="E-删除当前整行并进入编辑模式"><a href="#E-删除当前整行并进入编辑模式" class="headerlink" title="[E]删除当前整行并进入编辑模式"></a>[E]删除当前整行并进入编辑模式</h3><p><code>S</code>等价于<code>dd</code>+<code>o</code>。也可以用<code>cc</code>。</p><h3 id="E-从当前位置开始向右删除整行"><a href="#E-从当前位置开始向右删除整行" class="headerlink" title="[E]从当前位置开始向右删除整行"></a>[E]从当前位置开始向右删除整行</h3><p><code>D</code>等价于<code>d$</code>。</p><h3 id="E-从当前位置开始向右删除整行并进入编辑模式"><a href="#E-从当前位置开始向右删除整行并进入编辑模式" class="headerlink" title="[E]从当前位置开始向右删除整行并进入编辑模式"></a>[E]从当前位置开始向右删除整行并进入编辑模式</h3><p><code>C</code>等价于<code>c$</code>，或者<code>d$</code>+<code>a</code>，或者<code>D</code>+<code>a</code>。</p><h3 id="V-可视模式选择内容"><a href="#V-可视模式选择内容" class="headerlink" title="[V]可视模式选择内容"></a>[V]可视模式选择内容</h3><p>按下 <code>v</code> 进入可视模式（visual mode），然后移动光标以选择文本。可以针对选中的文本执行任意操作 (verb)，比如</p><ul><li>按下 <code>y</code> 可以复制选中的文本，再移动到别的位置按下 <code>p</code> 粘贴这些文本</li><li>按下 <code>d</code> 可以删除选中的文本</li></ul><p>按下 <code>ctrl + v</code>可以进入 Visual Block Mode，选择一个矩形块里的内容。</p><p>按下大写 <code>V</code> 可以选中整行。常见的使用技巧：</p><ul><li>按 <code>V</code> 选中整行，按 <code>j</code> 向下选中多行，然后 <code>y</code> 复制。</li><li>按 <code>V</code> 选中整行，按 <code>j</code> 向下选中多行，按 <code>&lt;</code> 向左缩进，按 <code>.</code> 继续缩进。</li><li>按 <code>V</code> 选中整行，按 <code>j</code> 向下选中多行，按 <code>=</code> 格式化。</li></ul><h3 id="复制单词"><a href="#复制单词" class="headerlink" title="复制单词"></a>复制单词</h3><p><code>y</code>可以进行复制（yank）。</p><ul><li><code>yw</code>：复制下一个单词</li></ul><p><code>y</code>和<code>c</code>、<code>d</code>一样可以和光标移动操作符相结合。</p><h3 id="复制当前行"><a href="#复制当前行" class="headerlink" title="复制当前行"></a>复制当前行</h3><ul><li><code>yy</code>：复制当前行</li><li><code>nyy</code>：复制当前行向下的n行，包括当前行</li><li><code>ynj</code>：同<code>nyy</code></li></ul><h3 id="粘贴到下一行或上一行"><a href="#粘贴到下一行或上一行" class="headerlink" title="粘贴到下一行或上一行"></a>粘贴到下一行或上一行</h3><ul><li><code>p</code>：粘贴复制内容到目标位置，使用<code>dd</code>删除某一行后，也可以按下<code>p</code>，将删除掉的内容放置到当前光标位置下一行（但是此时是放置（put）而不是粘贴）</li><li><code>P</code>：粘贴到上一行</li></ul><h3 id="当前行置顶"><a href="#当前行置顶" class="headerlink" title="当前行置顶"></a>当前行置顶</h3><ul><li><code>zt</code>：把当前行置于屏幕顶端，<code>z</code> 字取其象形意义，模拟一张纸的折叠变形，<code>t</code> 取 top 的首字母</li><li><code>zz</code>：将当前行至于屏幕中央</li><li><code>zb</code>：将当前行至于屏幕底端</li></ul><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><ul><li><code>&lt;</code>：选中文本后，向左缩进</li><li><code>&gt;</code>：选中文本后，向右缩进】</li></ul><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><ul><li><code>=</code>：通过 <code>V</code> 选中多行，然后按 <code>=</code> 格式化选中的文本</li></ul><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="E-inside和around"><a href="#E-inside和around" class="headerlink" title="[E]inside和around"></a>[E]inside和around</h3><p>对于 Vim 的删除命令 <code>d</code>，还有一类比较常用的操作是以 <code>i</code> （inside或 inner） 和 <code>a</code> （around） 为后缀的命令，用于删除以当前光标所在的语法元素内部或周围的字符。</p><ul><li><code>diw</code> 和 <code>daw</code>：前者删除当前光标所在的单词，后者会删除当前光标所在的单词与后面的空格</li><li><code>di(</code> 和 <code>da(</code>：前者会删除括号内的内容，后者还会删除括号本身。类似的还有<code>di[</code>、<code>da[</code>、<code>di{</code>、<code>da{</code>等</li><li><code>dib</code> 和 <code>dab</code>：等价于 <code>di(</code> 和 <code>da)</code>，<code>b</code> 表示 bracket</li><li><code>di"</code> 和 <code>da"</code>：前者删除双引号内的内容，后者还会删除引号本身</li><li><code>dit</code> 和 <code>dat</code>：修改 tag 包围的内容，vim 会自动将 <code>&lt;tag&gt;</code> 和 <code>&lt;/tag&gt;</code> 识别为一对 tag</li><li><code>dip</code>：删除当前整段 (paragraph) 的内容</li></ul><p>除了 <code>d</code> 命令，<code>c</code> / <code>v</code> / <code>gu</code> 等命令也可以和 inside、around 组合。比如 <code>ciw</code> 是修改当前单词，<code>viw</code> 是选中当前单词。</p><p>inside、around 也可以和上面的重复n次结合使用。比如光标位于 <code>(a * (b + c))</code> 的字符 <code>c</code> 时，按 <code>di(</code> 将删除内层括号里的 <code>b + c</code>，按 <code>d2i(</code> 将删除外层括号里的全部内容。</p><h3 id="F-查找文档中的关键字"><a href="#F-查找文档中的关键字" class="headerlink" title="[F]查找文档中的关键字"></a>[F]查找文档中的关键字</h3><p><code>/</code> 从光标所在位置向后查找关键字，<code>n</code> / <code>N</code> 查找下一个 / 上一个匹配的位置。</p><p><code>?</code> 向前查找，不过很少使用。如果想向前查找的话，使用 <code>/</code> + <code>N</code> 就可以了。</p><p><code>q/</code>、<code>q?</code> 可以列出 <code>/</code>、<code>?</code> 的查找历史，上下选择，按 <code>i</code> 编辑，回车执行，<code>:q</code>退出。</p><p><code>&lt;pattern&gt;</code> 可以是正则表达式，比如 <code>/vim$</code> 查找位于行尾的 <code>vim</code>。查找特殊字符时需要转义，比如 <code>/vim\$</code> 查找 <code>vim$</code>。</p><p>在查找模式中加入 <code>\c</code> 表示大小写不敏感查找，<code>\C</code> 表示大小写敏感，比如 <code>/foo\c</code> 会查找 <code>foo</code>、<code>Foo</code> 等。默认是大小写敏感，可以执行 <code>:set ignorecase</code> 或写入配置文件设置大小写不敏感为默认的查找模式。</p><h3 id="F-查找当前光标对应的完整单词"><a href="#F-查找当前光标对应的完整单词" class="headerlink" title="[F]查找当前光标对应的完整单词"></a>[F]查找当前光标对应的完整单词</h3><p>按下<code>*</code>，将向后查找，按下<code>#</code>是向前查找。</p><h3 id="F-在代码块匹配的括号之间跳转"><a href="#F-在代码块匹配的括号之间跳转" class="headerlink" title="[F]在代码块匹配的括号之间跳转"></a>[F]在代码块匹配的括号之间跳转</h3><p><code>%</code> 在匹配的括号之间跳转。需要将光标放在 <code>{}[]()</code> 上，然后按 <code>%</code>。 如果光标所在的位置不是 <code>{}[]()</code>，那么会向右查找第一个 <code>{}[]()</code>。</p><h3 id="F-光标跳转到前一个位置-后一个位置"><a href="#F-光标跳转到前一个位置-后一个位置" class="headerlink" title="[F]光标跳转到前一个位置/后一个位置"></a>[F]光标跳转到前一个位置/后一个位置</h3><p>在标准模式下，<code>&lt;Ctrl&gt; + o</code> 将光标跳转到前一个位置，<code>&lt;Ctrl&gt; + i</code> 跳转到后一个位置。<code>h</code> / <code>j</code>/ <code>k</code> / <code>l</code> / <code>w</code> 等移动将不会记录在「跳转表」中，只有通过 <code>gg</code> / <code>nG</code> / 查找时的 <code>n</code> / <code>N</code> 等命令执行的跳转操作，才可以通过 <code>&lt;Ctrl&gt; + o</code> / <code>&lt;Ctrl&gt; + i</code> 来回跳转。</p><ul><li>在 VS Code 中，向前一个 / 后一个位置跳转的快捷键是 <code>&lt;Ctrl&gt; + [</code> / <code>&lt;Ctrl&gt; + ]</code>。</li></ul><h3 id="F-E-替换文本"><a href="#F-E-替换文本" class="headerlink" title="[F][E]替换文本"></a>[F][E]替换文本</h3><p><code>:s</code>（substitute）命令用来查找和替换文本。语法如下：</p><pre class="line-numbers language-none"><code class="language-none">:{range}s/{old}/{new}/{flag}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示在指定范围 <code>range</code> 内查找字符串 <code>old</code> 并替换为 <code>new</code>，<code>flag</code> 说明了替换模式，如只替换首次出现、或全部替换。</p><p>作用范围<code>range</code>分为当前行、全文、行范围、选区等：</p><ul><li>当前行：空白，默认，如 <code>:s/foo/bar/g</code></li><li>全文：<code>%</code>，如 <code>:%s/foo/bar/g</code></li><li>n~m 行：<code>n,m</code>，如 <code>:5,12s/foo/bar/g</code> 表示 5~12 行</li><li>当前行与之后 n 行：<code>.,+n</code>，如 <code>:.,+2s/foo/bar/g</code> 表示当前行与之后 2 行</li><li>选区：略</li></ul><p>替换模式<code>flag</code>：</p><ul><li>空白：默认，只替换光标位置之后的首次出现，如 <code>:%s/foo/bar</code></li><li><code>g</code>：全局替换，替换每次出现（global），如 <code>:%s/foo/bar/g</code></li><li><code>i</code>：忽略大小写</li><li><code>c</code>：交互式替换，每次替换前需要用户确认（confirm），如 <code>:%s/foo/bar/gc</code> 表示查找全文的所有 <code>foo</code> 并替换为 <code>bar</code>，每次替换前都需要确认：<ul><li>按下回车执行后，提示 `replace with bar (y/n/a/q/l/^E/^Y)?``</li><li><code>`y</code> 表示替换</li><li><code>n</code> 表示不替换</li><li><code>a</code> 表示替换后续所有</li><li><code>q</code> 表示退出查找模式</li><li><code>l</code> 表示替换当前位置并退出查找模式</li><li><code>^E</code>、<code>^Y</code> 用于向上、向下滚动屏幕，<code>^</code> 表示 <code>&lt;Ctrl&gt;</code> 键</li></ul></li></ul><p><strong>也可以配合<code>v</code>可视模式选择替换区域</strong>。 首先按 <code>v</code> 进入可视模式，选择要替换的文本范围。接下来，输入替换命令：</p><pre class="line-numbers language-none"><code class="language-none">:'&lt;,'&gt;s/old_text/new_text/g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将在选择的区域内替换所有匹配到的 <code>old_text</code>。</p><h3 id="录制宏"><a href="#录制宏" class="headerlink" title="录制宏"></a>录制宏</h3><p>Vim 的宏提供了将一系列操作记录下来然后重复执行的机制。它可以大大提高重复性的操作效率。使用宏的步骤如下：</p><ol><li>录制宏。按下 <code>q</code> 键，然后再按下一个字母 (如 <code>a</code>，这是宏的名字)，开始录制宏。这时会在状态栏显示 <code>recording a</code>。在录制时，执行要重复的操作，包括移动、删除、插入等等。执行完操作后，按下 <code>q</code> 键结束录制。</li><li>执行宏。按下 <code>@</code> 键，然后在输入框中输入之前记录宏的字母 (如 <code>a</code>)，按下回车键即可执行宏。也可以连续执行多次，比如执行 10 次，只需在 <code>@a</code> 后面加上 <code>10</code> 即可。</li></ol><p>另外，按下 <code>v</code> 键进入 visual mode 选中多行，可以批量针对多行文本执行宏。使用 <code>:reg</code> 命令可以查看所有已经保存的宏。如果在执行宏时出现错误，可以通过使用 <code>:debug</code> 命令进入调试模式。</p><h3 id="在vim中执行shell命令"><a href="#在vim中执行shell命令" class="headerlink" title="在vim中执行shell命令"></a>在vim中执行shell命令</h3><p>比如通过 vim 编辑文本的时候，希望打印当前目录，但是又不想退出 vim，那么就可以直接在 vim 中执行：<code>:!pwd</code>，这等同于在 shell 中执行 <code>pwd</code>。</p><p>获得命令提示：</p><ul><li>在 vim 中输入 <code>:</code>，再按下 <code>&lt;Ctrl&gt; + d</code>，将展示所有可以在 vim 中使用的命令。</li><li>输入 <code>:w</code>，再按下 <code>&lt;Ctrl&gt; + d</code>，将展示所有可以在 vim 中使用的、以 <code>w</code> 开头的命令。</li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件位于 <code>~/.vimrc</code>，其内容是若干行可在 vim 中执行的命令，会在每次打开 vim 时自动执行。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missing-semester(2)-shell工具和脚本</title>
      <link href="/2025/02/08/8d29a533.html"/>
      <url>/2025/02/08/8d29a533.html</url>
      
        <content type="html"><![CDATA[<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><p>在shell中，空格十分重要。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>bar %可以执行$ foo <span class="token operator">=</span> bar %无法执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意单引号和双引号的区别。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"Value is <span class="token variable">$foo</span>"</span> %<span class="token variable">$foo</span>会转变为其对应的变量值$ <span class="token builtin class-name">echo</span> <span class="token string">'Value is $foo'</span> %<span class="token variable">$foo</span>不会转换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面是一个bash脚本的例子<code>mcd.sh</code>（创建以第一个参数为名的文件夹并进入）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function-name function">mcd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ppmkdir <span class="token parameter variable">-p</span> <span class="token string">"<span class="token variable">$1</span>"</span>ppcd <span class="token string">"<span class="token variable">$1</span>"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>$0</code>表示脚本自身的名字，<code>$1</code>到<code>$9</code>依次表示各个输入参数，<code>$_</code>是上一个指令的最后一个参数，<code>$?</code>可以获得上一个指令的错误代码，<code>!!</code>可以指代上一条指令。可以通过如下指令来加载新定义的函数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">source</span> mcd.sh %脚本中包含的函数会在当前shell中加载<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>逻辑符号：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token boolean">false</span> <span class="token operator">||</span> <span class="token builtin class-name">echo</span> <span class="token string">"Oops fail"</span> %如果第一条指令出错，则执行第二条指令$ <span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">"Things went well"</span> %如果第一条指令正确，才会执行第二条指令$ <span class="token boolean">false</span> <span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token string">"This will alwanys print"</span> %分号只是将两条指令分割开来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将某个指令的输出赋值给一个变量：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>$ <span class="token builtin class-name">echo</span> <span class="token string">"We are in <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>冷门特性——进程替换：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">ls</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">ls</span> <span class="token punctuation">..</span><span class="token punctuation">)</span> %<span class="token operator">&lt;</span><span class="token punctuation">(</span>命令<span class="token punctuation">)</span>相当于把该命令的输出作为一个临时文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面展示一个具体的例子（使用 <code>grep</code> 搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token string">"Starting program at <span class="token variable"><span class="token variable">$(</span><span class="token function">date</span><span class="token variable">)</span></span>"</span> <span class="token comment"># date会被替换成日期和时间</span><span class="token builtin class-name">echo</span> <span class="token string">"Running program <span class="token variable">$0</span> with <span class="token variable">$#</span> arguments with pid <span class="token variable">$$</span>"</span><span class="token comment"># $#表示输入参数的数目，$$表示当前进程的id</span><span class="token keyword">for</span> <span class="token for-or-select variable">file</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$@</span>"</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token comment"># $@表示所有的参数</span>    <span class="token function">grep</span> foobar <span class="token string">"<span class="token variable">$file</span>"</span> <span class="token operator">&gt;</span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> /dev/null    <span class="token comment"># 如果模式没有找到，则grep退出状态为 1</span>    <span class="token comment"># 我们将标准输出流(第一个&gt;)和标准错误流(2&gt;)重定向到Null，因为我们并不关心这些信息</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$?</span> <span class="token parameter variable">-ne</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token builtin class-name">echo</span> <span class="token string">"File <span class="token variable">$file</span> does not have any foobar, adding one"</span>        <span class="token builtin class-name">echo</span> <span class="token string">"# foobar"</span> <span class="token operator">&gt;&gt;</span> <span class="token string">"<span class="token variable">$file</span>"</span>    <span class="token keyword">fi</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接使用如下方式执行上述脚本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./example.sh <span class="token punctuation">[</span>文件1<span class="token punctuation">]</span> <span class="token punctuation">[</span>文件2<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>shell的通配（globbing）允许我们方便地进行文件匹配：</p><ul><li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件 <code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code> 这条命令会删除 <code>foo1</code> 和 <code>foo2</code> ，而 <code>rm foo*</code> 则会删除除了 <code>bar</code> 之外的所有文件。</li><li>花括号 <code>{}</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ convert image.<span class="token punctuation">{</span>png,jpg<span class="token punctuation">}</span> %会展开为convert image.png image.jpg$ <span class="token function">cp</span> /path/to/project/<span class="token punctuation">{</span>foo,bar,baz<span class="token punctuation">}</span>.sh /newpath %会展开为cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath$ <span class="token function">mv</span> *<span class="token punctuation">{</span>.py,.sh<span class="token punctuation">}</span> folder %移动所有以.py和.sh结尾的文件$ <span class="token function">touch</span> <span class="token punctuation">{</span>foo,bar<span class="token punctuation">}</span>/<span class="token punctuation">{</span>a<span class="token punctuation">..</span>j<span class="token punctuation">}</span> %展开为foo/a, foo/b, <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>脚本并不是一定只有用bash写才能在终端中调用，如下的Python脚本也可以直接在终端中调用：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/local/bin/python</span><span class="token keyword">import</span> sys<span class="token keyword">for</span> arg <span class="token keyword">in</span> <span class="token builtin">reversed</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>脚本中第一行的<code>shebang</code>使得终端知道应该调用python解释器。（也可以写为<code>#!/usr/bin/env python</code>）</p><p> 编写 <code>bash</code> 脚本有时候会很别扭和反直觉，<a href="https://github.com/koalaman/shellcheck">shellcheck</a> 这样的工具可以帮助你定位 sh/bash 脚本中的错误。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">shellcheck</span> mcd.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>shell 函数和脚本有如下一些不同点：</p><ul><li>函数只能与 shell 使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li><li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li><li><strong>函数会在当前的 shell 环境中执行，脚本会在单独的进程中执行。</strong>因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <a href="https://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a> 将环境变量导出，并将值传递给环境变量。</li><li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell 脚本中往往也会包含它们自己的函数定义。</li></ul><h2 id="shell工具"><a href="#shell工具" class="headerlink" title="shell工具"></a>shell工具</h2><h3 id="查看命令实例"><a href="#查看命令实例" class="headerlink" title="查看命令实例"></a>查看命令实例</h3><p><code>convert</code>和<code>ffmpeg</code>这两个命令可以分别用于处理图片和视频。可以使用如下指令获得一些命令的简单例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tldr convert <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><p>通过如下指令可以找到所需的文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-name</span> src <span class="token parameter variable">-type</span> d %在当前文件夹中迭代找到名称为src的文件夹$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-path</span> <span class="token string">'**/test/*.py'</span> <span class="token parameter variable">-type</span> f %在当前文件夹中找到某些文件夹下包含在test子目录中的py文件$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-mtime</span> <span class="token parameter variable">-1</span> %在昨天被修改过的文件，mtime表示修改时间$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-name</span> <span class="token string">"*.tmp"</span> <span class="token parameter variable">-exec</span> <span class="token function">rm</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">\</span><span class="token punctuation">;</span> %找到这些文件并移除它们$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-name</span> <span class="token string">'*.png'</span> <span class="token parameter variable">-exec</span> convert <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>.jpg <span class="token punctuation">\</span><span class="token punctuation">;</span> %查找全部的 PNG 文件并将其转换为 JPG$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-size</span> +500k <span class="token parameter variable">-size</span> <span class="token parameter variable">-10M</span> <span class="token parameter variable">-name</span> <span class="token string">'*.tar.gz'</span> %查找所有大小在500k至10M的tar.gz文件$ fd <span class="token string">"*.py"</span> %具有和find相似的作用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以检索整个文件系统：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ updatedb %在执行查找前需要更新数据库$ <span class="token function">locate</span> tmp %找到整个文件系统中路径带有tmp的文件，注意是是路径中带有<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="查找内容"><a href="#查找内容" class="headerlink" title="查找内容"></a>查找内容</h3><p>如下方式可以查找文件中特定内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">grep</span> foobar mcd.sh %查找mcd.sh文件中的foobar$ <span class="token function">grep</span> <span class="token parameter variable">-R</span> foobar %在当前文件夹下查找文件中所有出现位置$ rg <span class="token string">"import requests"</span> <span class="token parameter variable">-t</span> py ~/scratch %在该文件夹下迭代搜索所有出现该内容的py文件$ rg <span class="token string">"import requests"</span> <span class="token parameter variable">-t</span> py <span class="token parameter variable">-C</span> <span class="token number">5</span> ~/scratch %输出时展示附近的5行内容$ rg <span class="token parameter variable">-u</span> --files-without-match <span class="token string">"^#\!"</span> <span class="token parameter variable">-t</span> <span class="token function">sh</span> %找到没有出现<span class="token string">"#!"</span>的文件，即没有shebang的文件，-u表示不要忽略隐藏文件$ rg <span class="token string">"import requests"</span> <span class="token parameter variable">-t</span> py <span class="token parameter variable">-C</span> <span class="token number">5</span> <span class="token parameter variable">--stats</span> PATTERN ~/scratch %打印更详细的检索信息$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>grep</code> 有很多选项，<code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。也出现了很多它的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。</p><h3 id="查找shell命令"><a href="#查找shell命令" class="headerlink" title="查找shell命令"></a>查找shell命令</h3><p>可以直接显示过往命令历史：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">history</span>$ <span class="token function">history</span> <span class="token operator">|</span> <span class="token function">grep</span> convert %先显示历史，再匹配对应的命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以使用<code>ctrl+R</code>，<code>fzf</code>可以进行模糊的检索（可以将其与<code>ctrl+R</code>绑定）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> example.sh <span class="token operator">|</span> fzf %进行可交互的查找<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录间随意切换呢？有很多简便的方法可以做到，比如设置 alias，使用 <a href="https://man7.org/linux/man-pages/man1/ln.1.html">ln -s</a> 创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p><p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用 <a href="https://github.com/clvv/fasd"><code>fasd</code></a> 和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p><p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm"><em>frecency</em> </a>对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em>）和时效（<em>recency</em>）进行排序。默认情况下，<code>fasd</code> 使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问 <code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用 <code>j cool</code> 代替即可。</p><p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tree %树状图显示文件结构$ broot %可交互的树状图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>命令行可以从参数或标准输入接受输入，在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如 <code>tar</code> 则需要从参数接受输入，而<code>xargs</code>可以使用标准输入中的内容作为参数，比如</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">rm</span> %删除当前文件夹下的所有文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missing-semester(1)-shell</title>
      <link href="/2025/02/07/fa4b86b9.html"/>
      <url>/2025/02/07/fa4b86b9.html</url>
      
        <content type="html"><![CDATA[<h2 id="shell基本使用"><a href="#shell基本使用" class="headerlink" title="shell基本使用"></a>shell基本使用</h2><p>如果需要同时输入多个argument，那么如下两种表达是等价的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> Hello<span class="token punctuation">\</span> World$ <span class="token builtin class-name">echo</span> <span class="token string">"Hello World"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>机器有其自身的内置函数，这些内置函数是终端系统可以直接执行的，机器通过<strong>环境变量</strong>来定位这些内置函数的位置。如下操作可以显示环境变量的位置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在每次执行一次shell指令时，终端都会在上述路径中搜索是否存在对应的函数。linux系统的namespace（路径的根源）一般只有一个，就是root，但是Windows一般有多个Driver作为路径根源。</p><p>显示当前工作路径位置（present working directory）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">pwd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>改变当前工作位置（change directory）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> xxx$ <span class="token builtin class-name">cd</span> - %回到上一次所在的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果环境变量中缺少你想要执行的指令所在的位置，那么可以在执行命令时直接指定其具体位置。</p><p>显示当前所在位置的所有文件（list d）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指令一般可以接受flags（开关）或者options（选择），可以指定一些额外的操作信息，可以用如下方式进行查看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token punctuation">[</span>指令<span class="token punctuation">]</span> <span class="token parameter variable">--help</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用如下指令后可以看到文件的具体信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">drwxr-xr-x <span class="token number">1</span> missing  <span class="token function">users</span>  <span class="token number">4096</span> Jun <span class="token number">15</span>  <span class="token number">2019</span> missing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一些关于上述文件的具体信息：</p><ul><li><code>d</code>开头表示<code>missing</code>是文件夹</li><li>每3个字符构成的3个组<code>rwx</code>用来依次表示文件所有者、用户组（users）以及其他所有人依次所具有的权限</li><li><code>-</code>表示某种类型的用户不具备相应的权限</li><li>上述信息表明只有文件所有者可以修改，其他用户只可以阅读或者执行</li></ul><p>还有一些常用指令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mv</span> <span class="token punctuation">[</span>旧名字<span class="token punctuation">]</span> <span class="token punctuation">[</span>新名字<span class="token punctuation">]</span> %对文件进行重命名$ <span class="token function">cp</span> <span class="token punctuation">[</span>原位置<span class="token punctuation">]</span> <span class="token punctuation">[</span>新位置<span class="token punctuation">]</span> %对文件进行复制$ <span class="token function">rm</span> <span class="token punctuation">[</span>文件位置<span class="token punctuation">]</span> %对文件进行删除$ <span class="token function">rmdir</span> <span class="token punctuation">[</span>文件夹<span class="token punctuation">]</span> %仅用于空文件夹的清除$ <span class="token function">mkdir</span> <span class="token punctuation">[</span>文件夹名<span class="token punctuation">]</span> %用于文件夹创建$ <span class="token function">man</span> <span class="token punctuation">[</span>指令或程序<span class="token punctuation">]</span> %显示程序的用户手册，按下q来退出$ ^L %清空终端，回到最上部分<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="建立程序间的连接"><a href="#建立程序间的连接" class="headerlink" title="建立程序间的连接"></a>建立程序间的连接</h2><p>指令一般都有输入流和输出流，<strong>最基本的输入流就是键盘，最基本的输出流就是终端</strong>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token operator">&lt;</span> <span class="token function">file</span> %将file的内容作为输入流$ <span class="token operator">&gt;</span> <span class="token function">file</span> %将输出流写入file（覆写）$ <span class="token builtin class-name">echo</span> hello <span class="token operator">&gt;</span> hello.txt %文件中的内容就是hello$ <span class="token function">cat</span> hello.txt %输出文件内容到终端$ <span class="token function">cat</span> <span class="token operator">&lt;</span> hello.txt %将hello.txt中内容作为cat的输入流$ <span class="token function">cat</span> <span class="token operator">&lt;</span> hello.txt <span class="token operator">&gt;</span> hello2.txt$ <span class="token operator">&gt;&gt;</span> <span class="token function">file</span> %将新信息添加到file中，而不是覆写$    <span class="token operator">|</span>   %pipe, 将左边程序的输出作为右边程序的输入$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> / <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-n1</span> %罗列/下的详细文件信息，给到右侧程序，右侧程序筛选出最后1条$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> / <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-n1</span> <span class="token operator">&gt;</span> ls.txt$ <span class="token function">curl</span> <span class="token parameter variable">--head</span> <span class="token parameter variable">--silent</span> google.com <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> content-length <span class="token operator">|</span> <span class="token function">cut</span> <span class="token parameter variable">--delimiter</span><span class="token operator">=</span><span class="token string">' '</span> <span class="token parameter variable">-f2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上可以通过简单的pipe来实现个人媒体直播，将自己的本地文件作为左侧程序，右侧程序则是向互联网发送数据。</p><h2 id="root用户"><a href="#root用户" class="headerlink" title="root用户"></a>root用户</h2><p>有时候需要作为root用户执行指令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token punctuation">[</span>指令<span class="token punctuation">]</span> %su意思是super<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过如下操作可以进入机器的内核系统，可以看到众多的内核参数，看起来就像文件系统一样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /sys %进入内核$ <span class="token builtin class-name">cd</span> class$ <span class="token builtin class-name">cd</span> backlight$ <span class="token builtin class-name">echo</span> <span class="token number">500</span> <span class="token operator">&gt;</span> brightness %无法执行，需要root权限$ <span class="token function">sudo</span> <span class="token builtin class-name">echo</span> <span class="token number">500</span> <span class="token operator">&gt;</span> brightness %仍然无法执行，因为sudo事实上只作用于echo，而没有作用于整个重定向<span class="token comment"># echo 1 &gt; /sys/net/ipv4_forward %加上井字号pound意味着要以root权限来执行该程序，这区别于美元符号</span>$ <span class="token function">sudo</span> <span class="token function">su</span> %执行该命令来切换为root权限<span class="token comment"># exit %退出root权限</span>$ <span class="token builtin class-name">echo</span> <span class="token number">500</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> brightness %如果不切换为root权限，也可以使用这个命令来修改机器背景光，tee可以读取输入流来写入文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如下命令可以打开文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">xdg-open</span> <span class="token punctuation">[</span>文件名<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/02/07/4a17b156.html"/>
      <url>/2025/02/07/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><script type="math/tex; mode=display">\left\{\begin{matrix}f(\vec x)=\frac{\sum\vec x}{2}\\f(\vec x)=\frac{\sum\vec x}{3}\end{matrix}\right.</script><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
