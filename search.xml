<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>版本控制与git(3)</title>
      <link href="/2025/02/25/23a4a0e0.html"/>
      <url>/2025/02/25/23a4a0e0.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>版本控制与git(2)</title>
      <link href="/2025/02/23/3abf91a1.html"/>
      <url>/2025/02/23/3abf91a1.html</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="https://git-scm.com/book/zh/v2/%E3%80%82">https://git-scm.com/book/zh/v2/。</a></p><h2 id="获取git仓库"><a href="#获取git仓库" class="headerlink" title="获取git仓库"></a>获取git仓库</h2><p>有两种获取 Git 项目仓库的方式：</p><ol><li>将尚未进行版本控制的本地目录转换为 Git 仓库；</li><li>从其它服务器 <strong>克隆</strong> 一个已存在的 Git 仓库。</li></ol><h3 id="在已存在目录中初始化仓库"><a href="#在已存在目录中初始化仓库" class="headerlink" title="在已存在目录中初始化仓库"></a>在已存在目录中初始化仓库</h3><p>进入希望转化为git仓库的工作目录，执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。但是这只是一个简单的初始化，项目中的文件还没有被跟踪。</p><p>如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 <code>git add</code> 命令来指定所需的文件来进行追踪，然后执行 <code>git commit</code> ：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> *.c %将所有的扩展名为.c的文件添加到暂存区$ <span class="token function">git</span> <span class="token function">add</span> LICENSE $ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">'initial project version'</span> %进行第一次文件提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="克隆现有仓库"><a href="#克隆现有仓库" class="headerlink" title="克隆现有仓库"></a>克隆现有仓库</h3><p>如果希望参与到某一个开源项目中去，一般就需要获得已经存在的git仓库的拷贝，这时就要用到 <code>git clone</code> 命令。</p><p>Git克隆的是该Git仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。当你执行 <code>git clone</code> 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库。</p><p>克隆仓库的命令是 <code>git clone &lt;url&gt;</code>，比如</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/holimario/holimario.github.io.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就会创建一个和该git仓库相同名称的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹， 从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。</p><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/holimario/holimario.github.io.git mydir<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Git 支持多种数据传输协议。 上面的例子使用的是 <code>https://</code> 协议，不过你也可以使用 <code>git://</code> 协议或者使用 SSH 传输协议，比如 <code>user@server:path/to/repo.git</code> 。</p><h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>现在我们的机器上有了一个 <strong>真实项目</strong> 的 Git 仓库，并从这个仓库中检出了所有文件的 <strong>工作副本</strong>。 通常，你会对这些文件做些修改，每当完成了一个阶段的目标，想要将记录下它时，就将它提交到仓库。</p><p>工作目录下的文件都只有两个状态：<strong>已跟踪</strong>或<strong>未跟踪</strong>。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。</p><p>工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。</p><p><img src="/pics/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8Egit/lifecycle.png"></p><h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>可以用 <code>git status</code> 命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>nothing to commit, working directory clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这说明你现在的工作目录很干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。</p><p>现在，让我们在项目下创建一个新的 <code>README</code> 文件。 如果之前并不存在这个文件，使用 <code>git status</code> 命令，你将看到一个新的未跟踪文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">'My Project'</span> <span class="token operator">&gt;</span> README$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Untracked files:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to include <span class="token keyword">in</span> what will be committed<span class="token punctuation">)</span>    READMEnothing added to commit but untracked files present <span class="token punctuation">(</span>use <span class="token string">"git add"</span> to track<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。</p><h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>使用命令 <code>git add</code> 开始跟踪一个文件。 所以，要跟踪 <code>README</code> 文件，运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> README<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时再运行 <code>git status</code> 命令，会看到 <code>README</code> 文件已被跟踪，并处于暂存状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git restore --staged &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    new file:   README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要在 <code>Changes to be committed</code> 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件在你运行 <code>git add</code> 时的版本将被留存在后续的历史记录中。<code>git add</code> 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p><h3 id="暂存已修改的文件"><a href="#暂存已修改的文件" class="headerlink" title="暂存已修改的文件"></a>暂存已修改的文件</h3><p> 如果你修改了一个名为 <code>CONTRIBUTING.md</code> 的已被跟踪的文件，然后运行 <code>git status</code> 命令，会看到下面内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    new file:   READMEChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件 <code>CONTRIBUTING.md</code> 出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行 <code>git add</code> 将“CONTRIBUTING.md”放到暂存区，然后再看看 <code>git status</code> 的输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> CONTRIBUTING.md$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    new file:   README    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 <code>CONTRIBUTING.md</code> 里再加条注释。 重新编辑存盘后，准备好提交。 不过且慢，再运行 <code>git status</code> 看看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vim</span> CONTRIBUTING.md$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    new file:   README    modified:   CONTRIBUTING.mdChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时<code>CONTRIBUTING.md</code> 文件同时出现在暂存区和非暂存区。实际上 Git 只不过暂存了你运行 <code>git add</code> 命令时的版本。 如果你现在提交，<code>CONTRIBUTING.md</code> 的版本是你最后一次运行 <code>git add</code> 命令时的那个版本，而不是你运行 <code>git commit</code> 时，在工作目录中的当前版本。所以，运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行 <code>git add</code> 把最新版本重新暂存起来：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> CONTRIBUTING.md$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    new file:   README    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种格式更为紧凑的输出。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> status <span class="token parameter variable">-s</span> M READMEMM RakefileA  lib/git.rbM  lib/simplegit.rb?? LICENSE.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示： <code>README</code> 文件在工作区已修改但尚未暂存，而 <code>lib/simplegit.rb</code> 文件已修改且已暂存。 <code>Rakefile</code> 文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件的模式。 来看一个实际的 <code>.gitignore</code> 例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> .gitignore*.<span class="token punctuation">[</span>oa<span class="token punctuation">]</span>*~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件。</p><p>文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反。</li></ul><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号（<code>**</code>）表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> 、 <code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p><p>如下是一个<code>.gitignore</code> 文件的例子：</p><pre class="line-numbers language-none"><code class="language-none"># 忽略所有的 .a 文件*.a# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件!lib.a# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO/TODO# 忽略任何目录下名为 build 的文件夹build/# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件doc/**/*.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>GitHub 有一个十分详细的针对数十种项目及语言的 <code>.gitignore</code> 文件列表：<a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 。</p><p>在最简单的情况下，一个仓库可能只根目录下有一个 <code>.gitignore</code> 文件，它递归地应用到整个仓库中。 然而，子目录下也可以有额外的 <code>.gitignore</code> 文件。子目录中的 <code>.gitignore</code> 文件中的规则只作用于它所在的目录中。</p><h3 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h3><p>想知道具体修改了什么地方，可以用 <code>git diff</code> 命令。通常可能会用它来回答这两个问题：当前做的哪些更新尚未暂存？ 有哪些更新已暂存并准备好下次提交？虽然 <code>git status</code> 已经通过在相应栏下列出文件名的方式回答了这个问题，但 <code>git diff</code> 能通过文件补丁的格式更加具体地显示哪些行发生了改变。</p><p>假如再次修改 README 文件后暂存，然后编辑 <code>CONTRIBUTING.md</code> 文件后先不暂存， 运行 <code>status</code> 命令将会看到：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    modified:   READMEChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">diff</span><span class="token function">diff</span> <span class="token parameter variable">--git</span> a/CONTRIBUTING.md b/CONTRIBUTING.mdindex 8ebb991<span class="token punctuation">..</span>643e24f <span class="token number">100644</span>--- a/CONTRIBUTING.md+++ b/CONTRIBUTING.md@@ -65,7 +65,8 @@ branch directly, things can get messy. Please include a <span class="token function">nice</span> description of your changes when you submit your PR<span class="token punctuation">;</span> <span class="token keyword">if</span> we have to <span class="token builtin class-name">read</span> the whole <span class="token function">diff</span> to figure out why you<span class="token string">'re contributing in the first place, you'</span>re <span class="token function">less</span> likely to get feedback and have your change<span class="token parameter variable">-merged</span> in.+merged in. Also, <span class="token function">split</span> your changes into comprehensive chunks <span class="token keyword">if</span> your patch is+longer than a dozen lines. If you are starting to work on a particular area, feel <span class="token function">free</span> to submit a PR that highlights your work <span class="token keyword">in</span> progress <span class="token punctuation">(</span>and note <span class="token keyword">in</span> the PR title that it's<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。</p><p>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --staged</code> （或者<code>git diff --cached</code>）命令。 这条命令将比对已暂存文件与最后一次提交的文件差异：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> <span class="token parameter variable">--staged</span><span class="token function">diff</span> <span class="token parameter variable">--git</span> a/README b/READMEnew <span class="token function">file</span> mode <span class="token number">100644</span>index 0000000<span class="token punctuation">..</span>03902a1--- /dev/null+++ b/README@@ -0,0 +1 @@+My Project<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，<code>git diff</code> 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 <code>git diff</code> 后却什么也没有，就是这个原因。</p><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>现在的暂存区已经准备就绪，可以提交了。此时需要确认是否还存在某些已修改或者已经新建的文件还没有进行<code>git add</code>，否则提交的时候不会记录这些尚未暂存的变化。 这些已修改但未暂存的文件只会保留在本地磁盘。 所以，每次准备提交前，先用 <code>git status</code> 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样会启动你选择的文本编辑器来输入提交说明。（启动的编辑器是通过 Shell 的环境变量 <code>EDITOR</code> 指定的）</p><p>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Please enter the commit message for your changes. Lines starting</span><span class="token comment"># with '#' will be ignored, and an empty message aborts the commit.</span><span class="token comment"># On branch master</span><span class="token comment"># Your branch is up-to-date with 'origin/master'.</span><span class="token comment">#</span><span class="token comment"># Changes to be committed:</span><span class="token comment">#new file:   README</span><span class="token comment">#modified:   CONTRIBUTING.md</span><span class="token comment">#</span>~~~<span class="token string">".git/COMMIT_EDITMSG"</span> 9L, 283C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一个空行，供你输入提交说明。退出编辑器时，Git 会丢弃注释行，用你输入的提交说明生成一次提交。</p><p>另外，你也可以在 <code>commit</code> 命令后添加 <code>-m</code> 选项，将提交信息与命令放在同一行，如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"Story 182: Fix benchmarks for speed"</span><span class="token punctuation">[</span>master 463dc4f<span class="token punctuation">]</span> Story <span class="token number">182</span>: Fix benchmarks <span class="token keyword">for</span> speed <span class="token number">2</span> files changed, <span class="token number">2</span> insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode <span class="token number">100644</span> README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，完成一次提交之后，输出信息告诉你是哪个分支提交的，本次提交的完整SHA-1校验和，以及本次提交中多少文件被修改，多少行添加和删改。</p><h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><p>暂存区可以比较精细地准备提交细节，但是有时会略显繁琐，因此git提供了一个可以跳过使用暂存区域的方式，只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，<strong>Git 就会自动把所有已经跟踪过的文件暂存起来一并提交</strong>，从而跳过 <code>git add</code> 步骤。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   CONTRIBUTING.mdno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span>$ <span class="token function">git</span> commit <span class="token parameter variable">-a</span> <span class="token parameter variable">-m</span> <span class="token string">'added new benchmarks'</span><span class="token punctuation">[</span>master 83e38c7<span class="token punctuation">]</span> added new benchmarks <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">5</span> insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">0</span> deletions<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <code>-a</code> 选项使本次提交包含了所有修改过的文件。 这很方便，但是要小心，有时这个选项会将不需要的文件添加到提交中。</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是 <em>未暂存清单</em>）看到：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> PROJECTS.md$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add/rm &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>        deleted:    PROJECTS.mdno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再运行 <code>git rm</code> 记录此次移除文件的操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> PROJECTS.md<span class="token function">rm</span> <span class="token string">'PROJECTS.md'</span>$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    deleted:    PROJECTS.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下一次提交时，该文件就不再纳入版本管理了。 如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删尚未添加到快照的数据，这样的数据不能被 Git 恢复。</p><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> <span class="token parameter variable">--cached</span> README<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。比如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> log/<span class="token punctuation">\</span>*.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code> 的所有文件。 类似的比如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> <span class="token punctuation">\</span>*~<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令会删除所有名字以 <code>~</code> 结尾的文件。</p><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。但是Git仍然可以推知发生了什么。</p><p> 要在 Git 中对文件改名，可以这么做：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">mv</span> file_from file_to<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">mv</span> README.md README$ <span class="token function">git</span> statusOn branch masterYour branch is up-to-date with <span class="token string">'origin/master'</span><span class="token builtin class-name">.</span>Changes to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    renamed:    README.md -<span class="token operator">&gt;</span> README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mv</span> README.md README<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。</p><p>当你在此项目中运行 <code>git log</code> 命令时，可以看到下面的输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> logcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Mon Mar <span class="token number">17</span> <span class="token number">21</span>:52:11 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    changed the version numbercommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Sat Mar <span class="token number">15</span> <span class="token number">16</span>:40:33 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    removed unnecessary <span class="token builtin class-name">test</span>commit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Sat Mar <span class="token number">15</span> <span class="token number">10</span>:31:28 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    first commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不传入任何参数的默认情况下，<code>git log</code> 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><p><code>git log</code> 有许多选项可以帮助你搜寻你所要找的提交。</p><p>其中一个比较有用的选项是 <code>-p</code> 或 <code>--patch</code> ，它会显示每次提交所引入的差异（按 <strong>补丁</strong> 的格式输出）。 你也可以限制显示的日志条目数量，例如使用 <code>-2</code> 选项来只显示最近的两次提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">-p</span> <span class="token parameter variable">-2</span>commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Mon Mar <span class="token number">17</span> <span class="token number">21</span>:52:11 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    changed the version number<span class="token function">diff</span> <span class="token parameter variable">--git</span> a/Rakefile b/Rakefileindex a874b73<span class="token punctuation">..</span>8f94139 <span class="token number">100644</span>--- a/Rakefile+++ b/Rakefile@@ -5,7 +5,7 @@ require <span class="token string">'rake/gempackagetask'</span> spec <span class="token operator">=</span> Gem::Specification.new <span class="token keyword">do</span> <span class="token operator">|</span>s<span class="token operator">|</span>     s.platform  <span class="token operator">=</span>   Gem::Platform::RUBY     s.name      <span class="token operator">=</span>   <span class="token string">"simplegit"</span>-    s.version   <span class="token operator">=</span>   <span class="token string">"0.1.0"</span>+    s.version   <span class="token operator">=</span>   <span class="token string">"0.1.1"</span>     s.author    <span class="token operator">=</span>   <span class="token string">"Scott Chacon"</span>     s.email     <span class="token operator">=</span>   <span class="token string">"schacon@gee-mail.com"</span>     s.summary   <span class="token operator">=</span>   <span class="token string">"A simple gem for using Git in Ruby code."</span>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Sat Mar <span class="token number">15</span> <span class="token number">16</span>:40:33 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    removed unnecessary <span class="token builtin class-name">test</span><span class="token function">diff</span> <span class="token parameter variable">--git</span> a/lib/simplegit.rb b/lib/simplegit.rbindex a0a60ae<span class="token punctuation">..</span>47c6340 <span class="token number">100644</span>--- a/lib/simplegit.rb+++ b/lib/simplegit.rb@@ -18,8 +18,3 @@ class SimpleGit     end end-<span class="token parameter variable">-if</span> <span class="token variable">$0</span> <span class="token operator">==</span> __FILE__-  <span class="token function">git</span> <span class="token operator">=</span> SimpleGit.new-  puts git.show<span class="token parameter variable">-end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该选项除了显示基本信息之外，还附带了每次提交的变化。 当进行代码审查，或者快速浏览某个搭档的提交所带来的变化的时候，这个参数就非常有用了。 你也可以为 <code>git log</code> 附带一系列的总结性选项。 比如你想看到每次提交的简略统计信息，可以使用 <code>--stat</code> 选项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--stat</span>commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Mon Mar <span class="token number">17</span> <span class="token number">21</span>:52:11 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    changed the version number Rakefile <span class="token operator">|</span> <span class="token number">2</span> +- <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Sat Mar <span class="token number">15</span> <span class="token number">16</span>:40:33 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    removed unnecessary <span class="token builtin class-name">test</span> lib/simplegit.rb <span class="token operator">|</span> <span class="token number">5</span> ----- <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">5</span> deletions<span class="token punctuation">(</span>-<span class="token punctuation">)</span>commit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Sat Mar <span class="token number">15</span> <span class="token number">10</span>:31:28 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    first commit README           <span class="token operator">|</span>  <span class="token number">6</span> ++++++ Rakefile         <span class="token operator">|</span> <span class="token number">23</span> +++++++++++++++++++++++ lib/simplegit.rb <span class="token operator">|</span> <span class="token number">25</span> +++++++++++++++++++++++++ <span class="token number">3</span> files changed, <span class="token number">54</span> insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>--stat</code> 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p><p>另一个非常有用的选项是 <code>--pretty</code>。 这个选项可以使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 <code>oneline</code> 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 选项，它们展示信息的格式基本一致，但是详尽程度不一：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>onelineca82a6dff817ec66f44342007202690a93763949 changed the version number085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary <span class="token builtin class-name">test</span>a11bef06a3f659402fe7563abf99ad00de2209e6 first commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最有意思的是 <code>format</code> ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>format:<span class="token string">"%h - %an, %ar : %s"</span>ca82a6d - Scott Chacon, <span class="token number">6</span> years ago <span class="token builtin class-name">:</span> changed the version number085bb3b - Scott Chacon, <span class="token number">6</span> years ago <span class="token builtin class-name">:</span> removed unnecessary <span class="token builtin class-name">test</span>a11bef0 - Scott Chacon, <span class="token number">6</span> years ago <span class="token builtin class-name">:</span> first commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><em>作者</em> 和 <em>提交者</em> 之间的差别：作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。</p><p>类似 <code>--since</code> 和 <code>--until</code> 这种按照时间作限制的选项很有用。 例如，下面的命令会列出最近两周的所有提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--since</span><span class="token operator">=</span><span class="token number">2</span>.weeks<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令可用的格式十分丰富——可以是类似 <code>"2008-01-15"</code> 的具体的某一天，也可以是类似 <code>"2 years 1 day 3 minutes ago"</code> 的相对日期。用 <code>--author</code> 选项显示指定作者的提交，用 <code>--grep</code> 选项搜索提交说明中的关键字。可以指定多个 <code>--author</code> 和 <code>--grep</code> 搜索条件，这样会只输出匹配 <strong>任意</strong> <code>--author</code> 模式和 <strong>任意</strong> <code>--grep</code> 模式的提交。然而，如果你添加了 <code>--all-match</code> 选项， 则只会输出匹配 <strong>所有</strong> <code>--grep</code> 模式的提交。</p><p>另一个非常有用的过滤器是 <code>-S</code>（俗称“pickaxe”选项，取“用鹤嘴锄在土里捡石头”之意）， 它接受一个字符串参数，并且只会显示那些添加或删除了该字符串的提交。 假设你想找出添加或删除了对某一个特定函数的引用的提交，可以调用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">-S</span> function_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后一个很实用的 <code>git log</code> 选项是路径（path）， 如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。 因为是放在最后位置上的选项，所以用两个短划线（–）隔开之前的选项和后面限定的路径名。</p><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p><strong>有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</strong></p><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令来重新提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">--amend</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。</p><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">'initial commit'</span>$ <span class="token function">git</span> <span class="token function">add</span> forgotten_file$ <span class="token function">git</span> commit <span class="token parameter variable">--amend</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p><p>当你在修补最后的提交时，与其说是修复旧提交，倒不如说是完全用一个 <strong>新的提交</strong> 替换旧的提交， 理解这一点非常重要。从效果上来说，就像是旧有的提交从未存在过一样，它并不会出现在仓库的历史中。修补提交最明显的价值是可以稍微改进你最后的提交。</p><h3 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h3><p>你已经修改了两个文件并且想要将它们作为两次独立的修改提交， 但是却意外地输入 <code>git add *</code> 暂存了它们两个。如何只取消暂存两个中的一个呢？可以使用 <code>git reset HEAD &lt;file&gt;…</code> 来取消暂存。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> reset HEAD CONTRIBUTING.mdUnstaged changes after reset:MCONTRIBUTING.md$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    renamed:    README.md -<span class="token operator">&gt;</span> READMEChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>CONTRIBUTING.md</code> 文件已经是修改未暂存的状态了。<code>git reset</code> 确实是个<strong>危险的命令</strong>，如果加上了 <code>--hard</code> 选项则更是如此。 <strong>然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。</strong></p><h3 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h3><p>如果你并不想保留对 <code>CONTRIBUTING.md</code> 文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？使用<code>git checkout -- CONTRIBUTING.md</code>命令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout -- CONTRIBUTING.md$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>    renamed:    README.md -<span class="token operator">&gt;</span> README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到那些修改已经被撤消了。</p><p>务必记得 <code>git checkout — &lt;file&gt;</code> 是一个<strong>危险的命令</strong>。 <strong>你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。</strong> 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</p><p>如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，通过分支保存进度通常是更好的做法。</p><p>在 Git 中任何 <strong>已提交</strong> 的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 <code>--amend</code> 选项覆盖的提交也可以恢复。 然而，<strong>任何你未提交的东西丢失后很可能再也找不到了。</strong></p><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。（你完全可以在一个“远程”仓库上工作，而实际上它在你本地的主机上。 词语“远程”未必表示仓库在网络或互联网上的其它位置，而只是表示它在别处。 在这样的远程仓库上工作，仍然需要和其它远程仓库上一样的标准推送、拉取和抓取操作。）</p><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/schacon/ticgitCloning into <span class="token string">'ticgit'</span><span class="token punctuation">..</span>.remote: Reusing existing pack: <span class="token number">1857</span>, done.remote: Total <span class="token number">1857</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>Receiving objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">1857</span>/1857<span class="token punctuation">)</span>, <span class="token number">374.35</span> KiB <span class="token operator">|</span> <span class="token number">268.00</span> KiB/s, done.Resolving deltas: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">772</span>/772<span class="token punctuation">)</span>, done.Checking connectivity<span class="token punctuation">..</span>. done.$ <span class="token builtin class-name">cd</span> ticgit$ <span class="token function">git</span> remoteorigin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote <span class="token parameter variable">-v</span>originhttps://github.com/schacon/ticgit <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>originhttps://github.com/schacon/ticgit <span class="token punctuation">(</span>push<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> grit$ <span class="token function">git</span> remote <span class="token parameter variable">-v</span>bakkdoor  https://github.com/bakkdoor/grit <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>bakkdoor  https://github.com/bakkdoor/grit <span class="token punctuation">(</span>push<span class="token punctuation">)</span>cho45     https://github.com/cho45/grit <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>cho45     https://github.com/cho45/grit <span class="token punctuation">(</span>push<span class="token punctuation">)</span>defunkt   https://github.com/defunkt/grit <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>defunkt   https://github.com/defunkt/grit <span class="token punctuation">(</span>push<span class="token punctuation">)</span>koke      git://github.com/koke/grit.git <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>koke      git://github.com/koke/grit.git <span class="token punctuation">(</span>push<span class="token punctuation">)</span>origin    git@github.com:mojombo/grit.git <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>origin    git@github.com:mojombo/grit.git <span class="token punctuation">(</span>push<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这表示我们能非常方便地拉取其它用户的贡献。我们还可以拥有向他们推送的权限。</p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>之前已经提到并展示了 <code>git clone</code> 命令是如何自行添加远程仓库的，这里将告诉你如何自己来添加它。 运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remoteorigin$ <span class="token function">git</span> remote <span class="token function">add</span> pb https://github.com/paulboone/ticgit$ <span class="token function">git</span> remote <span class="token parameter variable">-v</span>originhttps://github.com/schacon/ticgit <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>originhttps://github.com/schacon/ticgit <span class="token punctuation">(</span>push<span class="token punctuation">)</span>pbhttps://github.com/paulboone/ticgit <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>pbhttps://github.com/paulboone/ticgit <span class="token punctuation">(</span>push<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch pbremote: Counting objects: <span class="token number">43</span>, done.remote: Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">36</span>/36<span class="token punctuation">)</span>, done.remote: Total <span class="token number">43</span> <span class="token punctuation">(</span>delta <span class="token number">10</span><span class="token punctuation">)</span>, reused <span class="token number">31</span> <span class="token punctuation">(</span>delta <span class="token number">5</span><span class="token punctuation">)</span>Unpacking objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">43</span>/43<span class="token punctuation">)</span>, done.From https://github.com/paulboone/ticgit * <span class="token punctuation">[</span>new branch<span class="token punctuation">]</span>      master     -<span class="token operator">&gt;</span> pb/master * <span class="token punctuation">[</span>new branch<span class="token punctuation">]</span>      ticgit     -<span class="token operator">&gt;</span> pb/ticgit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到——你可以将它合并到自己的某个分支中， 或者如果你想要查看它的话，可以检出一个指向该点的本地分支。</p><h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><p>从远程仓库中获得数据，可以执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch <span class="token operator">&lt;</span>remote<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</strong></p><p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。<code>git fetch</code> 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p><p>如果你的当前分支设置了跟踪远程分支， 那么可以用 <code>git pull</code> 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，<code>git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 <code>master</code> 分支（或其它名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p><h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push &lt;remote&gt; &lt;branch&gt;</code>。 当你想要将 <code>master</code> 分支推送到 <code>origin</code> 服务器时（<strong>再次说明，克隆时通常会自动帮你设置好那两个名字</strong>）， 那么运行这个命令就可以将你所做的备份到服务器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 <strong>当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。</strong></p><h3 id="查看某个远程仓库"><a href="#查看某个远程仓库" class="headerlink" title="查看某个远程仓库"></a>查看某个远程仓库</h3><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show &lt;remote&gt;</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 <code>origin</code>，会得到像下面类似的信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote show origin* remote origin  Fetch URL: https://github.com/schacon/ticgit  Push  URL: https://github.com/schacon/ticgit  HEAD branch: master  Remote branches:    master                               tracked    dev-branch                           tracked  Local branch configured <span class="token keyword">for</span> <span class="token string">'git pull'</span><span class="token builtin class-name">:</span>    master merges with remote master  Local ref configured <span class="token keyword">for</span> <span class="token string">'git push'</span><span class="token builtin class-name">:</span>    master pushes to master <span class="token punctuation">(</span>up to <span class="token function">date</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 <code>master</code> 分支，并且如果运行 <code>git pull</code>， 就会抓取所有的远程引用，然后将远程 <code>master</code> 分支合并到本地 <code>master</code> 分支。 它也会列出拉取到的所有远程引用。</p><p>如果你是 Git 的重度使用者，那么还可以通过 <code>git remote show</code> 看到更多的信息。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote show origin* remote origin  URL: https://github.com/my-org/complex-project  Fetch URL: https://github.com/my-org/complex-project  Push  URL: https://github.com/my-org/complex-project  HEAD branch: master  Remote branches:    master                           tracked    dev-branch                       tracked    markdown-strip                   tracked    issue-43                         new <span class="token punctuation">(</span>next fetch will store <span class="token keyword">in</span> remotes/origin<span class="token punctuation">)</span>    issue-45                         new <span class="token punctuation">(</span>next fetch will store <span class="token keyword">in</span> remotes/origin<span class="token punctuation">)</span>    refs/remotes/origin/issue-11     stale <span class="token punctuation">(</span>use <span class="token string">'git remote prune'</span> to remove<span class="token punctuation">)</span>  Local branches configured <span class="token keyword">for</span> <span class="token string">'git pull'</span><span class="token builtin class-name">:</span>    dev-branch merges with remote dev-branch    master     merges with remote master  Local refs configured <span class="token keyword">for</span> <span class="token string">'git push'</span><span class="token builtin class-name">:</span>    dev-branch                     pushes to dev-branch                     <span class="token punctuation">(</span>up to <span class="token function">date</span><span class="token punctuation">)</span>    markdown-strip                 pushes to markdown-strip                 <span class="token punctuation">(</span>up to <span class="token function">date</span><span class="token punctuation">)</span>    master                         pushes to master                         <span class="token punctuation">(</span>up to <span class="token function">date</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个命令列出了当你在特定的分支上执行 <code>git push</code> 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了， 还有当你执行 <code>git pull</code> 时哪些本地分支可以与它跟踪的远程分支自动合并。</p><h3 id="远程仓库的重命名与移除"><a href="#远程仓库的重命名与移除" class="headerlink" title="远程仓库的重命名与移除"></a>远程仓库的重命名与移除</h3><p>你可以运行 <code>git remote rename</code> 来修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote <span class="token function">rename</span> pb paul$ <span class="token function">git</span> remoteoriginpaul<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p><p>如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了， 又或者某一个贡献者不再贡献了——可以使用 <code>git remote remove</code> 或 <code>git remote rm</code> ：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote remove paul$ <span class="token function">git</span> remoteorigin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>像其他版本控制系统（VCS）一样，Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ <code>v1.0</code> 、 <code>v2.0</code> 等等）。 如何列出已有的标签、如何创建和删除新的标签、以及不同类型的标签分别是什么。</p><h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><p>在 Git 中列出已有的标签非常简单，只需要输入 <code>git tag</code> （可带上可选的 <code>-l</code> 选项 <code>--list</code>）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tagv1.0v2.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你也可以按照特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag <span class="token parameter variable">-l</span> <span class="token string">"v1.8.5*"</span>v1.8.5v1.8.5-rc0v1.8.5-rc1v1.8.5-rc2v1.8.5-rc3v1.8.5.1v1.8.5.2v1.8.5.3v1.8.5.4v1.8.5.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>按照通配符列出标签需要</strong> <code>-l</code> <strong>或</strong> <code>--list</code> <strong>选项</strong>。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。</p><p>轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。</p><p>而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。</p><h3 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h3><p>在 Git 中创建附注标签十分简单。 最简单的方式是当你在运行 <code>tag</code> 命令时指定 <code>-a</code> 选项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag <span class="token parameter variable">-a</span> v1.4 <span class="token parameter variable">-m</span> <span class="token string">"my version 1.4"</span>$ <span class="token function">git</span> tagv0.1v1.3v1.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>-m</code> 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。</p><p>通过使用 <code>git show</code> 命令可以看到标签信息和与之对应的提交信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> show v1.4tag v1.4Tagger: Ben Straub <span class="token operator">&lt;</span>ben@straub.cc<span class="token operator">&gt;</span>Date:   Sat May <span class="token number">3</span> <span class="token number">20</span>:19:12 <span class="token number">2014</span> <span class="token parameter variable">-0700</span>my version <span class="token number">1.4</span>commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Mon Mar <span class="token number">17</span> <span class="token number">21</span>:52:11 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    changed the version number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p><h3 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h3><p>另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或 <code>-m</code> 选项，只需要提供标签名字：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag v1.4-lw$ <span class="token function">git</span> tagv0.1v1.3v1.4v1.4-lwv1.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时，如果在标签上运行 <code>git show</code>，你不会看到额外的标签信息。 命令只会显示出提交信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> show v1.4-lwcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Mon Mar <span class="token number">17</span> <span class="token number">21</span>:52:11 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    changed the version number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h3><p>你也可以对过去的提交打标签。 假设提交历史是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch <span class="token string">'experiment'</span>a6b4c97498bd301d84096da251c98a07c7723e65 beginning <span class="token function">write</span> support0d52aaab4479697da7686c15f77a3d64d9165190 one <span class="token function">more</span> thing6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch <span class="token string">'experiment'</span>0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit <span class="token keyword">function</span>4682c3261057305bdd616e23b64b0857d832627b added a todo <span class="token function">file</span>166ae0c4d3f420721acbb115cc33848dfcc2121a started <span class="token function">write</span> support9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag <span class="token parameter variable">-a</span> v1.2 9fceb02<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到你已经在那次提交上打上标签了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tagv0.1v1.2v1.3v1.4v1.4-lwv1.5$ <span class="token function">git</span> show v1.2tag v1.2Tagger: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Mon Feb <span class="token number">9</span> <span class="token number">15</span>:32:16 <span class="token number">2009</span> <span class="token parameter variable">-0800</span>version <span class="token number">1.2</span>commit 9fceb02d0ae598e95dc970b74767f19372d61af8Author: Magnus Chacon <span class="token operator">&lt;</span>mchacon@gee-mail.com<span class="token operator">&gt;</span>Date:   Sun Apr <span class="token number">27</span> <span class="token number">20</span>:43:35 <span class="token number">2008</span> <span class="token parameter variable">-0700</span>    updated rakefile<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h3><p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 <code>git push origin &lt;tagname&gt;</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin v1.5Counting objects: <span class="token number">14</span>, done.Delta compression using up to <span class="token number">8</span> threads.Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">12</span>/12<span class="token punctuation">)</span>, done.Writing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">14</span>/14<span class="token punctuation">)</span>, <span class="token number">2.05</span> KiB <span class="token operator">|</span> <span class="token number">0</span> bytes/s, done.Total <span class="token number">14</span> <span class="token punctuation">(</span>delta <span class="token number">3</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>To git@github.com:schacon/simplegit.git * <span class="token punctuation">[</span>new tag<span class="token punctuation">]</span>         v1.5 -<span class="token operator">&gt;</span> v1.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的 <code>git push</code> 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin <span class="token parameter variable">--tags</span>Counting objects: <span class="token number">1</span>, done.Writing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">1</span>/1<span class="token punctuation">)</span>, <span class="token number">160</span> bytes <span class="token operator">|</span> <span class="token number">0</span> bytes/s, done.Total <span class="token number">1</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>To git@github.com:schacon/simplegit.git * <span class="token punctuation">[</span>new tag<span class="token punctuation">]</span>         v1.4 -<span class="token operator">&gt;</span> v1.4 * <span class="token punctuation">[</span>new tag<span class="token punctuation">]</span>         v1.4-lw -<span class="token operator">&gt;</span> v1.4-lw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p><p>使用 <code>git push &lt;remote&gt; --tags</code> 推送标签并不会区分轻量标签和附注标签， 没有简单的选项能够让你只选择推送一种标签。</p><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p>要删除掉你本地仓库上的标签，可以使用命令 <code>git tag -d &lt;tagname&gt;</code>。 例如，可以使用以下命令删除一个轻量标签：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag <span class="token parameter variable">-d</span> v1.4-lwDeleted tag <span class="token string">'v1.4-lw'</span> <span class="token punctuation">(</span>was e7d5add<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 <code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code> 来更新你的远程仓库：</p><p>第一种变体是 <code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code> ：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin :refs/tags/v1.4-lwTo /git@github.com:schacon/simplegit.git - <span class="token punctuation">[</span>deleted<span class="token punctuation">]</span>         v1.4-lw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。</p><p>第二种更直观的删除远程标签的方式是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin <span class="token parameter variable">--delete</span> <span class="token operator">&lt;</span>tagname<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p>如果你想查看某个标签所指向的文件版本，可以使用 <code>git checkout</code> 命令， 虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout <span class="token number">2.0</span>.0Note: checking out <span class="token string">'2.0.0'</span><span class="token builtin class-name">.</span>You are <span class="token keyword">in</span> <span class="token string">'detached HEAD'</span> state. You can <span class="token function">look</span> around, <span class="token function">make</span> experimentalchanges and commit them, and you can discard any commits you <span class="token function">make</span> <span class="token keyword">in</span> thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you may<span class="token keyword">do</span> so <span class="token punctuation">(</span>now or later<span class="token punctuation">)</span> by using <span class="token parameter variable">-b</span> with the checkout <span class="token builtin class-name">command</span> again. Example:  <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> <span class="token operator">&lt;</span>new-branch<span class="token operator">&gt;</span>HEAD is now at 99ada87<span class="token punctuation">..</span>. Merge pull request <span class="token comment">#89 from schacon/appendix-final</span>$ <span class="token function">git</span> checkout <span class="token number">2.0</span>-beta-0.1Previous HEAD position was 99ada87<span class="token punctuation">..</span>. Merge pull request <span class="token comment">#89 from schacon/appendix-final</span>HEAD is now at df3f601<span class="token punctuation">..</span>. <span class="token function">add</span> atlas.json and cover image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> version2 v2.0.0Switched to a new branch <span class="token string">'version2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果在这之后又进行了一次提交，<code>version2</code> 分支就会因为这个改动向前移动， 此时它就会和 <code>v2.0.0</code> 标签稍微有些不同，这时就要当心了。</p><h3 id="git别名"><a href="#git别名" class="headerlink" title="git别名"></a>git别名</h3><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 <code>git config</code> 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.co checkout$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.br branch$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.ci commit$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.st status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这意味着，当要输入 <code>git commit</code> 时，只需要输入 <code>git ci</code>。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。</p><p>在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.unstage <span class="token string">'reset HEAD --'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会使下面的两个命令等价：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> unstage fileA$ <span class="token function">git</span> reset HEAD -- fileA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样看起来更清楚一些。 通常也会添加一个 <code>last</code> 命令，像这样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.last <span class="token string">'log -1 HEAD'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，可以轻松地看到最后一次提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> lastcommit 66938dae3329c7aebe598c2246a8e6af90d04646Author: Josh Goebel <span class="token operator">&lt;</span>dreamer3@example.com<span class="token operator">&gt;</span>Date:   Tue Aug <span class="token number">26</span> <span class="token number">19</span>:48:51 <span class="token number">2008</span> +0800    <span class="token builtin class-name">test</span> <span class="token keyword">for</span> current <span class="token function">head</span>    Signed-off-by: Scott Chacon <span class="token operator">&lt;</span>schacon@example.com<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 <code>!</code> 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 <code>git visual</code> 定义为 <code>gitk</code> 的别名：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.visual <span class="token string">'!gitk'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本控制与git(1)</title>
      <link href="/2025/02/23/1192c262.html"/>
      <url>/2025/02/23/1192c262.html</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="https://git-scm.com/book/zh/v2/%E3%80%82">https://git-scm.com/book/zh/v2/。</a></p><h2 id="版本控制（VCS，version-control-system）"><a href="#版本控制（VCS，version-control-system）" class="headerlink" title="版本控制（VCS，version control system）"></a>版本控制（VCS，version control system）</h2><h3 id="本地版本控制"><a href="#本地版本控制" class="headerlink" title="本地版本控制"></a>本地版本控制</h3><p>比较流行的一种是RCS，在硬盘上保存补丁集，通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p><h3 id="集中化版本控制系统"><a href="#集中化版本控制系统" class="headerlink" title="集中化版本控制系统"></a>集中化版本控制系统</h3><p>集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。这已经成为了版本控制的标准做法。</p><p>每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>但是缺点在于，如果中央服务器出现损坏或者宕机，那么所有使用者在这段时间都无法工作甚至使其此前的所有版本记录。</p><h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>分布式版本控制系统（Distributed Version Control System，简称 DVCS）为了解决集中化版本的缺陷而诞生。在这种系统中客户端不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录，这样任何一处服务器发生故障，其他客户端都可以进行版本回溯。</p><p>许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。</p><h2 id="git的核心理念"><a href="#git的核心理念" class="headerlink" title="git的核心理念"></a>git的核心理念</h2><h3 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h3><p>其它大部分系统以文件变更列表的形式存储信息，也就是存储不同版本之间的差异。</p><p><img src="/pics/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8Egit/deltas.png"></p><p>git将数据看作是对小型文件系统的一系列快照。在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>，git本身更像是一个小型的文件系统。</p><p><img src="/pics/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8Egit/snapshots.png"></p><h3 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h3><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。</p><p>如果你想查看当前版本与一个月前的版本之间引入的修改， Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p><p>这意味着在离线情况下也可以进行编辑和提交操作，而等到有网络之后再进行上传。</p><h3 id="git保证完整性"><a href="#git保证完整性" class="headerlink" title="git保证完整性"></a>git保证完整性</h3><p>Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p><p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：</p><pre class="line-numbers language-none"><code class="language-none">24b9da6552252987aa493b52f8696cd6d3b00373<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p><h3 id="git一般只添加数据"><a href="#git一般只添加数据" class="headerlink" title="git一般只添加数据"></a>git一般只添加数据</h3><p>你执行的 Git 操作，几乎只往 Git 数据库中 <strong>添加</strong> 数据。 你很难使用 Git 从数据库中删除数据，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作。未提交更新时有可能丢失或弄乱修改的内容。但是一旦你提交快照到 Git 中， 就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p><h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><p>Git 有三种状态，你的文件可能处于其中之一： <strong>已提交（committed）</strong>、<strong>已修改（modified）</strong> 和 <strong>已暂存（staged）</strong>。</p><ul><li>已修改表示修改了文件，但还没保存到数据库中。</li><li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li><li>已提交表示数据已经安全地保存在本地数据库中。</li></ul><p><img src="/pics/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8Egit/areas.png"></p><p>工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p>暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。</p><p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。</p><p>基本的 Git 工作流程如下：</p><ol><li>在工作区中修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li></ol><h2 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h2><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p><ol><li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 <code>git config</code> 时带上 <code>--system</code> 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 你可以传递 <code>--global</code> 选项让 Git 读写此文件，这会对你系统上 <strong>所有</strong> 的仓库生效。</li><li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（即 <code>.git/config</code>）：针对该仓库。 你可以传递 <code>--local</code> 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）</li></ol><p>每一个级别会覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p><p>若你使用 Git 时需要获取帮助，有三种等价的方法可以找到 Git 命令的综合手册（manpage）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token builtin class-name">help</span> <span class="token operator">&lt;</span>verb<span class="token operator">&gt;</span>$ <span class="token function">git</span> <span class="token operator">&lt;</span>verb<span class="token operator">&gt;</span> <span class="token parameter variable">--help</span>$ <span class="token function">man</span> git-<span class="token operator">&lt;</span>verb<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此外，如果你不需要全面的手册，只需要可用选项的快速参考，那么可以用 <code>-h</code> 选项获得更简明的 “help” 输出。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习入门知识</title>
      <link href="/2025/02/14/89184582.html"/>
      <url>/2025/02/14/89184582.html</url>
      
        <content type="html"><![CDATA[<p>本文参考<a href="https://mofanpy.com/tutorials/machine-learning/reinforcement-learning/">莫烦python-强化学习</a>。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一种对强化学习的直观理解就是通过不断地尝试，从实践中学习，最终找到某种规律，得到一个训练后的agent。从实践中学习需要一个老师，这个老师会根据agent的行为进行打分，agent的训练过程实际上就是记住了各种行为对应的打分。</p><p>监督学习中使用的数据是同时包含数据和正确标签的，而强化学习可以认为老师给行为打的分数就是某种标签。</p><h2 id="强化学习分类"><a href="#强化学习分类" class="headerlink" title="强化学习分类"></a>强化学习分类</h2><h3 id="model-free和model-based"><a href="#model-free和model-based" class="headerlink" title="model-free和model-based"></a>model-free和model-based</h3><p>在model-free的方法中，都是直接从环境中得到反馈然后学习，比如Q Learning，Sarsa，Policy Gradients。而model-based则增加了一个程序，为真实世界增加了建模模型来进行模拟，这种方法可以模拟一些真实场景中不存在的情况，并且这种训练出来的RL模型具有一定想象力，可以预判接下来要发生的所有情况来进行行为选择。</p><h3 id="基于概率和基于价值"><a href="#基于概率和基于价值" class="headerlink" title="基于概率和基于价值"></a>基于概率和基于价值</h3><p>基于概率的模型可以通过感官分析下一步要采取的各种动作的概率，然后根据概率采取行动，比如Policy Gradients。而基于价值的模型则是会直接选择价值最高的动作，比如Q Learning，Sarsa。还有一种结合二者的方法，叫做Actor-Critic，actor 会基于概率做出动作, 而 critic 会对做出的动作给出动作的价值, 这样就在原有的 policy gradients 上加速了学习过程。</p><h3 id="回合更新和单步更新"><a href="#回合更新和单步更新" class="headerlink" title="回合更新和单步更新"></a>回合更新和单步更新</h3><p><img src="/pics/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/RLmtd3.png"></p><p>回合更新是在游戏结束后再总结这一回合中所有转折点，进行行为准则更新。而单步更新则是在游戏进行中每一步都在更新，不需要等到游戏结束。</p><p>Monte-carlo learning 和基础版的 policy gradients 等 都是回合更新制, Q learning, Sarsa，升级版的 policy gradients 等都是单步更新制。因为单步更新更有效率，所以现在大多方法都是基于单步更新。比如有的强化学习问题并不属于回合问题。</p><h3 id="在线学习和离线学习"><a href="#在线学习和离线学习" class="headerlink" title="在线学习和离线学习"></a>在线学习和离线学习</h3><p>在线学习就是指必须本人在场，边玩边学。离线学习则是可以选择自己玩，也可以选择看着别人玩，通过别人玩的记录来学习自己的行为准则。</p><p>最典型的在线学习就是 Sarsa 了，还有一种优化 Sarsa 的算法，叫做 Sarsa lambda，最典型的离线学习就是 Q learning，后来人也根据离线学习的属性，开发了更强大的算法，比如让计算机学会玩电动的 Deep-Q-Network。</p><h2 id="几种算法简介"><a href="#几种算法简介" class="headerlink" title="几种算法简介"></a>几种算法简介</h2><h3 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q-Learning"></a>Q-Learning</h3><p>$s$为状态，$a$为行动，$Q(s,a)$为状态$s$下选择行动$a$的收益，$R$为处于某个状态下的收益。在某一个当前状态$s_t$下，单次执行可以套用如下公式：</p><ul><li>选择收益$Q(s_t,a_t)$最高的行动$a_t$，这样行动后的下一步状态是$s_{t+1}$</li><li>更新收益$Q^{new}(s_t,a_t)\leftarrow(1-\alpha)Q(s_t,a_t)+\alpha(R_{t+1}+\gamma\max_a Q(s_{t+1},a))$</li></ul><p>要注意的是Q Learning说到并不一定做到，所以也被叫做off-policy，离线学习。</p><h3 id="Sarsa"><a href="#Sarsa" class="headerlink" title="Sarsa"></a>Sarsa</h3><p><img src="/pics/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/s4.png"></p><p>Sarsa和Q Learning的主要步骤很像，但是有一个核心的步骤是不同的，那就是它说到做到，在更新Q值的过程中并不一定会选择最大Q对应的步行动$a$作为更新，而是采用某种与Q相关的策略。</p><p>Q Learning的机器人永远会选择最近的一条通向成功的路，即使可能很危险，而Sarsa则比较保守，希望能够离危险远一些，拿到宝箱是次要的。</p><p>【Epsilon greedy 是用在决策上的一种策略，比如 epsilon = 0.9 时，就说明有90% 的情况我会按照 Q 表的最优值选择行为，10% 的时间使用随机选行为】</p><h4 id="Sarsa-lambda"><a href="#Sarsa-lambda" class="headerlink" title="Sarsa(lambda)"></a>Sarsa(lambda)</h4><p><img src="/pics/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/3-3-1.png"></p><p>Sarsa是一种单步更新方法，这可以被成为Sarsa(0)，因为它在走完当前这一步之后直接更新行为准则，而假如走完这步再走一步再更新，那么就可以称为Sarsa(1)。以此类推，这就是Sarsa(lambda)。</p><p>“虽然我们每一步都在更新，但是在没有获取宝藏的时候，我们现在站着的这一步也没有得到任何更新，也就是直到获取宝藏时，我们才为获取到宝藏的上一步更新为：这一步很好，和获取宝藏是有关联的，而之前为了获取宝藏所走的所有步都被认为和获取宝藏没关系。回合更新虽然我要等到这回合结束，才开始对本回合所经历的所有步都添加更新，但是这所有的步都是和宝藏有关系的，都是为了得到宝藏需要学习的步，所以每一个脚印在下回合被选则的几率又高了一些。在这种角度来看，回合更新似乎会有效率一些。”</p><p>”其实 lambda 就是一个衰变值，他可以让你知道离奖励越远的步可能并不是让你最快拿到奖励的步，所以我们想象我们站在宝藏的位置，回头看看我们走过的寻宝之路，离宝藏越近的脚印越看得清，远处的脚印太渺小，我们都很难看清，那我们就索性记下离宝藏越近的脚印越重要，越需要被好好的更新。和之前我们提到过的 奖励衰减值 gamma 一样，lambda 是脚步衰减值，都是一个在 0 和 1 之间的数。“</p><h3 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h3><p>对于某些问题，是难以建立一个包含所有状态和行动的Q值表的，因为状态过于多了，比如围棋，因此不妨直接使用神经网络来拟合这个Q值表，其可以接受状态和行动并输出对应的Q值。</p><h3 id="Policy-Gradient"><a href="#Policy-Gradient" class="headerlink" title="Policy Gradient"></a>Policy Gradient</h3><h3 id="Actor-Critic"><a href="#Actor-Critic" class="headerlink" title="Actor Critic"></a>Actor Critic</h3>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parallel Computing (2)</title>
      <link href="/2025/02/12/81b3bf3b.html"/>
      <url>/2025/02/12/81b3bf3b.html</url>
      
        <content type="html"><![CDATA[<h2 id="对多级缓存的认识"><a href="#对多级缓存的认识" class="headerlink" title="对多级缓存的认识"></a>对多级缓存的认识</h2><p>多种miss：</p><ul><li>cold miss</li><li>conflict miss</li><li>capacity miss</li></ul><p><img src="/pics/parallel-compute2/slide_018.jpg" alt="slide_018"></p><h2 id="多种并行思路"><a href="#多种并行思路" class="headerlink" title="多种并行思路"></a>多种并行思路</h2><p>在本次课程中，除开上一次课程介绍的超标量（指令级别并行），又介绍了多种并行处理器思路来提升吞吐量（throughput），考虑到</p><ul><li>并行执行</li><li>访问存储器的延迟（latency）</li></ul><h3 id="超标量（super-scalar）"><a href="#超标量（super-scalar）" class="headerlink" title="超标量（super scalar）"></a>超标量（super scalar）</h3><p>对于同一个程序，可以同时抓取预先编译好的多个可并行指令进行执行。</p><p><img src="/pics/parallel-compute2/slide_024.jpg" alt="slide_024"></p><p>程序中的并行是由硬件自动发现的。</p><h3 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h3><p>在还没出现多核处理器的时候，人们设计CPU往往致力于增加更多的模块来让单条指令执行地更快。</p><p><img src="/pics/parallel-compute2/slide_025.jpg" alt="slide_025"></p><p>但是通过删去这些额外的模块，实际上可以实现多个核的处理器（单核的性能比原来要差）。</p><p><img src="/pics/parallel-compute2/slide_027.jpg" alt="slide_027"></p><p>这样通过在程序中定义多个线程，就可以比较充分地利用两个核的性能。程序示意图如下所示：</p><p><img src="/pics/parallel-compute2/slide_029.jpg" alt="slide_029"></p><p><img src="/pics/parallel-compute2/slide_030.jpg" alt="slide_030"></p><p>现代多核处理器的例子：</p><p><img src="/pics/parallel-compute2/slide_033.jpg" alt="slide_033"></p><p><img src="/pics/parallel-compute2/slide_034.jpg" alt="slide_034"></p><h3 id="单指令多数据流（SIMD）"><a href="#单指令多数据流（SIMD）" class="headerlink" title="单指令多数据流（SIMD）"></a>单指令多数据流（SIMD）</h3><p>single instruction, multiple data。</p><p>通过引入更多的ALU（计算单元），使得可以在同一时间对多个数据进行相同的运算操作。</p><p><img src="/pics/parallel-compute2/slide_037.jpg" alt="slide_037"></p><p>如上架构可以执行如下的数据并行程序：</p><p><img src="/pics/parallel-compute2/slide_039.jpg" alt="slide_039"></p><p><img src="/pics/parallel-compute2/slide_030.jpg" alt="slide_030"></p><p>【注意上述第二个程序既可以被多核处理器处理也可以被SIMD处理】向量化是由编译器实现（explicit）或者在runtime时由硬件实现（implicit）。</p><h4 id="一些行话"><a href="#一些行话" class="headerlink" title="一些行话"></a>一些行话</h4><ul><li>指令流一致性、相干性（coherence）<ul><li>相同指令可以同时作用于多个数据</li><li>一致执行对于SIMD来说是必要的</li><li>一致执行对于多核并行并不是必要的</li></ul></li><li>差异执行（divergent）<ul><li>指令流缺乏一致性</li></ul></li></ul><p><img src="/pics/parallel-compute2/slide_049.jpg" alt="slide_049"></p><p><img src="/pics/parallel-compute2/slide_050.jpg" alt="slide_050"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="/pics/parallel-compute2/slide_053.jpg" alt="slide_053"></p><p><img src="/pics/parallel-compute2/slide_054.jpg" alt="slide_054"></p><h2 id="访问存储的加速"><a href="#访问存储的加速" class="headerlink" title="访问存储的加速"></a>访问存储的加速</h2><p><img src="/pics/parallel-compute2/slide_057.jpg" alt="slide_057"></p><h3 id="数据预加载"><a href="#数据预加载" class="headerlink" title="数据预加载"></a>数据预加载</h3><p>目前有一些现代CPU架构，其可以在使用到数据前自动地进行分析，并提前加载数据，从而减少stall，但是错误估计实际上会降低性能。</p><h3 id="多线程减少stall"><a href="#多线程减少stall" class="headerlink" title="多线程减少stall"></a>多线程减少stall</h3><p>在同一个核上interleave（交织）多个线程来提升利用率。</p><p><img src="/pics/parallel-compute2/slide_066.jpg" alt="slide_066"></p><p>执行单个线程的时间实际上可能仍然很长，但是多个线程总体执行时间相较于串行执行变少了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并行计算 </tag>
            
            <tag> CS149 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parallel Computing (1)</title>
      <link href="/2025/02/12/aa9eecf8.html"/>
      <url>/2025/02/12/aa9eecf8.html</url>
      
        <content type="html"><![CDATA[<h2 id="课程核心主题"><a href="#课程核心主题" class="headerlink" title="课程核心主题"></a>课程核心主题</h2><p>【课程前置：计算机组成相关课程】</p><h3 id="设计并编写真的能够加速的并行程序"><a href="#设计并编写真的能够加速的并行程序" class="headerlink" title="设计并编写真的能够加速的并行程序"></a>设计并编写真的能够加速的并行程序</h3><p><strong>并行思维</strong>：</p><ol><li>将工作分解为多个块，使得这些块可以安全地并行执行</li><li>将每块工作分配给处理器</li><li>适当地规划不同处理器之间的交流和同步问题，保证这些问题不会限制加速比</li></ol><p><strong>对上述并行思维各项任务的抽象（架构）</strong>：使用现有并行编程语言进行编程</p><h3 id="并行计算机硬件的实现：并行计算机如何工作"><a href="#并行计算机硬件的实现：并行计算机如何工作" class="headerlink" title="并行计算机硬件的实现：并行计算机如何工作"></a>并行计算机硬件的实现：并行计算机如何工作</h3><p><strong>可以高效实现程序抽象的架构</strong>：</p><ul><li>实现的性能特征</li><li>设计的trade-off：性能，便利，能耗</li></ul><p><strong>为什么需要了解硬件</strong>：</p><ul><li>计算机的设计架构对于程序编写十分重要</li><li>效率和性能十分重要</li></ul><h3 id="关注效率"><a href="#关注效率" class="headerlink" title="关注效率"></a>关注效率</h3><p><strong>快速并不意味着高效率！</strong></p><p>使用一个具有10个处理器的计算机，但是仅仅实现了2倍的加速比，这显然是不行的。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>电脑程序是一系列需要执行的指令。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>指令是处理器需要处理的操作。执行指令实际上修改了电脑的状态，所谓状态就是指存储在电脑中的数据，这些数据处于寄存器或者存储器中。</p><h3 id="指令级别并行"><a href="#指令级别并行" class="headerlink" title="指令级别并行"></a>指令级别并行</h3><p><strong>instruction level parallelism</strong>（ILP）：构建</p><h3 id="寄存器-缓存-存储器多级结构"><a href="#寄存器-缓存-存储器多级结构" class="headerlink" title="寄存器-缓存-存储器多级结构"></a>寄存器-缓存-存储器多级结构</h3>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并行计算 </tag>
            
            <tag> CS149 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能计算系统第1章-概述</title>
      <link href="/2025/02/11/4cc7c60c.html"/>
      <url>/2025/02/11/4cc7c60c.html</url>
      
        <content type="html"><![CDATA[<h2 id="三个流派"><a href="#三个流派" class="headerlink" title="三个流派"></a>三个流派</h2><ul><li>行为主义：基于控制论，构建感知-动作型控制系统，类似于小脑（强化学习）</li><li>符号主义：基于符号逻辑的方法，用逻辑表示知识和求解方法</li><li>连接主义：基于大脑中神经元细胞连接的计算模型，用人工神经网络来拟合智能行为</li></ul><p>tips：通过核心例子或观点将文章内容在introduction中串联起来，保证审稿人在前期就可以很快理解文章内容。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missing-semester(3)-vim</title>
      <link href="/2025/02/09/86d7b9fc.html"/>
      <url>/2025/02/09/86d7b9fc.html</url>
      
        <content type="html"><![CDATA[<p>本文参考<a href="https://imageslr.com/2021/vim.html">💻【Linux】Vim 入门笔记</a>，仅供自己查阅使用</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>vim编辑器是一种多模态编辑器，其允许用户切换不同的模式来进行不同的编辑任务：</p><ul><li>normal：最初始的模式，主要用于查询和移动</li><li>insert：<code>i</code></li><li>replace：<code>r</code></li><li>visual：<code>v</code></li><li>visual line：<code>shift-v</code></li><li>visual block：<code>ctrl-v</code></li><li>command line：<code>:</code></li></ul><h3 id="buffer-window-tab"><a href="#buffer-window-tab" class="headerlink" title="buffer, window, tab"></a>buffer, window, tab</h3><p>每一个buffer对应一个文件，一个window可以显示一个buffer（多个window可以对应同一个buffer），每一个tab可以打开多个window。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p><code>:</code>后输入命令</p><h3 id="退出vim"><a href="#退出vim" class="headerlink" title="退出vim"></a>退出vim</h3><ul><li><code>:q</code>或<code>:quit</code>：退出当前tab中所在window，直到最后一个window则退出tab</li><li><code>:q!</code>：退出并丢弃已有操作</li><li><code>:wq</code>：保存更改（write）并退出（quit）</li><li><code>ZZ</code>：等价于<code>:wq</code></li></ul><h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><ul><li><code>:w</code>：保存更改</li><li><code>:w &lt;filename&gt;</code>：将当前内容保存到新的文件中</li></ul><h3 id="M-基本移动"><a href="#M-基本移动" class="headerlink" title="[M]基本移动"></a>[M]基本移动</h3><p>使用<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>而不是左下右上的方向键</p><h3 id="M-前进到第一行或最后一行"><a href="#M-前进到第一行或最后一行" class="headerlink" title="[M]前进到第一行或最后一行"></a>[M]前进到第一行或最后一行</h3><ul><li><code>gg</code>：前往第一行</li><li><code>1G</code>：同<code>gg</code></li><li><code>G</code>：前往最后一行</li></ul><h3 id="M-前往第n行"><a href="#M-前往第n行" class="headerlink" title="[M]前往第n行"></a>[M]前往第n行</h3><ul><li><code>nG</code>：前往第n行，可以在标准模式下使用<code>set number</code>来显示行号</li><li><code>:n</code>：同样前往第n行</li></ul><h3 id="M-向右移动一个单词"><a href="#M-向右移动一个单词" class="headerlink" title="[M]向右移动一个单词"></a>[M]向右移动一个单词</h3><ul><li><code>w</code>：向右移动一个单词，光标处于首字符</li><li><code>e</code>：向右移动一个单词，光标落在当前单词的最后一个字符</li></ul><p>注意此处<strong>单词</strong>的定义是<strong>连续的「数字+字母+下划线」</strong>，或者<strong>连续的「特殊字符」</strong>。<code>hello, world!!!</code> 里包含 <code>hello</code>、<code>,</code>、<code>world</code> 和 <code>!!!</code> 四个单词。</p><ul><li><code>W</code>：向右移动一个<strong>连续的「非空字符」</strong>，光标处于首字符</li><li><code>E</code>：向右移动一个<strong>连续的「非空字符」</strong>，光标落在当前单词的最后一个字符</li></ul><h3 id="M-向左移动一个单词"><a href="#M-向左移动一个单词" class="headerlink" title="[M]向左移动一个单词"></a>[M]向左移动一个单词</h3><ul><li><code>b</code>：向左移动到前一个单词的首字符</li><li><code>ge</code>：向左移动到前一个单词的末尾</li><li><code>B</code>：向左移动一个<strong>连续的「非空字符」</strong></li><li><code>gE</code>：向左移动一个<strong>连续的「非空字符」</strong>，到末尾</li></ul><h3 id="M-前往当前行的开头和末尾字符"><a href="#M-前往当前行的开头和末尾字符" class="headerlink" title="[M]前往当前行的开头和末尾字符"></a>[M]前往当前行的开头和末尾字符</h3><ul><li><code>0</code>：前往开头</li><li><code>$</code>：前往末尾</li><li><code>_</code>：前往第一个非空字符（编写python等缩进代码时很有用）</li><li><code>^</code>：与<code>_</code>等价</li></ul><h3 id="E-删除字符"><a href="#E-删除字符" class="headerlink" title="[E]删除字符"></a>[E]删除字符</h3><ul><li><code>x</code>：删除当前字符</li><li><code>X</code>：删除前一个字符</li></ul><h3 id="E-删除单词"><a href="#E-删除单词" class="headerlink" title="[E]删除单词"></a>[E]删除单词</h3><ul><li><code>dw</code>：删除单词</li><li><code>dW</code>：删除下一个空格前的单词</li></ul><h3 id="E-删除当前行"><a href="#E-删除当前行" class="headerlink" title="[E]删除当前行"></a>[E]删除当前行</h3><ul><li><code>dd</code></li></ul><h3 id="E-在当前位置插入"><a href="#E-在当前位置插入" class="headerlink" title="[E]在当前位置插入"></a>[E]在当前位置插入</h3><ul><li><code>i</code>：在当前位置前面插入（insert）</li><li><code>a</code>：在当前位置后面插入（append）</li></ul><h3 id="E-在当前行开头或末尾插入"><a href="#E-在当前行开头或末尾插入" class="headerlink" title="[E]在当前行开头或末尾插入"></a>[E]在当前行开头或末尾插入</h3><ul><li><code>I</code>：在当前行开头插入</li><li><code>A</code>：在当前行末尾插入</li></ul><h3 id="E-在当前行上或下插入新的行"><a href="#E-在当前行上或下插入新的行" class="headerlink" title="[E]在当前行上或下插入新的行"></a>[E]在当前行上或下插入新的行</h3><ul><li><code>o</code>：在上面插入新的行</li><li><code>O</code>：在下面插入新的行</li></ul><h3 id="E-改变大小写"><a href="#E-改变大小写" class="headerlink" title="[E]改变大小写"></a>[E]改变大小写</h3><ul><li><code>~</code>：将光标下的字母改变大小写</li><li><code>gu&lt;motion&gt;</code>：指定范围的字母变成小写，比如 <code>guw</code> 是后一个单词全变成小写，<code>guj</code> 是当前整行改成小写</li><li><code>gU&lt;motion&gt;</code>：指定范围的字母变成大写</li><li><code>guu</code>：将当前行的字母改成小写</li><li><code>gUU</code>：将当前行的字母改成大写</li><li><code>guiw</code>：将光标所在的单词改成小写</li></ul><h3 id="F-移动到写一个指定字符"><a href="#F-移动到写一个指定字符" class="headerlink" title="[F]移动到写一个指定字符"></a>[F]移动到写一个指定字符</h3><ul><li><code>f&lt;target&gt;</code>：移动到下一个<code>&lt;target&gt;</code>出现的位置，比如<code>ft</code>就是移动到下一个<code>t</code>出现的位置</li><li><code>F&lt;target&gt;</code>：移动到前一个<code>&lt;target&gt;</code>出现的位置</li><li><code>t&lt;target&gt;</code>：类似于<code>f</code>，但是会移动到下一个指定字符之前</li><li><code>T&lt;target&gt;</code>：类似于<code>F</code>，但是会移动到前一个指定字符之后</li></ul><h3 id="E-撤销或重做"><a href="#E-撤销或重做" class="headerlink" title="[E]撤销或重做"></a>[E]撤销或重做</h3><ul><li><code>u</code>：撤销（undo）</li><li><code>&lt;ctrl&gt;+r</code>：重做（redo）</li></ul><h2 id="一些模式"><a href="#一些模式" class="headerlink" title="一些模式"></a>一些模式</h2><h3 id="重复n次操作"><a href="#重复n次操作" class="headerlink" title="重复n次操作"></a>重复n次操作</h3><p><code>n&lt;action&gt;</code>，重复n次<code>&lt;action&gt;</code>操作</p><h3 id="操作任意范围"><a href="#操作任意范围" class="headerlink" title="操作任意范围"></a>操作任意范围</h3><p><code>&lt;verb&gt;&lt;motion&gt;</code>，任意的操作<code>&lt;verb&gt;</code>都可以和范围<code>&lt;motion&gt;</code>拼接，使得指定一个范围进行操作。<code>w</code> 是跳到下一个单词的开头，那么 <code>dw</code> 就是删除到下一个单词的开头。</p><p>大部分命令都支持 <code>&lt;verb&gt;&lt;n&gt;&lt;motion&gt;</code> 和 <code>&lt;n&gt;&lt;verb&gt;&lt;motion&gt;</code> 两种模式，比如 <code>d2w</code> 和 <code>2dw</code> 都是删除后两个单词。</p><h3 id="命令大小写"><a href="#命令大小写" class="headerlink" title="命令大小写"></a>命令大小写</h3><p>不同的方向：</p><ul><li><code>x</code> 向右、<code>X</code> 向左</li><li><code>p</code> 向下、<code>P</code> 向上</li><li><code>o</code> 向下、<code>O</code> 向上</li><li><code>f</code> 向右、<code>F</code> 向左</li></ul><p>更严格的条件：</p><ul><li><code>w</code> 将特殊字符作为独立单词，<code>W</code> 只将空格作为单词分隔符</li><li><code>e</code> / <code>E</code>、<code>b</code> / <code>B</code> 同理</li></ul><p>更大的范围：</p><ul><li><code>a</code> 在当前位置后面插入、<code>A</code> 在当前行末尾插入</li><li><code>i</code> 在当前位置前插入、<code>I</code> 在当前行开始插入</li><li><code>d</code> 删除一个范围、<code>D</code> 删除到行末尾</li><li><code>c</code> 删除一个范围、<code>C</code> 删除到行末尾，并进入编辑模式</li><li><code>s</code> 删除当前字符，并进入编辑模式；<code>S</code> 删除当前整行，并进入编辑模式</li></ul><p>连续操作：</p><ul><li><code>r</code> 替换一个字符、<code>R</code> 连续替换多个字符直到按下 <code>&lt;Esc&gt;</code></li></ul><h3 id="两个字母重复"><a href="#两个字母重复" class="headerlink" title="两个字母重复"></a>两个字母重复</h3><p>两个 verb 字母重复，表示对当前整行操作：</p><ul><li><code>dd</code>：删除整行</li><li><code>cc</code>：删除整行，并进入编辑模式</li><li><code>yy</code>：复制整行</li><li><code>guu</code>：当前整行变成小写</li><li><code>gUU</code>：当前整行变成大写</li></ul><h3 id="重复上次操作"><a href="#重复上次操作" class="headerlink" title="重复上次操作"></a>重复上次操作</h3><ul><li><code>.</code>：重复上次的编辑操作</li><li><code>,</code>或<code>;</code>：重复当前行内的上一次 / 下一次 <code>f</code> 查找</li><li><code>n</code>或<code>N</code>：按 <code>/bar&lt;Enter&gt;</code> 搜索 <code>bar</code> 字符串后，按 <code>n</code> 可以查找下一个，按 <code>N</code> 查找上一个</li></ul><h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><h3 id="E-替换一个字符"><a href="#E-替换一个字符" class="headerlink" title="[E]替换一个字符"></a>[E]替换一个字符</h3><p><code>r</code>：再按下任意键，替换（replace）当前字符，等同于 <code>x</code> + <code>i</code>。</p><h3 id="E-替换连续多个字符"><a href="#E-替换连续多个字符" class="headerlink" title="[E]替换连续多个字符"></a>[E]替换连续多个字符</h3><p><code>R</code>：替换连续的多个字符，按下 <code>&lt;Esc&gt;</code> 可以退出替换模式。</p><h3 id="E-更改一个范围的内容"><a href="#E-更改一个范围的内容" class="headerlink" title="[E]更改一个范围的内容"></a>[E]更改一个范围的内容</h3><p><code>c</code>相当于将删除和进入编辑模式合二为一（change）。</p><ul><li><code>cw</code>：更改下一个单词，等同于<code>dw</code>+<code>i</code></li></ul><h3 id="E-删除当前字符并进入编辑模式"><a href="#E-删除当前字符并进入编辑模式" class="headerlink" title="[E]删除当前字符并进入编辑模式"></a>[E]删除当前字符并进入编辑模式</h3><p><code>s</code>等价于<code>x</code>+<code>i</code>。</p><h3 id="E-删除当前整行并进入编辑模式"><a href="#E-删除当前整行并进入编辑模式" class="headerlink" title="[E]删除当前整行并进入编辑模式"></a>[E]删除当前整行并进入编辑模式</h3><p><code>S</code>等价于<code>dd</code>+<code>o</code>。也可以用<code>cc</code>。</p><h3 id="E-从当前位置开始向右删除整行"><a href="#E-从当前位置开始向右删除整行" class="headerlink" title="[E]从当前位置开始向右删除整行"></a>[E]从当前位置开始向右删除整行</h3><p><code>D</code>等价于<code>d$</code>。</p><h3 id="E-从当前位置开始向右删除整行并进入编辑模式"><a href="#E-从当前位置开始向右删除整行并进入编辑模式" class="headerlink" title="[E]从当前位置开始向右删除整行并进入编辑模式"></a>[E]从当前位置开始向右删除整行并进入编辑模式</h3><p><code>C</code>等价于<code>c$</code>，或者<code>d$</code>+<code>a</code>，或者<code>D</code>+<code>a</code>。</p><h3 id="V-可视模式选择内容"><a href="#V-可视模式选择内容" class="headerlink" title="[V]可视模式选择内容"></a>[V]可视模式选择内容</h3><p>按下 <code>v</code> 进入可视模式（visual mode），然后移动光标以选择文本。可以针对选中的文本执行任意操作 (verb)，比如</p><ul><li>按下 <code>y</code> 可以复制选中的文本，再移动到别的位置按下 <code>p</code> 粘贴这些文本</li><li>按下 <code>d</code> 可以删除选中的文本</li></ul><p>按下 <code>ctrl + v </code>可以进入 Visual Block Mode，选择一个矩形块里的内容。</p><p>按下大写 <code>V</code> 可以选中整行。常见的使用技巧：</p><ul><li>按 <code>V</code> 选中整行，按 <code>j</code> 向下选中多行，然后 <code>y</code> 复制。</li><li>按 <code>V</code> 选中整行，按 <code>j</code> 向下选中多行，按 <code>&lt;</code> 向左缩进，按 <code>.</code> 继续缩进。</li><li>按 <code>V</code> 选中整行，按 <code>j</code> 向下选中多行，按 <code>=</code> 格式化。</li></ul><h3 id="复制单词"><a href="#复制单词" class="headerlink" title="复制单词"></a>复制单词</h3><p><code>y</code>可以进行复制（yank）。</p><ul><li><code>yw</code>：复制下一个单词</li></ul><p><code>y</code>和<code>c</code>、<code>d</code>一样可以和光标移动操作符相结合。</p><h3 id="复制当前行"><a href="#复制当前行" class="headerlink" title="复制当前行"></a>复制当前行</h3><ul><li><code>yy</code>：复制当前行</li><li><code>nyy</code>：复制当前行向下的n行，包括当前行</li><li><code>ynj</code>：同<code>nyy</code></li></ul><h3 id="粘贴到下一行或上一行"><a href="#粘贴到下一行或上一行" class="headerlink" title="粘贴到下一行或上一行"></a>粘贴到下一行或上一行</h3><ul><li><code>p</code>：粘贴复制内容到目标位置，使用<code>dd</code>删除某一行后，也可以按下<code>p</code>，将删除掉的内容放置到当前光标位置下一行（但是此时是放置（put）而不是粘贴）</li><li><code>P</code>：粘贴到上一行</li></ul><h3 id="当前行置顶"><a href="#当前行置顶" class="headerlink" title="当前行置顶"></a>当前行置顶</h3><ul><li><code>zt</code>：把当前行置于屏幕顶端，<code>z</code> 字取其象形意义，模拟一张纸的折叠变形，<code>t</code> 取 top 的首字母</li><li><code>zz</code>：将当前行至于屏幕中央</li><li><code>zb</code>：将当前行至于屏幕底端</li></ul><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><ul><li><code>&lt;</code>：选中文本后，向左缩进</li><li><code>&gt;</code>：选中文本后，向右缩进】</li></ul><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><ul><li><code>=</code>：通过 <code>V</code> 选中多行，然后按 <code>=</code> 格式化选中的文本</li></ul><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="E-inside和around"><a href="#E-inside和around" class="headerlink" title="[E]inside和around"></a>[E]inside和around</h3><p>对于 Vim 的删除命令 <code>d</code>，还有一类比较常用的操作是以 <code>i</code> （inside或 inner） 和 <code>a</code> （around） 为后缀的命令，用于删除以当前光标所在的语法元素内部或周围的字符。</p><ul><li><code>diw</code> 和 <code>daw</code>：前者删除当前光标所在的单词，后者会删除当前光标所在的单词与后面的空格</li><li><code>di(</code> 和 <code>da(</code>：前者会删除括号内的内容，后者还会删除括号本身。类似的还有<code>di[</code>、<code>da[</code>、<code>di{</code>、<code>da{</code>等</li><li><code>dib</code> 和 <code>dab</code>：等价于 <code>di(</code> 和 <code>da)</code>，<code>b</code> 表示 bracket</li><li><code>di"</code> 和 <code>da"</code>：前者删除双引号内的内容，后者还会删除引号本身</li><li><code>dit</code> 和 <code>dat</code>：修改 tag 包围的内容，vim 会自动将 <code>&lt;tag&gt;</code> 和 <code>&lt;/tag&gt;</code> 识别为一对 tag</li><li><code>dip</code>：删除当前整段 (paragraph) 的内容</li></ul><p>除了 <code>d</code> 命令，<code>c</code> / <code>v</code> / <code>gu</code> 等命令也可以和 inside、around 组合。比如 <code>ciw</code> 是修改当前单词，<code>viw</code> 是选中当前单词。</p><p>inside、around 也可以和上面的重复n次结合使用。比如光标位于 <code>(a * (b + c))</code> 的字符 <code>c</code> 时，按 <code>di(</code> 将删除内层括号里的 <code>b + c</code>，按 <code>d2i(</code> 将删除外层括号里的全部内容。</p><h3 id="F-查找文档中的关键字"><a href="#F-查找文档中的关键字" class="headerlink" title="[F]查找文档中的关键字"></a>[F]查找文档中的关键字</h3><p><code>/</code> 从光标所在位置向后查找关键字，<code>n</code> / <code>N</code> 查找下一个 / 上一个匹配的位置。</p><p><code>?</code> 向前查找，不过很少使用。如果想向前查找的话，使用 <code>/</code> + <code>N</code> 就可以了。</p><p><code>q/</code>、<code>q?</code> 可以列出 <code>/</code>、<code>?</code> 的查找历史，上下选择，按 <code>i</code> 编辑，回车执行，<code>:q</code>退出。</p><p><code>&lt;pattern&gt;</code> 可以是正则表达式，比如 <code>/vim$</code> 查找位于行尾的 <code>vim</code>。查找特殊字符时需要转义，比如 <code>/vim\$</code> 查找 <code>vim$</code>。</p><p>在查找模式中加入 <code>\c</code> 表示大小写不敏感查找，<code>\C</code> 表示大小写敏感，比如 <code>/foo\c</code> 会查找 <code>foo</code>、<code>Foo</code> 等。默认是大小写敏感，可以执行 <code>:set ignorecase</code> 或写入配置文件设置大小写不敏感为默认的查找模式。</p><h3 id="F-查找当前光标对应的完整单词"><a href="#F-查找当前光标对应的完整单词" class="headerlink" title="[F]查找当前光标对应的完整单词"></a>[F]查找当前光标对应的完整单词</h3><p>按下<code>*</code>，将向后查找，按下<code>#</code>是向前查找。</p><h3 id="F-在代码块匹配的括号之间跳转"><a href="#F-在代码块匹配的括号之间跳转" class="headerlink" title="[F]在代码块匹配的括号之间跳转"></a>[F]在代码块匹配的括号之间跳转</h3><p><code>%</code> 在匹配的括号之间跳转。需要将光标放在 <code>{}[]()</code> 上，然后按 <code>%</code>。 如果光标所在的位置不是 <code>{}[]()</code>，那么会向右查找第一个 <code>{}[]()</code>。</p><h3 id="F-光标跳转到前一个位置-后一个位置"><a href="#F-光标跳转到前一个位置-后一个位置" class="headerlink" title="[F]光标跳转到前一个位置/后一个位置"></a>[F]光标跳转到前一个位置/后一个位置</h3><p>在标准模式下，<code>&lt;Ctrl&gt; + o</code> 将光标跳转到前一个位置，<code>&lt;Ctrl&gt; + i</code> 跳转到后一个位置。<code>h</code> / <code>j</code>/ <code>k</code> / <code>l</code> / <code>w</code> 等移动将不会记录在「跳转表」中，只有通过 <code>gg</code> / <code>nG</code> / 查找时的 <code>n</code> / <code>N</code> 等命令执行的跳转操作，才可以通过 <code>&lt;Ctrl&gt; + o</code> / <code>&lt;Ctrl&gt; + i</code> 来回跳转。</p><ul><li>在 VS Code 中，向前一个 / 后一个位置跳转的快捷键是 <code>&lt;Ctrl&gt; + [</code> / <code>&lt;Ctrl&gt; + ]</code>。</li></ul><h3 id="F-E-替换文本"><a href="#F-E-替换文本" class="headerlink" title="[F][E]替换文本"></a>[F][E]替换文本</h3><p><code>:s</code>（substitute）命令用来查找和替换文本。语法如下：</p><pre class="line-numbers language-none"><code class="language-none">:{range}s/{old}/{new}/{flag}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示在指定范围 <code>range</code> 内查找字符串 <code>old</code> 并替换为 <code>new</code>，<code>flag</code> 说明了替换模式，如只替换首次出现、或全部替换。</p><p>作用范围<code>range</code>分为当前行、全文、行范围、选区等：</p><ul><li>当前行：空白，默认，如 <code>:s/foo/bar/g</code></li><li>全文：<code>%</code>，如 <code>:%s/foo/bar/g</code></li><li>n<del>m 行：<code>n,m</code>，如 <code>:5,12s/foo/bar/g</code> 表示 5</del>12 行</li><li>当前行与之后 n 行：<code>.,+n</code>，如 <code>:.,+2s/foo/bar/g</code> 表示当前行与之后 2 行</li><li>选区：略</li></ul><p>替换模式<code>flag</code>：</p><ul><li>空白：默认，只替换光标位置之后的首次出现，如 <code>:%s/foo/bar</code></li><li><code>g</code>：全局替换，替换每次出现（global），如 <code>:%s/foo/bar/g</code></li><li><code>i</code>：忽略大小写</li><li><code>c</code>：交互式替换，每次替换前需要用户确认（confirm），如 <code>:%s/foo/bar/gc</code> 表示查找全文的所有 <code>foo</code> 并替换为 <code>bar</code>，每次替换前都需要确认：<ul><li>按下回车执行后，提示 `replace with bar (y/n/a/q/l/^E/^Y)?``</li><li>``y` 表示替换</li><li><code>n</code> 表示不替换</li><li><code>a</code> 表示替换后续所有</li><li><code>q</code> 表示退出查找模式</li><li><code>l</code> 表示替换当前位置并退出查找模式</li><li><code>^E</code>、<code>^Y</code> 用于向上、向下滚动屏幕，<code>^</code> 表示 <code>&lt;Ctrl&gt;</code> 键</li></ul></li></ul><p><strong>也可以配合<code>v</code>可视模式选择替换区域</strong>。 首先按 <code>v</code> 进入可视模式，选择要替换的文本范围。接下来，输入替换命令：</p><pre class="line-numbers language-none"><code class="language-none">:'&lt;,'&gt;s/old_text/new_text/g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将在选择的区域内替换所有匹配到的 <code>old_text</code>。</p><h3 id="录制宏"><a href="#录制宏" class="headerlink" title="录制宏"></a>录制宏</h3><p>Vim 的宏提供了将一系列操作记录下来然后重复执行的机制。它可以大大提高重复性的操作效率。使用宏的步骤如下：</p><ol><li>录制宏。按下 <code>q</code> 键，然后再按下一个字母 (如 <code>a</code>，这是宏的名字)，开始录制宏。这时会在状态栏显示 <code>recording a</code>。在录制时，执行要重复的操作，包括移动、删除、插入等等。执行完操作后，按下 <code>q</code> 键结束录制。</li><li>执行宏。按下 <code>@</code> 键，然后在输入框中输入之前记录宏的字母 (如 <code>a</code>)，按下回车键即可执行宏。也可以连续执行多次，比如执行 10 次，只需在 <code>@a</code> 后面加上 <code>10</code> 即可。</li></ol><p>另外，按下 <code>v</code> 键进入 visual mode 选中多行，可以批量针对多行文本执行宏。使用 <code>:reg</code> 命令可以查看所有已经保存的宏。如果在执行宏时出现错误，可以通过使用 <code>:debug</code> 命令进入调试模式。</p><h3 id="在vim中执行shell命令"><a href="#在vim中执行shell命令" class="headerlink" title="在vim中执行shell命令"></a>在vim中执行shell命令</h3><p>比如通过 vim 编辑文本的时候，希望打印当前目录，但是又不想退出 vim，那么就可以直接在 vim 中执行：<code>:!pwd</code>，这等同于在 shell 中执行 <code>pwd</code>。</p><p>获得命令提示：</p><ul><li>在 vim 中输入 <code>:</code>，再按下 <code>&lt;Ctrl&gt; + d</code>，将展示所有可以在 vim 中使用的命令。</li><li>输入 <code>:w</code>，再按下 <code>&lt;Ctrl&gt; + d</code>，将展示所有可以在 vim 中使用的、以 <code>w</code> 开头的命令。</li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件位于 <code>~/.vimrc</code>，其内容是若干行可在 vim 中执行的命令，会在每次打开 vim 时自动执行。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missing-semester(2)-shell工具和脚本</title>
      <link href="/2025/02/08/8d29a533.html"/>
      <url>/2025/02/08/8d29a533.html</url>
      
        <content type="html"><![CDATA[<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><p>在shell中，空格十分重要。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>bar %可以执行$ foo <span class="token operator">=</span> bar %无法执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意单引号和双引号的区别。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"Value is <span class="token variable">$foo</span>"</span> %<span class="token variable">$foo</span>会转变为其对应的变量值$ <span class="token builtin class-name">echo</span> <span class="token string">'Value is $foo'</span> %<span class="token variable">$foo</span>不会转换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面是一个bash脚本的例子<code>mcd.sh</code>（创建以第一个参数为名的文件夹并进入）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function-name function">mcd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ppmkdir <span class="token parameter variable">-p</span> <span class="token string">"<span class="token variable">$1</span>"</span>ppcd <span class="token string">"<span class="token variable">$1</span>"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>$0</code>表示脚本自身的名字，<code>$1</code>到<code>$9</code>依次表示各个输入参数，<code>$_</code>是上一个指令的最后一个参数，<code>$?</code>可以获得上一个指令的错误代码，<code>!!</code>可以指代上一条指令。可以通过如下指令来加载新定义的函数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">source</span> mcd.sh %脚本中包含的函数会在当前shell中加载<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>逻辑符号：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token boolean">false</span> <span class="token operator">||</span> <span class="token builtin class-name">echo</span> <span class="token string">"Oops fail"</span> %如果第一条指令出错，则执行第二条指令$ <span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">"Things went well"</span> %如果第一条指令正确，才会执行第二条指令$ <span class="token boolean">false</span> <span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token string">"This will alwanys print"</span> %分号只是将两条指令分割开来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将某个指令的输出赋值给一个变量：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>$ <span class="token builtin class-name">echo</span> <span class="token string">"We are in <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>冷门特性——进程替换：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">ls</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">ls</span> <span class="token punctuation">..</span><span class="token punctuation">)</span> %<span class="token operator">&lt;</span><span class="token punctuation">(</span>命令<span class="token punctuation">)</span>相当于把该命令的输出作为一个临时文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面展示一个具体的例子（使用 <code>grep</code> 搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token string">"Starting program at <span class="token variable"><span class="token variable">$(</span><span class="token function">date</span><span class="token variable">)</span></span>"</span> <span class="token comment"># date会被替换成日期和时间</span><span class="token builtin class-name">echo</span> <span class="token string">"Running program <span class="token variable">$0</span> with <span class="token variable">$#</span> arguments with pid <span class="token variable">$$</span>"</span><span class="token comment"># $#表示输入参数的数目，$$表示当前进程的id</span><span class="token keyword">for</span> <span class="token for-or-select variable">file</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$@</span>"</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token comment"># $@表示所有的参数</span>    <span class="token function">grep</span> foobar <span class="token string">"<span class="token variable">$file</span>"</span> <span class="token operator">&gt;</span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> /dev/null    <span class="token comment"># 如果模式没有找到，则grep退出状态为 1</span>    <span class="token comment"># 我们将标准输出流(第一个&gt;)和标准错误流(2&gt;)重定向到Null，因为我们并不关心这些信息</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$?</span> <span class="token parameter variable">-ne</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token builtin class-name">echo</span> <span class="token string">"File <span class="token variable">$file</span> does not have any foobar, adding one"</span>        <span class="token builtin class-name">echo</span> <span class="token string">"# foobar"</span> <span class="token operator">&gt;&gt;</span> <span class="token string">"<span class="token variable">$file</span>"</span>    <span class="token keyword">fi</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接使用如下方式执行上述脚本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./example.sh <span class="token punctuation">[</span>文件1<span class="token punctuation">]</span> <span class="token punctuation">[</span>文件2<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>shell的通配（globbing）允许我们方便地进行文件匹配：</p><ul><li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件 <code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code> 这条命令会删除 <code>foo1</code> 和 <code>foo2</code> ，而 <code>rm foo*</code> 则会删除除了 <code>bar</code> 之外的所有文件。</li><li>花括号 <code>{}</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ convert image.<span class="token punctuation">{</span>png,jpg<span class="token punctuation">}</span> %会展开为convert image.png image.jpg$ <span class="token function">cp</span> /path/to/project/<span class="token punctuation">{</span>foo,bar,baz<span class="token punctuation">}</span>.sh /newpath %会展开为cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath$ <span class="token function">mv</span> *<span class="token punctuation">{</span>.py,.sh<span class="token punctuation">}</span> folder %移动所有以.py和.sh结尾的文件$ <span class="token function">touch</span> <span class="token punctuation">{</span>foo,bar<span class="token punctuation">}</span>/<span class="token punctuation">{</span>a<span class="token punctuation">..</span>j<span class="token punctuation">}</span> %展开为foo/a, foo/b, <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>脚本并不是一定只有用bash写才能在终端中调用，如下的Python脚本也可以直接在终端中调用：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/local/bin/python</span><span class="token keyword">import</span> sys<span class="token keyword">for</span> arg <span class="token keyword">in</span> <span class="token builtin">reversed</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>脚本中第一行的<code>shebang</code>使得终端知道应该调用python解释器。（也可以写为<code>#!/usr/bin/env python</code>）</p><p> 编写 <code>bash</code> 脚本有时候会很别扭和反直觉，<a href="https://github.com/koalaman/shellcheck">shellcheck</a> 这样的工具可以帮助你定位 sh/bash 脚本中的错误。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">shellcheck</span> mcd.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>shell 函数和脚本有如下一些不同点：</p><ul><li>函数只能与 shell 使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li><li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li><li>**函数会在当前的 shell 环境中执行，脚本会在单独的进程中执行。**因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <a href="https://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a> 将环境变量导出，并将值传递给环境变量。</li><li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell 脚本中往往也会包含它们自己的函数定义。</li></ul><h2 id="shell工具"><a href="#shell工具" class="headerlink" title="shell工具"></a>shell工具</h2><h3 id="查看命令实例"><a href="#查看命令实例" class="headerlink" title="查看命令实例"></a>查看命令实例</h3><p><code>convert</code>和<code>ffmpeg</code>这两个命令可以分别用于处理图片和视频。可以使用如下指令获得一些命令的简单例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tldr convert <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><p>通过如下指令可以找到所需的文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-name</span> src <span class="token parameter variable">-type</span> d %在当前文件夹中迭代找到名称为src的文件夹$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-path</span> <span class="token string">'**/test/*.py'</span> <span class="token parameter variable">-type</span> f %在当前文件夹中找到某些文件夹下包含在test子目录中的py文件$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-mtime</span> <span class="token parameter variable">-1</span> %在昨天被修改过的文件，mtime表示修改时间$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-name</span> <span class="token string">"*.tmp"</span> <span class="token parameter variable">-exec</span> <span class="token function">rm</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">\</span><span class="token punctuation">;</span> %找到这些文件并移除它们$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-name</span> <span class="token string">'*.png'</span> <span class="token parameter variable">-exec</span> convert <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>.jpg <span class="token punctuation">\</span><span class="token punctuation">;</span> %查找全部的 PNG 文件并将其转换为 JPG$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-size</span> +500k <span class="token parameter variable">-size</span> <span class="token parameter variable">-10M</span> <span class="token parameter variable">-name</span> <span class="token string">'*.tar.gz'</span> %查找所有大小在500k至10M的tar.gz文件$ fd <span class="token string">"*.py"</span> %具有和find相似的作用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以检索整个文件系统：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ updatedb %在执行查找前需要更新数据库$ <span class="token function">locate</span> tmp %找到整个文件系统中路径带有tmp的文件，注意是是路径中带有<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="查找内容"><a href="#查找内容" class="headerlink" title="查找内容"></a>查找内容</h3><p>如下方式可以查找文件中特定内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">grep</span> foobar mcd.sh %查找mcd.sh文件中的foobar$ <span class="token function">grep</span> <span class="token parameter variable">-R</span> foobar %在当前文件夹下查找文件中所有出现位置$ rg <span class="token string">"import requests"</span> <span class="token parameter variable">-t</span> py ~/scratch %在该文件夹下迭代搜索所有出现该内容的py文件$ rg <span class="token string">"import requests"</span> <span class="token parameter variable">-t</span> py <span class="token parameter variable">-C</span> <span class="token number">5</span> ~/scratch %输出时展示附近的5行内容$ rg <span class="token parameter variable">-u</span> --files-without-match <span class="token string">"^#\!"</span> <span class="token parameter variable">-t</span> <span class="token function">sh</span> %找到没有出现<span class="token string">"#!"</span>的文件，即没有shebang的文件，-u表示不要忽略隐藏文件$ rg <span class="token string">"import requests"</span> <span class="token parameter variable">-t</span> py <span class="token parameter variable">-C</span> <span class="token number">5</span> <span class="token parameter variable">--stats</span> PATTERN ~/scratch %打印更详细的检索信息$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>grep</code> 有很多选项，<code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。也出现了很多它的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。</p><h3 id="查找shell命令"><a href="#查找shell命令" class="headerlink" title="查找shell命令"></a>查找shell命令</h3><p>可以直接显示过往命令历史：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">history</span>$ <span class="token function">history</span> <span class="token operator">|</span> <span class="token function">grep</span> convert %先显示历史，再匹配对应的命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以使用<code>ctrl+R</code>，<code>fzf</code>可以进行模糊的检索（可以将其与<code>ctrl+R</code>绑定）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> example.sh <span class="token operator">|</span> fzf %进行可交互的查找<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录间随意切换呢？有很多简便的方法可以做到，比如设置 alias，使用 <a href="https://man7.org/linux/man-pages/man1/ln.1.html">ln -s</a> 创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p><p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用 <a href="https://github.com/clvv/fasd"><code>fasd</code></a> 和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p><p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm"><em>frecency</em> </a>对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em>）和时效（<em>recency</em>）进行排序。默认情况下，<code>fasd</code> 使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问 <code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用 <code>j cool</code> 代替即可。</p><p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tree %树状图显示文件结构$ broot %可交互的树状图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>命令行可以从参数或标准输入接受输入，在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如 <code>tar</code> 则需要从参数接受输入，而<code>xargs</code>可以使用标准输入中的内容作为参数，比如</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">rm</span> %删除当前文件夹下的所有文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/02/07/4a17b156.html"/>
      <url>/2025/02/07/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br>$$<br>\left{<br>\begin{matrix}<br>f(\vec x)=\frac{\sum\vec x}{2}\<br>f(\vec x)=\frac{\sum\vec x}{3}<br>\end{matrix}<br>\right.<br>$$</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missing-semester(1)-shell</title>
      <link href="/2025/02/07/fa4b86b9.html"/>
      <url>/2025/02/07/fa4b86b9.html</url>
      
        <content type="html"><![CDATA[<h2 id="shell基本使用"><a href="#shell基本使用" class="headerlink" title="shell基本使用"></a>shell基本使用</h2><p>如果需要同时输入多个argument，那么如下两种表达是等价的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> Hello<span class="token punctuation">\</span> World$ <span class="token builtin class-name">echo</span> <span class="token string">"Hello World"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>机器有其自身的内置函数，这些内置函数是终端系统可以直接执行的，机器通过<strong>环境变量</strong>来定位这些内置函数的位置。如下操作可以显示环境变量的位置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在每次执行一次shell指令时，终端都会在上述路径中搜索是否存在对应的函数。linux系统的namespace（路径的根源）一般只有一个，就是root，但是Windows一般有多个Driver作为路径根源。</p><p>显示当前工作路径位置（present working directory）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">pwd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>改变当前工作位置（change directory）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> xxx$ <span class="token builtin class-name">cd</span> - %回到上一次所在的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果环境变量中缺少你想要执行的指令所在的位置，那么可以在执行命令时直接指定其具体位置。</p><p>显示当前所在位置的所有文件（list d）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指令一般可以接受flags（开关）或者options（选择），可以指定一些额外的操作信息，可以用如下方式进行查看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token punctuation">[</span>指令<span class="token punctuation">]</span> <span class="token parameter variable">--help</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用如下指令后可以看到文件的具体信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">drwxr-xr-x <span class="token number">1</span> missing  <span class="token function">users</span>  <span class="token number">4096</span> Jun <span class="token number">15</span>  <span class="token number">2019</span> missing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一些关于上述文件的具体信息：</p><ul><li><code>d</code>开头表示<code>missing</code>是文件夹</li><li>每3个字符构成的3个组<code>rwx</code>用来依次表示文件所有者、用户组（users）以及其他所有人依次所具有的权限</li><li><code>-</code>表示某种类型的用户不具备相应的权限</li><li>上述信息表明只有文件所有者可以修改，其他用户只可以阅读或者执行</li></ul><p>还有一些常用指令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mv</span> <span class="token punctuation">[</span>旧名字<span class="token punctuation">]</span> <span class="token punctuation">[</span>新名字<span class="token punctuation">]</span> %对文件进行重命名$ <span class="token function">cp</span> <span class="token punctuation">[</span>原位置<span class="token punctuation">]</span> <span class="token punctuation">[</span>新位置<span class="token punctuation">]</span> %对文件进行复制$ <span class="token function">rm</span> <span class="token punctuation">[</span>文件位置<span class="token punctuation">]</span> %对文件进行删除$ <span class="token function">rmdir</span> <span class="token punctuation">[</span>文件夹<span class="token punctuation">]</span> %仅用于空文件夹的清除$ <span class="token function">mkdir</span> <span class="token punctuation">[</span>文件夹名<span class="token punctuation">]</span> %用于文件夹创建$ <span class="token function">man</span> <span class="token punctuation">[</span>指令或程序<span class="token punctuation">]</span> %显示程序的用户手册，按下q来退出$ ^L %清空终端，回到最上部分<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="建立程序间的连接"><a href="#建立程序间的连接" class="headerlink" title="建立程序间的连接"></a>建立程序间的连接</h2><p>指令一般都有输入流和输出流，<strong>最基本的输入流就是键盘，最基本的输出流就是终端</strong>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token operator">&lt;</span> <span class="token function">file</span> %将file的内容作为输入流$ <span class="token operator">&gt;</span> <span class="token function">file</span> %将输出流写入file（覆写）$ <span class="token builtin class-name">echo</span> hello <span class="token operator">&gt;</span> hello.txt %文件中的内容就是hello$ <span class="token function">cat</span> hello.txt %输出文件内容到终端$ <span class="token function">cat</span> <span class="token operator">&lt;</span> hello.txt %将hello.txt中内容作为cat的输入流$ <span class="token function">cat</span> <span class="token operator">&lt;</span> hello.txt <span class="token operator">&gt;</span> hello2.txt$ <span class="token operator">&gt;&gt;</span> <span class="token function">file</span> %将新信息添加到file中，而不是覆写$    <span class="token operator">|</span>   %pipe, 将左边程序的输出作为右边程序的输入$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> / <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-n1</span> %罗列/下的详细文件信息，给到右侧程序，右侧程序筛选出最后1条$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> / <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-n1</span> <span class="token operator">&gt;</span> ls.txt$ <span class="token function">curl</span> <span class="token parameter variable">--head</span> <span class="token parameter variable">--silent</span> google.com <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> content-length <span class="token operator">|</span> <span class="token function">cut</span> <span class="token parameter variable">--delimiter</span><span class="token operator">=</span><span class="token string">' '</span> <span class="token parameter variable">-f2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上可以通过简单的pipe来实现个人媒体直播，将自己的本地文件作为左侧程序，右侧程序则是向互联网发送数据。</p><h2 id="root用户"><a href="#root用户" class="headerlink" title="root用户"></a>root用户</h2><p>有时候需要作为root用户执行指令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token punctuation">[</span>指令<span class="token punctuation">]</span> %su意思是super<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过如下操作可以进入机器的内核系统，可以看到众多的内核参数，看起来就像文件系统一样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /sys %进入内核$ <span class="token builtin class-name">cd</span> class$ <span class="token builtin class-name">cd</span> backlight$ <span class="token builtin class-name">echo</span> <span class="token number">500</span> <span class="token operator">&gt;</span> brightness %无法执行，需要root权限$ <span class="token function">sudo</span> <span class="token builtin class-name">echo</span> <span class="token number">500</span> <span class="token operator">&gt;</span> brightness %仍然无法执行，因为sudo事实上只作用于echo，而没有作用于整个重定向<span class="token comment"># echo 1 &gt; /sys/net/ipv4_forward %加上井字号pound意味着要以root权限来执行该程序，这区别于美元符号</span>$ <span class="token function">sudo</span> <span class="token function">su</span> %执行该命令来切换为root权限<span class="token comment"># exit %退出root权限</span>$ <span class="token builtin class-name">echo</span> <span class="token number">500</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> brightness %如果不切换为root权限，也可以使用这个命令来修改机器背景光，tee可以读取输入流来写入文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如下命令可以打开文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">xdg-open</span> <span class="token punctuation">[</span>文件名<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
