<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>&#39;智能计算系统第1章-概述&#39;</title>
      <link href="/2025/02/11/4cc7c60c.html"/>
      <url>/2025/02/11/4cc7c60c.html</url>
      
        <content type="html"><![CDATA[<h2 id="三个流派"><a href="#三个流派" class="headerlink" title="三个流派"></a>三个流派</h2><ul><li>行为主义：基于控制论，构建感知-动作型控制系统，类似于小脑（强化学习）</li><li>符号主义：基于符号逻辑的方法，用逻辑表示知识和求解方法</li><li>连接主义：基于大脑中神经元细胞连接的计算模型，用人工神经网络来拟合智能行为</li></ul><p>tips：通过核心例子或观点将文章内容在introduction中串联起来，保证审稿人在前期就可以很快理解文章内容。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missing-semester(3)-vim</title>
      <link href="/2025/02/09/86d7b9fc.html"/>
      <url>/2025/02/09/86d7b9fc.html</url>
      
        <content type="html"><![CDATA[<p>本文参考<a href="https://imageslr.com/2021/vim.html">💻【Linux】Vim 入门笔记</a>，仅供自己查阅使用</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>vim编辑器是一种多模态编辑器，其允许用户切换不同的模式来进行不同的编辑任务：</p><ul><li>normal：最初始的模式，主要用于查询和移动</li><li>insert：<code>i</code></li><li>replace：<code>r</code></li><li>visual：<code>v</code></li><li>visual line：<code>shift-v</code></li><li>visual block：<code>ctrl-v</code></li><li>command line：<code>:</code></li></ul><h3 id="buffer-window-tab"><a href="#buffer-window-tab" class="headerlink" title="buffer, window, tab"></a>buffer, window, tab</h3><p>每一个buffer对应一个文件，一个window可以显示一个buffer（多个window可以对应同一个buffer），每一个tab可以打开多个window。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p><code>:</code>后输入命令</p><h3 id="退出vim"><a href="#退出vim" class="headerlink" title="退出vim"></a>退出vim</h3><ul><li><code>:q</code>或<code>:quit</code>：退出当前tab中所在window，直到最后一个window则退出tab</li><li><code>:q!</code>：退出并丢弃已有操作</li><li><code>:wq</code>：保存更改（write）并退出（quit）</li><li><code>ZZ</code>：等价于<code>:wq</code></li></ul><h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><ul><li><code>:w</code>：保存更改</li><li><code>:w &lt;filename&gt;</code>：将当前内容保存到新的文件中</li></ul><h3 id="M-基本移动"><a href="#M-基本移动" class="headerlink" title="[M]基本移动"></a>[M]基本移动</h3><p>使用<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>而不是左下右上的方向键</p><h3 id="M-前进到第一行或最后一行"><a href="#M-前进到第一行或最后一行" class="headerlink" title="[M]前进到第一行或最后一行"></a>[M]前进到第一行或最后一行</h3><ul><li><code>gg</code>：前往第一行</li><li><code>1G</code>：同<code>gg</code></li><li><code>G</code>：前往最后一行</li></ul><h3 id="M-前往第n行"><a href="#M-前往第n行" class="headerlink" title="[M]前往第n行"></a>[M]前往第n行</h3><ul><li><code>nG</code>：前往第n行，可以在标准模式下使用<code>set number</code>来显示行号</li><li><code>:n</code>：同样前往第n行</li></ul><h3 id="M-向右移动一个单词"><a href="#M-向右移动一个单词" class="headerlink" title="[M]向右移动一个单词"></a>[M]向右移动一个单词</h3><ul><li><code>w</code>：向右移动一个单词，光标处于首字符</li><li><code>e</code>：向右移动一个单词，光标落在当前单词的最后一个字符</li></ul><p>注意此处<strong>单词</strong>的定义是<strong>连续的「数字+字母+下划线」</strong>，或者<strong>连续的「特殊字符」</strong>。<code>hello, world!!!</code> 里包含 <code>hello</code>、<code>,</code>、<code>world</code> 和 <code>!!!</code> 四个单词。</p><ul><li><code>W</code>：向右移动一个<strong>连续的「非空字符」</strong>，光标处于首字符</li><li><code>E</code>：向右移动一个<strong>连续的「非空字符」</strong>，光标落在当前单词的最后一个字符</li></ul><h3 id="M-向左移动一个单词"><a href="#M-向左移动一个单词" class="headerlink" title="[M]向左移动一个单词"></a>[M]向左移动一个单词</h3><ul><li><code>b</code>：向左移动到前一个单词的首字符</li><li><code>ge</code>：向左移动到前一个单词的末尾</li><li><code>B</code>：向左移动一个<strong>连续的「非空字符」</strong></li><li><code>gE</code>：向左移动一个<strong>连续的「非空字符」</strong>，到末尾</li></ul><h3 id="M-前往当前行的开头和末尾字符"><a href="#M-前往当前行的开头和末尾字符" class="headerlink" title="[M]前往当前行的开头和末尾字符"></a>[M]前往当前行的开头和末尾字符</h3><ul><li><code>0</code>：前往开头</li><li><code>$</code>：前往末尾</li><li><code>_</code>：前往第一个非空字符（编写python等缩进代码时很有用）</li><li><code>^</code>：与<code>_</code>等价</li></ul><h3 id="E-删除字符"><a href="#E-删除字符" class="headerlink" title="[E]删除字符"></a>[E]删除字符</h3><ul><li><code>x</code>：删除当前字符</li><li><code>X</code>：删除前一个字符</li></ul><h3 id="E-删除单词"><a href="#E-删除单词" class="headerlink" title="[E]删除单词"></a>[E]删除单词</h3><ul><li><code>dw</code>：删除单词</li><li><code>dW</code>：删除下一个空格前的单词</li></ul><h3 id="E-删除当前行"><a href="#E-删除当前行" class="headerlink" title="[E]删除当前行"></a>[E]删除当前行</h3><ul><li><code>dd</code></li></ul><h3 id="E-在当前位置插入"><a href="#E-在当前位置插入" class="headerlink" title="[E]在当前位置插入"></a>[E]在当前位置插入</h3><ul><li><code>i</code>：在当前位置前面插入（insert）</li><li><code>a</code>：在当前位置后面插入（append）</li></ul><h3 id="E-在当前行开头或末尾插入"><a href="#E-在当前行开头或末尾插入" class="headerlink" title="[E]在当前行开头或末尾插入"></a>[E]在当前行开头或末尾插入</h3><ul><li><code>I</code>：在当前行开头插入</li><li><code>A</code>：在当前行末尾插入</li></ul><h3 id="E-在当前行上或下插入新的行"><a href="#E-在当前行上或下插入新的行" class="headerlink" title="[E]在当前行上或下插入新的行"></a>[E]在当前行上或下插入新的行</h3><ul><li><code>o</code>：在上面插入新的行</li><li><code>O</code>：在下面插入新的行</li></ul><h3 id="E-改变大小写"><a href="#E-改变大小写" class="headerlink" title="[E]改变大小写"></a>[E]改变大小写</h3><ul><li><code>~</code>：将光标下的字母改变大小写</li><li><code>gu&lt;motion&gt;</code>：指定范围的字母变成小写，比如 <code>guw</code> 是后一个单词全变成小写，<code>guj</code> 是当前整行改成小写</li><li><code>gU&lt;motion&gt;</code>：指定范围的字母变成大写</li><li><code>guu</code>：将当前行的字母改成小写</li><li><code>gUU</code>：将当前行的字母改成大写</li><li><code>guiw</code>：将光标所在的单词改成小写</li></ul><h3 id="F-移动到写一个指定字符"><a href="#F-移动到写一个指定字符" class="headerlink" title="[F]移动到写一个指定字符"></a>[F]移动到写一个指定字符</h3><ul><li><code>f&lt;target&gt;</code>：移动到下一个<code>&lt;target&gt;</code>出现的位置，比如<code>ft</code>就是移动到下一个<code>t</code>出现的位置</li><li><code>F&lt;target&gt;</code>：移动到前一个<code>&lt;target&gt;</code>出现的位置</li><li><code>t&lt;target&gt;</code>：类似于<code>f</code>，但是会移动到下一个指定字符之前</li><li><code>T&lt;target&gt;</code>：类似于<code>F</code>，但是会移动到前一个指定字符之后</li></ul><h3 id="E-撤销或重做"><a href="#E-撤销或重做" class="headerlink" title="[E]撤销或重做"></a>[E]撤销或重做</h3><ul><li><code>u</code>：撤销（undo）</li><li><code>&lt;ctrl&gt;+r</code>：重做（redo）</li></ul><h2 id="一些模式"><a href="#一些模式" class="headerlink" title="一些模式"></a>一些模式</h2><h3 id="重复n次操作"><a href="#重复n次操作" class="headerlink" title="重复n次操作"></a>重复n次操作</h3><p><code>n&lt;action&gt;</code>，重复n次<code>&lt;action&gt;</code>操作</p><h3 id="操作任意范围"><a href="#操作任意范围" class="headerlink" title="操作任意范围"></a>操作任意范围</h3><p><code>&lt;verb&gt;&lt;motion&gt;</code>，任意的操作<code>&lt;verb&gt;</code>都可以和范围<code>&lt;motion&gt;</code>拼接，使得指定一个范围进行操作。<code>w</code> 是跳到下一个单词的开头，那么 <code>dw</code> 就是删除到下一个单词的开头。</p><p>大部分命令都支持 <code>&lt;verb&gt;&lt;n&gt;&lt;motion&gt;</code> 和 <code>&lt;n&gt;&lt;verb&gt;&lt;motion&gt;</code> 两种模式，比如 <code>d2w</code> 和 <code>2dw</code> 都是删除后两个单词。</p><h3 id="命令大小写"><a href="#命令大小写" class="headerlink" title="命令大小写"></a>命令大小写</h3><p>不同的方向：</p><ul><li><code>x</code> 向右、<code>X</code> 向左</li><li><code>p</code> 向下、<code>P</code> 向上</li><li><code>o</code> 向下、<code>O</code> 向上</li><li><code>f</code> 向右、<code>F</code> 向左</li></ul><p>更严格的条件：</p><ul><li><code>w</code> 将特殊字符作为独立单词，<code>W</code> 只将空格作为单词分隔符</li><li><code>e</code> / <code>E</code>、<code>b</code> / <code>B</code> 同理</li></ul><p>更大的范围：</p><ul><li><code>a</code> 在当前位置后面插入、<code>A</code> 在当前行末尾插入</li><li><code>i</code> 在当前位置前插入、<code>I</code> 在当前行开始插入</li><li><code>d</code> 删除一个范围、<code>D</code> 删除到行末尾</li><li><code>c</code> 删除一个范围、<code>C</code> 删除到行末尾，并进入编辑模式</li><li><code>s</code> 删除当前字符，并进入编辑模式；<code>S</code> 删除当前整行，并进入编辑模式</li></ul><p>连续操作：</p><ul><li><code>r</code> 替换一个字符、<code>R</code> 连续替换多个字符直到按下 <code>&lt;Esc&gt;</code></li></ul><h3 id="两个字母重复"><a href="#两个字母重复" class="headerlink" title="两个字母重复"></a>两个字母重复</h3><p>两个 verb 字母重复，表示对当前整行操作：</p><ul><li><code>dd</code>：删除整行</li><li><code>cc</code>：删除整行，并进入编辑模式</li><li><code>yy</code>：复制整行</li><li><code>guu</code>：当前整行变成小写</li><li><code>gUU</code>：当前整行变成大写</li></ul><h3 id="重复上次操作"><a href="#重复上次操作" class="headerlink" title="重复上次操作"></a>重复上次操作</h3><ul><li><code>.</code>：重复上次的编辑操作</li><li><code>,</code>或<code>;</code>：重复当前行内的上一次 / 下一次 <code>f</code> 查找</li><li><code>n</code>或<code>N</code>：按 <code>/bar&lt;Enter&gt;</code> 搜索 <code>bar</code> 字符串后，按 <code>n</code> 可以查找下一个，按 <code>N</code> 查找上一个</li></ul><h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><h3 id="E-替换一个字符"><a href="#E-替换一个字符" class="headerlink" title="[E]替换一个字符"></a>[E]替换一个字符</h3><p><code>r</code>：再按下任意键，替换（replace）当前字符，等同于 <code>x</code> + <code>i</code>。</p><h3 id="E-替换连续多个字符"><a href="#E-替换连续多个字符" class="headerlink" title="[E]替换连续多个字符"></a>[E]替换连续多个字符</h3><p><code>R</code>：替换连续的多个字符，按下 <code>&lt;Esc&gt;</code> 可以退出替换模式。</p><h3 id="E-更改一个范围的内容"><a href="#E-更改一个范围的内容" class="headerlink" title="[E]更改一个范围的内容"></a>[E]更改一个范围的内容</h3><p><code>c</code>相当于将删除和进入编辑模式合二为一（change）。</p><ul><li><code>cw</code>：更改下一个单词，等同于<code>dw</code>+<code>i</code></li></ul><h3 id="E-删除当前字符并进入编辑模式"><a href="#E-删除当前字符并进入编辑模式" class="headerlink" title="[E]删除当前字符并进入编辑模式"></a>[E]删除当前字符并进入编辑模式</h3><p><code>s</code>等价于<code>x</code>+<code>i</code>。</p><h3 id="E-删除当前整行并进入编辑模式"><a href="#E-删除当前整行并进入编辑模式" class="headerlink" title="[E]删除当前整行并进入编辑模式"></a>[E]删除当前整行并进入编辑模式</h3><p><code>S</code>等价于<code>dd</code>+<code>o</code>。也可以用<code>cc</code>。</p><h3 id="E-从当前位置开始向右删除整行"><a href="#E-从当前位置开始向右删除整行" class="headerlink" title="[E]从当前位置开始向右删除整行"></a>[E]从当前位置开始向右删除整行</h3><p><code>D</code>等价于<code>d$</code>。</p><h3 id="E-从当前位置开始向右删除整行并进入编辑模式"><a href="#E-从当前位置开始向右删除整行并进入编辑模式" class="headerlink" title="[E]从当前位置开始向右删除整行并进入编辑模式"></a>[E]从当前位置开始向右删除整行并进入编辑模式</h3><p><code>C</code>等价于<code>c$</code>，或者<code>d$</code>+<code>a</code>，或者<code>D</code>+<code>a</code>。</p><h3 id="V-可视模式选择内容"><a href="#V-可视模式选择内容" class="headerlink" title="[V]可视模式选择内容"></a>[V]可视模式选择内容</h3><p>按下 <code>v</code> 进入可视模式（visual mode），然后移动光标以选择文本。可以针对选中的文本执行任意操作 (verb)，比如</p><ul><li>按下 <code>y</code> 可以复制选中的文本，再移动到别的位置按下 <code>p</code> 粘贴这些文本</li><li>按下 <code>d</code> 可以删除选中的文本</li></ul><p>按下 <code>ctrl + v</code>可以进入 Visual Block Mode，选择一个矩形块里的内容。</p><p>按下大写 <code>V</code> 可以选中整行。常见的使用技巧：</p><ul><li>按 <code>V</code> 选中整行，按 <code>j</code> 向下选中多行，然后 <code>y</code> 复制。</li><li>按 <code>V</code> 选中整行，按 <code>j</code> 向下选中多行，按 <code>&lt;</code> 向左缩进，按 <code>.</code> 继续缩进。</li><li>按 <code>V</code> 选中整行，按 <code>j</code> 向下选中多行，按 <code>=</code> 格式化。</li></ul><h3 id="复制单词"><a href="#复制单词" class="headerlink" title="复制单词"></a>复制单词</h3><p><code>y</code>可以进行复制（yank）。</p><ul><li><code>yw</code>：复制下一个单词</li></ul><p><code>y</code>和<code>c</code>、<code>d</code>一样可以和光标移动操作符相结合。</p><h3 id="复制当前行"><a href="#复制当前行" class="headerlink" title="复制当前行"></a>复制当前行</h3><ul><li><code>yy</code>：复制当前行</li><li><code>nyy</code>：复制当前行向下的n行，包括当前行</li><li><code>ynj</code>：同<code>nyy</code></li></ul><h3 id="粘贴到下一行或上一行"><a href="#粘贴到下一行或上一行" class="headerlink" title="粘贴到下一行或上一行"></a>粘贴到下一行或上一行</h3><ul><li><code>p</code>：粘贴复制内容到目标位置，使用<code>dd</code>删除某一行后，也可以按下<code>p</code>，将删除掉的内容放置到当前光标位置下一行（但是此时是放置（put）而不是粘贴）</li><li><code>P</code>：粘贴到上一行</li></ul><h3 id="当前行置顶"><a href="#当前行置顶" class="headerlink" title="当前行置顶"></a>当前行置顶</h3><ul><li><code>zt</code>：把当前行置于屏幕顶端，<code>z</code> 字取其象形意义，模拟一张纸的折叠变形，<code>t</code> 取 top 的首字母</li><li><code>zz</code>：将当前行至于屏幕中央</li><li><code>zb</code>：将当前行至于屏幕底端</li></ul><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><ul><li><code>&lt;</code>：选中文本后，向左缩进</li><li><code>&gt;</code>：选中文本后，向右缩进】</li></ul><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><ul><li><code>=</code>：通过 <code>V</code> 选中多行，然后按 <code>=</code> 格式化选中的文本</li></ul><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="E-inside和around"><a href="#E-inside和around" class="headerlink" title="[E]inside和around"></a>[E]inside和around</h3><p>对于 Vim 的删除命令 <code>d</code>，还有一类比较常用的操作是以 <code>i</code> （inside或 inner） 和 <code>a</code> （around） 为后缀的命令，用于删除以当前光标所在的语法元素内部或周围的字符。</p><ul><li><code>diw</code> 和 <code>daw</code>：前者删除当前光标所在的单词，后者会删除当前光标所在的单词与后面的空格</li><li><code>di(</code> 和 <code>da(</code>：前者会删除括号内的内容，后者还会删除括号本身。类似的还有<code>di[</code>、<code>da[</code>、<code>di{</code>、<code>da{</code>等</li><li><code>dib</code> 和 <code>dab</code>：等价于 <code>di(</code> 和 <code>da)</code>，<code>b</code> 表示 bracket</li><li><code>di"</code> 和 <code>da"</code>：前者删除双引号内的内容，后者还会删除引号本身</li><li><code>dit</code> 和 <code>dat</code>：修改 tag 包围的内容，vim 会自动将 <code>&lt;tag&gt;</code> 和 <code>&lt;/tag&gt;</code> 识别为一对 tag</li><li><code>dip</code>：删除当前整段 (paragraph) 的内容</li></ul><p>除了 <code>d</code> 命令，<code>c</code> / <code>v</code> / <code>gu</code> 等命令也可以和 inside、around 组合。比如 <code>ciw</code> 是修改当前单词，<code>viw</code> 是选中当前单词。</p><p>inside、around 也可以和上面的重复n次结合使用。比如光标位于 <code>(a * (b + c))</code> 的字符 <code>c</code> 时，按 <code>di(</code> 将删除内层括号里的 <code>b + c</code>，按 <code>d2i(</code> 将删除外层括号里的全部内容。</p><h3 id="F-查找文档中的关键字"><a href="#F-查找文档中的关键字" class="headerlink" title="[F]查找文档中的关键字"></a>[F]查找文档中的关键字</h3><p><code>/</code> 从光标所在位置向后查找关键字，<code>n</code> / <code>N</code> 查找下一个 / 上一个匹配的位置。</p><p><code>?</code> 向前查找，不过很少使用。如果想向前查找的话，使用 <code>/</code> + <code>N</code> 就可以了。</p><p><code>q/</code>、<code>q?</code> 可以列出 <code>/</code>、<code>?</code> 的查找历史，上下选择，按 <code>i</code> 编辑，回车执行，<code>:q</code>退出。</p><p><code>&lt;pattern&gt;</code> 可以是正则表达式，比如 <code>/vim$</code> 查找位于行尾的 <code>vim</code>。查找特殊字符时需要转义，比如 <code>/vim\$</code> 查找 <code>vim$</code>。</p><p>在查找模式中加入 <code>\c</code> 表示大小写不敏感查找，<code>\C</code> 表示大小写敏感，比如 <code>/foo\c</code> 会查找 <code>foo</code>、<code>Foo</code> 等。默认是大小写敏感，可以执行 <code>:set ignorecase</code> 或写入配置文件设置大小写不敏感为默认的查找模式。</p><h3 id="F-查找当前光标对应的完整单词"><a href="#F-查找当前光标对应的完整单词" class="headerlink" title="[F]查找当前光标对应的完整单词"></a>[F]查找当前光标对应的完整单词</h3><p>按下<code>*</code>，将向后查找，按下<code>#</code>是向前查找。</p><h3 id="F-在代码块匹配的括号之间跳转"><a href="#F-在代码块匹配的括号之间跳转" class="headerlink" title="[F]在代码块匹配的括号之间跳转"></a>[F]在代码块匹配的括号之间跳转</h3><p><code>%</code> 在匹配的括号之间跳转。需要将光标放在 <code>{}[]()</code> 上，然后按 <code>%</code>。 如果光标所在的位置不是 <code>{}[]()</code>，那么会向右查找第一个 <code>{}[]()</code>。</p><h3 id="F-光标跳转到前一个位置-后一个位置"><a href="#F-光标跳转到前一个位置-后一个位置" class="headerlink" title="[F]光标跳转到前一个位置/后一个位置"></a>[F]光标跳转到前一个位置/后一个位置</h3><p>在标准模式下，<code>&lt;Ctrl&gt; + o</code> 将光标跳转到前一个位置，<code>&lt;Ctrl&gt; + i</code> 跳转到后一个位置。<code>h</code> / <code>j</code>/ <code>k</code> / <code>l</code> / <code>w</code> 等移动将不会记录在「跳转表」中，只有通过 <code>gg</code> / <code>nG</code> / 查找时的 <code>n</code> / <code>N</code> 等命令执行的跳转操作，才可以通过 <code>&lt;Ctrl&gt; + o</code> / <code>&lt;Ctrl&gt; + i</code> 来回跳转。</p><ul><li>在 VS Code 中，向前一个 / 后一个位置跳转的快捷键是 <code>&lt;Ctrl&gt; + [</code> / <code>&lt;Ctrl&gt; + ]</code>。</li></ul><h3 id="F-E-替换文本"><a href="#F-E-替换文本" class="headerlink" title="[F][E]替换文本"></a>[F][E]替换文本</h3><p><code>:s</code>（substitute）命令用来查找和替换文本。语法如下：</p><pre class="line-numbers language-none"><code class="language-none">:{range}s/{old}/{new}/{flag}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示在指定范围 <code>range</code> 内查找字符串 <code>old</code> 并替换为 <code>new</code>，<code>flag</code> 说明了替换模式，如只替换首次出现、或全部替换。</p><p>作用范围<code>range</code>分为当前行、全文、行范围、选区等：</p><ul><li>当前行：空白，默认，如 <code>:s/foo/bar/g</code></li><li>全文：<code>%</code>，如 <code>:%s/foo/bar/g</code></li><li>n~m 行：<code>n,m</code>，如 <code>:5,12s/foo/bar/g</code> 表示 5~12 行</li><li>当前行与之后 n 行：<code>.,+n</code>，如 <code>:.,+2s/foo/bar/g</code> 表示当前行与之后 2 行</li><li>选区：略</li></ul><p>替换模式<code>flag</code>：</p><ul><li>空白：默认，只替换光标位置之后的首次出现，如 <code>:%s/foo/bar</code></li><li><code>g</code>：全局替换，替换每次出现（global），如 <code>:%s/foo/bar/g</code></li><li><code>i</code>：忽略大小写</li><li><code>c</code>：交互式替换，每次替换前需要用户确认（confirm），如 <code>:%s/foo/bar/gc</code> 表示查找全文的所有 <code>foo</code> 并替换为 <code>bar</code>，每次替换前都需要确认：<ul><li>按下回车执行后，提示 `replace with bar (y/n/a/q/l/^E/^Y)?``</li><li><code>`y</code> 表示替换</li><li><code>n</code> 表示不替换</li><li><code>a</code> 表示替换后续所有</li><li><code>q</code> 表示退出查找模式</li><li><code>l</code> 表示替换当前位置并退出查找模式</li><li><code>^E</code>、<code>^Y</code> 用于向上、向下滚动屏幕，<code>^</code> 表示 <code>&lt;Ctrl&gt;</code> 键</li></ul></li></ul><p><strong>也可以配合<code>v</code>可视模式选择替换区域</strong>。 首先按 <code>v</code> 进入可视模式，选择要替换的文本范围。接下来，输入替换命令：</p><pre class="line-numbers language-none"><code class="language-none">:'&lt;,'&gt;s/old_text/new_text/g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将在选择的区域内替换所有匹配到的 <code>old_text</code>。</p><h3 id="录制宏"><a href="#录制宏" class="headerlink" title="录制宏"></a>录制宏</h3><p>Vim 的宏提供了将一系列操作记录下来然后重复执行的机制。它可以大大提高重复性的操作效率。使用宏的步骤如下：</p><ol><li>录制宏。按下 <code>q</code> 键，然后再按下一个字母 (如 <code>a</code>，这是宏的名字)，开始录制宏。这时会在状态栏显示 <code>recording a</code>。在录制时，执行要重复的操作，包括移动、删除、插入等等。执行完操作后，按下 <code>q</code> 键结束录制。</li><li>执行宏。按下 <code>@</code> 键，然后在输入框中输入之前记录宏的字母 (如 <code>a</code>)，按下回车键即可执行宏。也可以连续执行多次，比如执行 10 次，只需在 <code>@a</code> 后面加上 <code>10</code> 即可。</li></ol><p>另外，按下 <code>v</code> 键进入 visual mode 选中多行，可以批量针对多行文本执行宏。使用 <code>:reg</code> 命令可以查看所有已经保存的宏。如果在执行宏时出现错误，可以通过使用 <code>:debug</code> 命令进入调试模式。</p><h3 id="在vim中执行shell命令"><a href="#在vim中执行shell命令" class="headerlink" title="在vim中执行shell命令"></a>在vim中执行shell命令</h3><p>比如通过 vim 编辑文本的时候，希望打印当前目录，但是又不想退出 vim，那么就可以直接在 vim 中执行：<code>:!pwd</code>，这等同于在 shell 中执行 <code>pwd</code>。</p><p>获得命令提示：</p><ul><li>在 vim 中输入 <code>:</code>，再按下 <code>&lt;Ctrl&gt; + d</code>，将展示所有可以在 vim 中使用的命令。</li><li>输入 <code>:w</code>，再按下 <code>&lt;Ctrl&gt; + d</code>，将展示所有可以在 vim 中使用的、以 <code>w</code> 开头的命令。</li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件位于 <code>~/.vimrc</code>，其内容是若干行可在 vim 中执行的命令，会在每次打开 vim 时自动执行。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missing-semester(2)-shell工具和脚本</title>
      <link href="/2025/02/08/8d29a533.html"/>
      <url>/2025/02/08/8d29a533.html</url>
      
        <content type="html"><![CDATA[<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><p>在shell中，空格十分重要。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>bar %可以执行$ foo <span class="token operator">=</span> bar %无法执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意单引号和双引号的区别。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"Value is <span class="token variable">$foo</span>"</span> %<span class="token variable">$foo</span>会转变为其对应的变量值$ <span class="token builtin class-name">echo</span> <span class="token string">'Value is $foo'</span> %<span class="token variable">$foo</span>不会转换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面是一个bash脚本的例子<code>mcd.sh</code>（创建以第一个参数为名的文件夹并进入）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function-name function">mcd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ppmkdir <span class="token parameter variable">-p</span> <span class="token string">"<span class="token variable">$1</span>"</span>ppcd <span class="token string">"<span class="token variable">$1</span>"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>$0</code>表示脚本自身的名字，<code>$1</code>到<code>$9</code>依次表示各个输入参数，<code>$_</code>是上一个指令的最后一个参数，<code>$?</code>可以获得上一个指令的错误代码，<code>!!</code>可以指代上一条指令。可以通过如下指令来加载新定义的函数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">source</span> mcd.sh %脚本中包含的函数会在当前shell中加载<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>逻辑符号：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token boolean">false</span> <span class="token operator">||</span> <span class="token builtin class-name">echo</span> <span class="token string">"Oops fail"</span> %如果第一条指令出错，则执行第二条指令$ <span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">"Things went well"</span> %如果第一条指令正确，才会执行第二条指令$ <span class="token boolean">false</span> <span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token string">"This will alwanys print"</span> %分号只是将两条指令分割开来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将某个指令的输出赋值给一个变量：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>$ <span class="token builtin class-name">echo</span> <span class="token string">"We are in <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>冷门特性——进程替换：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">ls</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">ls</span> <span class="token punctuation">..</span><span class="token punctuation">)</span> %<span class="token operator">&lt;</span><span class="token punctuation">(</span>命令<span class="token punctuation">)</span>相当于把该命令的输出作为一个临时文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面展示一个具体的例子（使用 <code>grep</code> 搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token string">"Starting program at <span class="token variable"><span class="token variable">$(</span><span class="token function">date</span><span class="token variable">)</span></span>"</span> <span class="token comment"># date会被替换成日期和时间</span><span class="token builtin class-name">echo</span> <span class="token string">"Running program <span class="token variable">$0</span> with <span class="token variable">$#</span> arguments with pid <span class="token variable">$$</span>"</span><span class="token comment"># $#表示输入参数的数目，$$表示当前进程的id</span><span class="token keyword">for</span> <span class="token for-or-select variable">file</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$@</span>"</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token comment"># $@表示所有的参数</span>    <span class="token function">grep</span> foobar <span class="token string">"<span class="token variable">$file</span>"</span> <span class="token operator">&gt;</span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> /dev/null    <span class="token comment"># 如果模式没有找到，则grep退出状态为 1</span>    <span class="token comment"># 我们将标准输出流(第一个&gt;)和标准错误流(2&gt;)重定向到Null，因为我们并不关心这些信息</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$?</span> <span class="token parameter variable">-ne</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token builtin class-name">echo</span> <span class="token string">"File <span class="token variable">$file</span> does not have any foobar, adding one"</span>        <span class="token builtin class-name">echo</span> <span class="token string">"# foobar"</span> <span class="token operator">&gt;&gt;</span> <span class="token string">"<span class="token variable">$file</span>"</span>    <span class="token keyword">fi</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接使用如下方式执行上述脚本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./example.sh <span class="token punctuation">[</span>文件1<span class="token punctuation">]</span> <span class="token punctuation">[</span>文件2<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>shell的通配（globbing）允许我们方便地进行文件匹配：</p><ul><li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件 <code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code> 这条命令会删除 <code>foo1</code> 和 <code>foo2</code> ，而 <code>rm foo*</code> 则会删除除了 <code>bar</code> 之外的所有文件。</li><li>花括号 <code>{}</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ convert image.<span class="token punctuation">{</span>png,jpg<span class="token punctuation">}</span> %会展开为convert image.png image.jpg$ <span class="token function">cp</span> /path/to/project/<span class="token punctuation">{</span>foo,bar,baz<span class="token punctuation">}</span>.sh /newpath %会展开为cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath$ <span class="token function">mv</span> *<span class="token punctuation">{</span>.py,.sh<span class="token punctuation">}</span> folder %移动所有以.py和.sh结尾的文件$ <span class="token function">touch</span> <span class="token punctuation">{</span>foo,bar<span class="token punctuation">}</span>/<span class="token punctuation">{</span>a<span class="token punctuation">..</span>j<span class="token punctuation">}</span> %展开为foo/a, foo/b, <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>脚本并不是一定只有用bash写才能在终端中调用，如下的Python脚本也可以直接在终端中调用：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/local/bin/python</span><span class="token keyword">import</span> sys<span class="token keyword">for</span> arg <span class="token keyword">in</span> <span class="token builtin">reversed</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>脚本中第一行的<code>shebang</code>使得终端知道应该调用python解释器。（也可以写为<code>#!/usr/bin/env python</code>）</p><p> 编写 <code>bash</code> 脚本有时候会很别扭和反直觉，<a href="https://github.com/koalaman/shellcheck">shellcheck</a> 这样的工具可以帮助你定位 sh/bash 脚本中的错误。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">shellcheck</span> mcd.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>shell 函数和脚本有如下一些不同点：</p><ul><li>函数只能与 shell 使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li><li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li><li><strong>函数会在当前的 shell 环境中执行，脚本会在单独的进程中执行。</strong>因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <a href="https://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a> 将环境变量导出，并将值传递给环境变量。</li><li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell 脚本中往往也会包含它们自己的函数定义。</li></ul><h2 id="shell工具"><a href="#shell工具" class="headerlink" title="shell工具"></a>shell工具</h2><h3 id="查看命令实例"><a href="#查看命令实例" class="headerlink" title="查看命令实例"></a>查看命令实例</h3><p><code>convert</code>和<code>ffmpeg</code>这两个命令可以分别用于处理图片和视频。可以使用如下指令获得一些命令的简单例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tldr convert <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><p>通过如下指令可以找到所需的文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-name</span> src <span class="token parameter variable">-type</span> d %在当前文件夹中迭代找到名称为src的文件夹$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-path</span> <span class="token string">'**/test/*.py'</span> <span class="token parameter variable">-type</span> f %在当前文件夹中找到某些文件夹下包含在test子目录中的py文件$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-mtime</span> <span class="token parameter variable">-1</span> %在昨天被修改过的文件，mtime表示修改时间$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-name</span> <span class="token string">"*.tmp"</span> <span class="token parameter variable">-exec</span> <span class="token function">rm</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">\</span><span class="token punctuation">;</span> %找到这些文件并移除它们$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-name</span> <span class="token string">'*.png'</span> <span class="token parameter variable">-exec</span> convert <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>.jpg <span class="token punctuation">\</span><span class="token punctuation">;</span> %查找全部的 PNG 文件并将其转换为 JPG$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-size</span> +500k <span class="token parameter variable">-size</span> <span class="token parameter variable">-10M</span> <span class="token parameter variable">-name</span> <span class="token string">'*.tar.gz'</span> %查找所有大小在500k至10M的tar.gz文件$ fd <span class="token string">"*.py"</span> %具有和find相似的作用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以检索整个文件系统：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ updatedb %在执行查找前需要更新数据库$ <span class="token function">locate</span> tmp %找到整个文件系统中路径带有tmp的文件，注意是是路径中带有<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="查找内容"><a href="#查找内容" class="headerlink" title="查找内容"></a>查找内容</h3><p>如下方式可以查找文件中特定内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">grep</span> foobar mcd.sh %查找mcd.sh文件中的foobar$ <span class="token function">grep</span> <span class="token parameter variable">-R</span> foobar %在当前文件夹下查找文件中所有出现位置$ rg <span class="token string">"import requests"</span> <span class="token parameter variable">-t</span> py ~/scratch %在该文件夹下迭代搜索所有出现该内容的py文件$ rg <span class="token string">"import requests"</span> <span class="token parameter variable">-t</span> py <span class="token parameter variable">-C</span> <span class="token number">5</span> ~/scratch %输出时展示附近的5行内容$ rg <span class="token parameter variable">-u</span> --files-without-match <span class="token string">"^#\!"</span> <span class="token parameter variable">-t</span> <span class="token function">sh</span> %找到没有出现<span class="token string">"#!"</span>的文件，即没有shebang的文件，-u表示不要忽略隐藏文件$ rg <span class="token string">"import requests"</span> <span class="token parameter variable">-t</span> py <span class="token parameter variable">-C</span> <span class="token number">5</span> <span class="token parameter variable">--stats</span> PATTERN ~/scratch %打印更详细的检索信息$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>grep</code> 有很多选项，<code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。也出现了很多它的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。</p><h3 id="查找shell命令"><a href="#查找shell命令" class="headerlink" title="查找shell命令"></a>查找shell命令</h3><p>可以直接显示过往命令历史：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">history</span>$ <span class="token function">history</span> <span class="token operator">|</span> <span class="token function">grep</span> convert %先显示历史，再匹配对应的命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以使用<code>ctrl+R</code>，<code>fzf</code>可以进行模糊的检索（可以将其与<code>ctrl+R</code>绑定）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> example.sh <span class="token operator">|</span> fzf %进行可交互的查找<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录间随意切换呢？有很多简便的方法可以做到，比如设置 alias，使用 <a href="https://man7.org/linux/man-pages/man1/ln.1.html">ln -s</a> 创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p><p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用 <a href="https://github.com/clvv/fasd"><code>fasd</code></a> 和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p><p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm"><em>frecency</em> </a>对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em>）和时效（<em>recency</em>）进行排序。默认情况下，<code>fasd</code> 使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问 <code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用 <code>j cool</code> 代替即可。</p><p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tree %树状图显示文件结构$ broot %可交互的树状图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>命令行可以从参数或标准输入接受输入，在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如 <code>tar</code> 则需要从参数接受输入，而<code>xargs</code>可以使用标准输入中的内容作为参数，比如</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">rm</span> %删除当前文件夹下的所有文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/02/07/4a17b156.html"/>
      <url>/2025/02/07/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><script type="math/tex; mode=display">\left\{\begin{matrix}f(\vec x)=\frac{\sum\vec x}{2}\\f(\vec x)=\frac{\sum\vec x}{3}\end{matrix}\right.</script><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missing-semester(1)-shell</title>
      <link href="/2025/02/07/fa4b86b9.html"/>
      <url>/2025/02/07/fa4b86b9.html</url>
      
        <content type="html"><![CDATA[<h2 id="shell基本使用"><a href="#shell基本使用" class="headerlink" title="shell基本使用"></a>shell基本使用</h2><p>如果需要同时输入多个argument，那么如下两种表达是等价的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> Hello<span class="token punctuation">\</span> World$ <span class="token builtin class-name">echo</span> <span class="token string">"Hello World"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>机器有其自身的内置函数，这些内置函数是终端系统可以直接执行的，机器通过<strong>环境变量</strong>来定位这些内置函数的位置。如下操作可以显示环境变量的位置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在每次执行一次shell指令时，终端都会在上述路径中搜索是否存在对应的函数。linux系统的namespace（路径的根源）一般只有一个，就是root，但是Windows一般有多个Driver作为路径根源。</p><p>显示当前工作路径位置（present working directory）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">pwd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>改变当前工作位置（change directory）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> xxx$ <span class="token builtin class-name">cd</span> - %回到上一次所在的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果环境变量中缺少你想要执行的指令所在的位置，那么可以在执行命令时直接指定其具体位置。</p><p>显示当前所在位置的所有文件（list d）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指令一般可以接受flags（开关）或者options（选择），可以指定一些额外的操作信息，可以用如下方式进行查看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token punctuation">[</span>指令<span class="token punctuation">]</span> <span class="token parameter variable">--help</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用如下指令后可以看到文件的具体信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">drwxr-xr-x <span class="token number">1</span> missing  <span class="token function">users</span>  <span class="token number">4096</span> Jun <span class="token number">15</span>  <span class="token number">2019</span> missing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一些关于上述文件的具体信息：</p><ul><li><code>d</code>开头表示<code>missing</code>是文件夹</li><li>每3个字符构成的3个组<code>rwx</code>用来依次表示文件所有者、用户组（users）以及其他所有人依次所具有的权限</li><li><code>-</code>表示某种类型的用户不具备相应的权限</li><li>上述信息表明只有文件所有者可以修改，其他用户只可以阅读或者执行</li></ul><p>还有一些常用指令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mv</span> <span class="token punctuation">[</span>旧名字<span class="token punctuation">]</span> <span class="token punctuation">[</span>新名字<span class="token punctuation">]</span> %对文件进行重命名$ <span class="token function">cp</span> <span class="token punctuation">[</span>原位置<span class="token punctuation">]</span> <span class="token punctuation">[</span>新位置<span class="token punctuation">]</span> %对文件进行复制$ <span class="token function">rm</span> <span class="token punctuation">[</span>文件位置<span class="token punctuation">]</span> %对文件进行删除$ <span class="token function">rmdir</span> <span class="token punctuation">[</span>文件夹<span class="token punctuation">]</span> %仅用于空文件夹的清除$ <span class="token function">mkdir</span> <span class="token punctuation">[</span>文件夹名<span class="token punctuation">]</span> %用于文件夹创建$ <span class="token function">man</span> <span class="token punctuation">[</span>指令或程序<span class="token punctuation">]</span> %显示程序的用户手册，按下q来退出$ ^L %清空终端，回到最上部分<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="建立程序间的连接"><a href="#建立程序间的连接" class="headerlink" title="建立程序间的连接"></a>建立程序间的连接</h2><p>指令一般都有输入流和输出流，<strong>最基本的输入流就是键盘，最基本的输出流就是终端</strong>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token operator">&lt;</span> <span class="token function">file</span> %将file的内容作为输入流$ <span class="token operator">&gt;</span> <span class="token function">file</span> %将输出流写入file（覆写）$ <span class="token builtin class-name">echo</span> hello <span class="token operator">&gt;</span> hello.txt %文件中的内容就是hello$ <span class="token function">cat</span> hello.txt %输出文件内容到终端$ <span class="token function">cat</span> <span class="token operator">&lt;</span> hello.txt %将hello.txt中内容作为cat的输入流$ <span class="token function">cat</span> <span class="token operator">&lt;</span> hello.txt <span class="token operator">&gt;</span> hello2.txt$ <span class="token operator">&gt;&gt;</span> <span class="token function">file</span> %将新信息添加到file中，而不是覆写$    <span class="token operator">|</span>   %pipe, 将左边程序的输出作为右边程序的输入$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> / <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-n1</span> %罗列/下的详细文件信息，给到右侧程序，右侧程序筛选出最后1条$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> / <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-n1</span> <span class="token operator">&gt;</span> ls.txt$ <span class="token function">curl</span> <span class="token parameter variable">--head</span> <span class="token parameter variable">--silent</span> google.com <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> content-length <span class="token operator">|</span> <span class="token function">cut</span> <span class="token parameter variable">--delimiter</span><span class="token operator">=</span><span class="token string">' '</span> <span class="token parameter variable">-f2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上可以通过简单的pipe来实现个人媒体直播，将自己的本地文件作为左侧程序，右侧程序则是向互联网发送数据。</p><h2 id="root用户"><a href="#root用户" class="headerlink" title="root用户"></a>root用户</h2><p>有时候需要作为root用户执行指令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token punctuation">[</span>指令<span class="token punctuation">]</span> %su意思是super<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过如下操作可以进入机器的内核系统，可以看到众多的内核参数，看起来就像文件系统一样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /sys %进入内核$ <span class="token builtin class-name">cd</span> class$ <span class="token builtin class-name">cd</span> backlight$ <span class="token builtin class-name">echo</span> <span class="token number">500</span> <span class="token operator">&gt;</span> brightness %无法执行，需要root权限$ <span class="token function">sudo</span> <span class="token builtin class-name">echo</span> <span class="token number">500</span> <span class="token operator">&gt;</span> brightness %仍然无法执行，因为sudo事实上只作用于echo，而没有作用于整个重定向<span class="token comment"># echo 1 &gt; /sys/net/ipv4_forward %加上井字号pound意味着要以root权限来执行该程序，这区别于美元符号</span>$ <span class="token function">sudo</span> <span class="token function">su</span> %执行该命令来切换为root权限<span class="token comment"># exit %退出root权限</span>$ <span class="token builtin class-name">echo</span> <span class="token number">500</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> brightness %如果不切换为root权限，也可以使用这个命令来修改机器背景光，tee可以读取输入流来写入文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如下命令可以打开文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">xdg-open</span> <span class="token punctuation">[</span>文件名<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
